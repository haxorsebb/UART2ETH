var documents = [

{
    "id": 0,
    "uri": "adrs/ADR-003-programming-language-selection.html",
    "menu": "adrs",
    "title": "ADR-003: Programming Language Selection for UART2ETH",
    "text": " Table of Contents ADR-003: Programming Language Selection for UART2ETH Context Decision Drivers Options Considered PUGH Matrix Analysis Decision Rationale Consequences Implementation Notes Follow-up Actions ADR-003: Programming Language Selection for UART2ETH Status: PROPOSED Date: 2025-07-26 Deciders: Architecture Team Consulted: Senior Developer Informed: Development Team Context The UART2ETH system requires selecting a programming language for firmware development on the RP2350 microcontroller. This decision directly impacts development velocity, system reliability, maintainability, and the ability to meet project delivery timelines. Based on hardware platform decisions (ADR-001: RP2350 selection, ADR-002: ENC28J60 selection), we need a programming language that can: Deliver industrial-grade reliability for 4 concurrent UART-to-TCP bridges Support real-time performance requirements (500 kbps per port, sub-5ms latency) Enable rapid development with existing team expertise Operate efficiently in severely memory-constrained environment (520KB SRAM, static allocation) Provide adequate safety guarantees for industrial deployment Meet aggressive project delivery timeline (\"deliver yesterday\") Must operate reliably in industrial environments (-40¬∞C to +85¬∞C) üòâ The programming language selection fundamentally determines development productivity, code maintainability, and the feasibility of meeting project deadlines with current team capabilities. Decision Drivers Primary Requirements Development Velocity : Critical time-to-market pressure requiring immediate productivity Team Expertise : Leveraging existing microcontroller team&#8217;s deep C experience Industrial Reliability : Proven track record in embedded industrial applications Memory Model Fit : Optimal performance in static memory allocation environment Ecosystem Maturity : Comprehensive tooling, libraries, and vendor support Real-time Determinism : Predictable behavior for latency-critical applications Hardware Integration : Direct access to RP2350 and ENC28J60 peripherals Debugging Capabilities : Mature debugging tools for embedded development Constraints Aggressive delivery timeline with no room for learning curve delays Small project scope where complexity management is achievable Static memory allocation model (no dynamic allocation) Team expertise concentrated in C/C++ embedded development Must operate reliably in industrial environments (-40¬∞C to +85¬∞C) üòâ Options Considered Option A: C Programming Language Ecosystem : Mature ecosystem with comprehensive RP2350 Pico SDK support Team Expertise : Deep existing knowledge in microcontroller team Development Velocity : Immediate productivity, no learning curve Memory Model : Direct, predictable memory management with static allocation Tooling : Mature debugging (GDB, OpenOCD), profiling, and analysis tools Hardware Support : Full vendor support for RP2350 and ENC28J60 Industrial Track Record : Decades of proven deployment in embedded systems Real-time Performance : Deterministic, low-level control over hardware Memory Safety : Achievable through disciplined practices and comprehensive testing Standards Compliance : MISRA-C guidelines for industrial safety Option B: Rust Programming Language Ecosystem : Emerging ecosystem with excellent RP2350 day-one support (rp235x-hal) Team Expertise : No existing knowledge, 6-12 month learning curve to proficiency Development Velocity : Significant initial productivity loss during team transition Memory Model : Memory safety guarantees less relevant in static allocation environment Tooling : Improving but less mature debugging tools (probe-rs vs GDB) Hardware Support : Good RP2350 support, limited ENC28J60 ecosystem Industrial Track Record : Limited embedded deployment history Real-time Performance : Embassy framework provides async capabilities Memory Safety : Compile-time guarantees prevent entire classes of bugs Modern Features : Advanced type system, zero-cost abstractions PUGH Matrix Analysis Scoring: Better than baseline (+1, +2), Same as baseline (0), Worse than baseline (-1, -2) Baseline: C Programming Language (all scores = 0) Criteria Weight C Language Rust Language Development Velocity 3 0 (baseline) -2 (6-12 month learning curve) Team Expertise 3 0 (baseline) -2 (zero existing knowledge) Time to Market 3 0 (baseline) -2 (immediate productivity loss) Ecosystem Maturity 2 0 (baseline) -1 (emerging, less comprehensive) Memory Safety in Static Environment 2 0 (baseline) +1 (compile-time checks, limited benefit) Industrial Track Record 2 0 (baseline) -1 (limited embedded deployment) Hardware Vendor Support 2 0 (baseline) -1 (good RP2350, limited ENC28J60) Debugging Maturity 2 0 (baseline) -1 (improving but less mature) Real-time Determinism 2 0 (baseline) 0 (comparable with Embassy) Code Maintainability 3 0 (baseline) +1 (better type system) Future Proofing 4 0 (baseline) +2 (modern language, industry trend) TOTAL WEIGHTED SCORE 0 -13 Decision Selected: C Programming Language The C programming language provides the optimal balance of development velocity, team productivity, and technical capability for the UART2ETH project, scoring significantly higher in our weighted analysis. Rationale Why C Over Rust Immediate Productivity : Team can begin productive development immediately without learning curve delays Time-Critical Delivery : Project timeline (\"deliver yesterday\") cannot accommodate 6-12 month Rust learning curve Static Memory Context : Rust&#8217;s primary advantages (memory safety) are significantly diminished in our static allocation environment where: No dynamic allocation eliminates use-after-free, double-free, memory leaks Fixed buffer sizes and lifetimes reduce dangling pointer risks Predictable memory layout simplifies debugging and validation Team Expertise Leverage : Deep microcontroller C experience translates to immediate high-quality code Ecosystem Maturity : Comprehensive vendor support, mature tooling, extensive industrial deployment history Manageable Complexity : Small project scope where C complexity is controllable through: Disciplined coding practices (MISRA-C guidelines) Comprehensive unit and integration testing Code reviews focused on memory safety patterns Static analysis tools Memory Safety Strategy in C Static Allocation : All memory allocated at compile time, eliminating dynamic memory risks Defensive Programming : Bounds checking, input validation, error handling Testing Strategy : 100% code coverage, stress testing, hardware-in-the-loop validation Code Standards : MISRA-C compliance for industrial safety Review Process : Mandatory security-focused code reviews Rust Advantages Acknowledged But Outweighed Compile-time Memory Safety : Valuable but less critical in static allocation environment Modern Type System : Benefits outweighed by learning curve and timeline pressure Future-proofing : Theoretical benefit cannot justify immediate delivery risk Consequences Positive ‚úÖ Immediate Development Start : No productivity loss during language transition ‚úÖ Team Expertise Utilized : Deep C knowledge translates to high-quality embedded code ‚úÖ Mature Ecosystem : Full vendor support, comprehensive tooling, extensive libraries ‚úÖ Proven Industrial Reliability : Decades of successful embedded deployments ‚úÖ Debugging Efficiency : Mature GDB/OpenOCD toolchain familiar to team ‚úÖ Timeline Compliance : Meets aggressive delivery requirements Negative ‚ö†Ô∏è Manual Memory Management : Requires disciplined practices and comprehensive testing ‚ö†Ô∏è Potential Security Vulnerabilities : Manual bounds checking, pointer management ‚ö†Ô∏è Future Technology Debt : May require reevaluation for future projects ‚ö†Ô∏è Missing Modern Features : Less expressive type system than Rust Risks and Mitigation Memory Safety Risk : Mitigate through MISRA-C compliance, static analysis, comprehensive testing Code Quality Risk : Mitigate through mandatory code reviews, automated testing, continuous integration Future Maintenance Risk : Document rationale, plan Rust evaluation for future projects Implementation Notes Development Standards MISRA-C Compliance : Follow MISRA-C:2012 guidelines for industrial safety Static Analysis : Integrate PC-lint, Cppcheck, or equivalent in CI pipeline Memory Management : Strictly static allocation, no malloc/free usage Error Handling : Consistent error codes, graceful degradation strategies Testing Strategy Unit Testing : 100% code coverage requirement Integration Testing : Hardware-in-the-loop validation Stress Testing : Extended operation under maximum load conditions Memory Validation : Static analysis tools, runtime bounds checking in debug builds Security Practices Input Validation : All network and UART inputs validated Buffer Management : Fixed-size buffers with explicit bounds checking Secure Coding : Follow SEI CERT C guidelines Code Reviews : Security-focused review process for all code changes Follow-up Actions Development Environment : Configure MISRA-C checking in build system Testing Framework : Establish unit testing framework with coverage reporting Code Standards : Document project-specific C coding guidelines Static Analysis : Integrate static analysis tools in CI/CD pipeline Team Training : Brief refresher on secure C practices for embedded systems Future Evaluation : Plan Rust reassessment for next major project Review Notes: &#10063; Confirm MISRA-C compliance requirements with quality team &#10063; Validate static analysis tool selection &#10063; Review memory safety testing strategy &#10063; Document specific secure coding guidelines &#10063; Plan future Rust evaluation timeline "
},

{
    "id": 1,
    "uri": "adrs/ADR-001-microcontroller-selection.html",
    "menu": "adrs",
    "title": "ADR-001: Microcontroller Platform Selection for UART2ETH",
    "text": " Table of Contents ADR-001: Microcontroller Platform Selection for UART2ETH Context Decision Drivers Options Considered PUGH Matrix Analysis Decision Rationale Consequences Implementation Notes Follow-up Actions ADR-001: Microcontroller Platform Selection for UART2ETH Status: PROPOSED Date: 2025-07-26 Deciders: Architecture Team Consulted: Senior Developer Informed: Development Team Context The UART2ETH system requires a microcontroller platform capable of: Supporting up to 4 concurrent UART interfaces Processing TCP/IP networking with industrial reliability Implementing secure OTA firmware updates with A/B partitioning Operating in industrial environments (-40¬∞C to +85¬∞C) Achieving 500 kbps sustained throughput per UART port with sub-5ms latency Cost-effective solution for volume production The microcontroller selection is a foundational decision that affects all system capabilities, development complexity, and long-term maintainability. Decision Drivers Primary Requirements Multi-UART Support : Hardware support for multiple UARTs or flexible alternatives Network Processing : Sufficient processing power for TCP/IP stack and protocol filtering A/B Update Capability : Sufficient flash memory and architecture for dual firmware partitions Security Capabilities : Hardware support for cryptographic operations and secure boot Industrial Reliability : Temperature range, electrical robustness, proven track record Real-time Performance : Deterministic behavior for latency-critical applications Development Ecosystem : Mature toolchain, documentation, community support Cost Effectiveness : Component cost + external components for volume production Constraints Must operate reliably in industrial environments GPL open source licensing compatibility Maximum system cost target: $10 for volume production Options Considered Option A: Raspberry Pi RP2350 Architecture : Dual-core ARM Cortex-M33 @ 150MHz Memory : 520KB SRAM, external flash required UARTs : 2 hardware UARTs + 12 programmable I/O (PIO) state machines Networking : Requires external Ethernet controller (ENC28J60) Security : Hardware SHA-256, ARM TrustZone, secure boot capabilities A/B Updates : External flash enables dual partitions + secure bootloader Development Ecosystem : Good documentation, smaller community than Arduino Industrial Track Record : None (released August 2024, zero field deployment) Cost : ~$1.00 + ~$1.50 (ENC28J60) = $2.50 total Option B: ATMega328P (Baseline) Architecture : Single-core 8-bit AVR @ 16MHz Memory : 2KB SRAM, 32KB Flash UARTs : 1 hardware UART Networking : Requires external Ethernet controller (ENC28J60) Security : No hardware security features A/B Updates : Insufficient flash space (32KB) for dual firmware images Development Ecosystem : Arduino platform - most accessible ecosystem ever created, millions of tutorials Industrial Track Record : Decades of proven deployment in industrial environments Cost : ~$2.50 + ~$1.50 (ENC28J60) = $4.00 total Option C: ESP32 Architecture : Dual-core Xtensa LX6 @ 240MHz Memory : 520KB SRAM, 4MB Flash UARTs : 3 hardware UARTs Networking : Built-in WiFi/Bluetooth, requires external Ethernet for wired Security : Hardware crypto acceleration, secure boot A/B Updates : 4MB flash supports dual partitions + ESP-IDF OTA framework Development Ecosystem : Good tools (ESP-IDF, Arduino IDE), solid community, smaller than Arduino Industrial Track Record : 8+ years deployment (2016+), moderate industrial adoption, less proven than ATMega328P Cost : ~$2.50 + ~$1.50 (ENC28J60) = $4.00 total PUGH Matrix Analysis Scoring: Better than baseline (+1, +2), Same as baseline (0), Worse than baseline (-1, -2) Baseline: ATMega328P (all scores = 0) Criteria Weight ATMega328P RP2350 ESP32 UART Support 3 0 (baseline) +2 (PIO flexibility) +1 (3 HW UARTs) Processing Power 3 0 (baseline) +2 (dual 32-bit @150MHz) +2 (dual 32-bit @240MHz) Memory Capacity 2 0 (baseline) +2 (260x more SRAM) +2 (260x more SRAM) A/B Update Support 3 0 (baseline) +2 (external flash + secure boot) +2 (4MB flash + OTA framework) Security Features 3 0 (baseline) +2 (HW SHA-256 + TrustZone) +1 (HW crypto only) Real-time Determinism 2 0 (baseline) +2 (PIO + dual-core) +1 (dual-core) Development Ecosystem 2 0 (baseline) -1 (smaller community, newer) 0 (good tools, smaller than Arduino) Industrial Reliability 2 0 (baseline) -1 (new platform, zero field history) 0 (8+ years, less than decades) Cost Effectiveness 1 0 (baseline) +2 (37% cost reduction) 0 (same cost) Network Architecture 2 0 (baseline) 0 (same - external PHY) -1 (WiFi overhead) Weighted Scores RP2350 Total Score: UART: 3√ó(+2) = +6 Processing: 3√ó(+2) = +6 Memory: 2√ó(+2) = +4 A/B Updates: 3√ó(+2) = +6 Security: 3√ó(+2) = +6 Real-time: 2√ó(+2) = +4 Ecosystem: 2√ó(-1) = -2 Reliability: 2√ó(-1) = -2 Cost: 1√ó(+2) = +2 Network: 2√ó(0) = 0 Total: +30 ESP32 Total Score: UART: 3√ó(+1) = +3 Processing: 3√ó(+2) = +6 Memory: 2√ó(+2) = +4 A/B Updates: 3√ó(+2) = +6 Security: 3√ó(+1) = +3 Real-time: 2√ó(+1) = +2 Ecosystem: 2√ó(0) = 0 Reliability: 2√ó(0) = 0 Cost: 1√ó(0) = 0 Network: 2√ó(-1) = -2 Total: +22 Decision Selected: Raspberry Pi RP2350 The RP2350 scores significantly higher (+30 vs +22) in the weighted PUGH analysis, primarily due to: Superior UART Flexibility : PIO state machines provide unmatched capability for implementing custom UART protocols A/B Update Architecture : External flash design enables reliable dual-partition firmware updates Security Architecture : Hardware SHA-256 and TrustZone directly address secure OTA requirements Cost Advantage : 37% lower total system cost while providing better capabilities Real-time Determinism : PIO subsystem + dual-core architecture enables predictable performance Rationale Why RP2350 Over ATMega328P Performance Gap : 328P cannot handle 4 concurrent UARTs + TCP processing Memory Limitation : 2KB SRAM insufficient for networking stack and buffering A/B Update Impossibility : 32KB flash insufficient for dual firmware images (need ~64KB minimum) Security Gap : No hardware security features compromise OTA update integrity Future Flexibility : PIO enables protocol adaptations without hardware changes Why RP2350 Over ESP32 Industrial Focus : No unnecessary WiFi attack surface in industrial environments Cost Efficiency : Lower total system cost for same networking capability Architectural Fit : PIO subsystem specifically designed for custom I/O protocols Security Model : TrustZone provides more comprehensive security architecture UART Flexibility : Superior support for multiple custom UART implementations Industrial Reliability Trade-off : While ESP32 has solid 8+ years of industrial deployment vs RP2350&#8217;s zero field history, neither matches ATMega328P&#8217;s decades of proven reliability. Development Ecosystem Trade-off : ATMega328P&#8217;s Arduino ecosystem is unmatched in accessibility, tutorials, and community support. Both RP2350 and ESP32 have smaller ecosystems despite good documentation. Despite these disadvantages, the RP2350&#8217;s technical advantages outweigh these risks for our specific application requirements. Consequences Positive ‚úÖ Technical Capability : Meets all performance and functionality requirements ‚úÖ Cost Optimization : Lowest total system cost among capable options ‚úÖ Security Compliance : Hardware support for all security requirements ‚úÖ Development Efficiency : Excellent documentation and tooling ecosystem ‚úÖ Future Flexibility : PIO enables protocol extensions without redesign Negative ‚ö†Ô∏è External Dependency : Requires ENC28J60 Ethernet controller ‚ö†Ô∏è Industrial Deployment Risk : Zero field deployment history in industrial environments (released August 2024) ‚ö†Ô∏è Platform Maturity : Less proven than ATMega328P&#8217;s decades of industrial use ‚ö†Ô∏è Development Ecosystem : Smaller community and fewer resources compared to Arduino&#8217;s massive ecosystem ‚ö†Ô∏è Custom Development : PIO programming requires specialized knowledge Risks and Mitigation Supply Chain Risk : Multiple suppliers available, stockpile strategy for critical components ENC28J60 Dependency : Well-established component with multiple sources and alternatives Industrial Reliability Risk : RP2350 has zero industrial field deployment history; mitigate with extensive environmental testing and validation program Development Complexity : Comprehensive documentation and examples available Implementation Notes Required External Components ENC28J60 Ethernet Controller : Hardware TCP/IP stack, SPI interface Crystal/Oscillator : For precise timing if required by application Power Supply : 3.3V regulation and filtering Protection : ESD protection for industrial environments Development Approach Phase 1 : Basic RP2350 + ENC28J60 integration with single UART Phase 2 : PIO-based additional UART implementation Phase 3 : Security features and OTA update system Architecture Implications Dual-Core Utilization : Core 0 for real-time UART processing, Core 1 for networking Memory Management : Static allocation for predictable real-time behavior Security Integration : TrustZone secure boot with hardware-accelerated crypto Follow-up Actions Procurement : Establish supplier relationships for RP2350 and ENC28J60 Industrial Validation : Comprehensive environmental testing program to validate RP2350 reliability in industrial conditions Prototyping : Develop basic hardware platform for validation testing PIO Development : Create UART protocol templates using PIO state machines Security Planning : Design secure boot and OTA update architecture Testing Strategy : Define industrial environment validation procedures including EMI/EMC testing Review Notes: &#10063; Confirm ENC28J60 vs W5500 preference &#10063; Validate cost estimates with current supplier pricing &#10063; Review A/B update architecture requirements vs RP2350 external flash approach &#10063; Confirm industrial temperature requirements vs RP2350 specs &#10063; Validate PUGH matrix criteria weights reflect actual project priorities "
},

{
    "id": 2,
    "uri": "adrs/ADR-004-development-ecosystem.html",
    "menu": "adrs",
    "title": "ADR-004: Development Ecosystem Selection for UART2ETH",
    "text": " Table of Contents ADR-004: Development Ecosystem Selection for UART2ETH Context Decision Drivers Options Considered PUGH Matrix Analysis Decision Rationale Consequences üö® Critical Contradiction Discovery Implementation Notes Interdependency with ADR-002 Follow-up Actions ADR-004: Development Ecosystem Selection for UART2ETH Status: PROPOSED Date: 2025-07-27 Deciders: Architecture Team Consulted: Senior Developer Informed: Development Team Context The UART2ETH system requires selecting a comprehensive development ecosystem including build system, toolchain, IDE integration, and dependency management for RP2350-based firmware development. This decision directly impacts development velocity, code quality, maintainability, and the ability to leverage advanced RP2350 capabilities. Based on platform decisions: ADR-001: RP2350 microcontroller selection ADR-002: ENC28J60 ethernet controller selection ADR-003: C programming language selection We need a development ecosystem that can: Enable rapid, professional C development on RP2350 platform Support industrial-grade reliability and testing practices Provide access to advanced RP2350 features (PIO, dual-core, secure boot, A/B updates) Integrate with selected ethernet controller efficiently Support team collaboration and CI/CD practices Meet aggressive delivery timeline requirements Enable MISRA-C compliance and comprehensive testing Decision Drivers Primary Requirements Development Velocity : Immediate productivity with minimal learning curve RP2350 Feature Access : Full access to PIO, dual-core, security, and OTA capabilities Industrial Tooling : Mature debugging, static analysis, and testing infrastructure Team Expertise Fit : Leverage existing C/embedded development skills Ethernet Integration : Efficient integration with selected ethernet controller Professional Workflow : Support for code reviews, CI/CD, and quality gates Documentation : Comprehensive vendor support and community resources Constraints Aggressive delivery timeline requiring immediate productivity Industrial reliability requirements (MISRA-C, comprehensive testing) Team expertise concentrated in C/embedded development Must support secure OTA updates and A/B partitioning GPL open source licensing compatibility Options Considered Option A: Arduino IDE/Framework Pros : Rapid prototyping, huge community, simple setup Cons : Not professional-grade, poor CI/CD integration, limited industrial features, conflicts with C language choice ( ADR-003 ) Option B: PlatformIO + Arduino Framework Pros : Professional IDE integration, good dependency management, better than Arduino IDE Cons : Still Arduino framework limitations, emerging RP2350 support Option C: PlatformIO + Native Pico SDK Pros : Professional environment with native SDK access Cons : RP2350 support still emerging, complexity with advanced features, abstraction layer overhead Option D: Native Pico SDK + CMake (Traditional Embedded) Pros : Maximum control, full vendor support, mature tooling, industrial-grade capability Cons : More manual setup, steeper learning curve for non-embedded developers PUGH Matrix Analysis Scoring: Better than baseline (+1, +2), Same as baseline (0), Worse than baseline (-1, -2) Baseline: Arduino IDE (all scores = 0) Criteria Weight Arduino IDE PlatformIO+Arduino PlatformIO+SDK Native SDK+CMake Development Velocity 3 0 (baseline) +1 (better IDE, deps mgmt) -1 (setup complexity) -1 (manual setup) RP2350 Feature Access 3 0 (baseline) 0 (Arduino framework limits) +1 (emerging SDK access) +2 (full SDK access) Industrial Tooling 3 0 (baseline) +1 (better IDE, CI integration) +2 (professional environment) +2 (mature debugging, analysis) Team Expertise Fit 2 0 (baseline) 0 (similar Arduino approach) +1 (mixed C/Arduino) +2 (pure C expertise) Professional Workflow 2 0 (baseline) +2 (CI/CD, collaboration tools) +2 (professional environment) +2 (industry standard) Advanced RP2350 Features 3 0 (baseline) -1 (Arduino abstractions hide features) +1 (partial SDK access) +2 (secure boot, A/B updates, PIO) Delivery Timeline 3 0 (baseline) +1 (faster than manual setup) 0 (learning curve offsets speed) -1 (initial setup overhead) Industrial Compliance 3 0 (baseline) 0 (limited MISRA-C support) +1 (better static analysis) +2 (full MISRA-C, testing support) Debugging Maturity 2 0 (baseline) +1 (better than Arduino IDE) +1 (good debugging support) +2 (GDB, OpenOCD, mature tools) Long-term Maintainability 2 0 (baseline) +1 (better project structure) +1 (cleaner architecture) +2 (vendor-supported, stable) Total PUGH Score 0 +14 +22 +34 Decision Selected: Native Pico SDK + CMake Development Ecosystem The Native Pico SDK with CMake provides the optimal foundation for professional, industrial-grade development of the UART2ETH system, scoring significantly higher (+34 vs +22 vs +14 vs 0) in weighted analysis. Rationale Why Native SDK + CMake Over PlatformIO + SDK (+34 vs +22) Superior RP2350 Feature Access : Full vendor-supported access to secure boot, A/B updates, and advanced PIO programming vs emerging support Industrial Compliance Advantage : Native MISRA-C toolchain integration vs adaptation layers Team Expertise Optimal Fit : Direct C expertise application vs mixed C/framework approach Debugging Maturity : Full GDB/OpenOCD integration vs abstracted debugging Long-term Vendor Support : Raspberry Pi official support vs third-party integration Why PlatformIO + SDK Over PlatformIO + Arduino (+22 vs +14) RP2350 Capabilities : Access to microcontroller features vs Arduino framework limitations Industrial Requirements : Better static analysis and compliance support Advanced Features : Required for secure OTA and A/B updates vs basic functionality Why Any Professional Option Over Arduino IDE (Baseline) Industrial Development : Professional tooling, CI/CD, collaboration vs hobbyist-focused Project Complexity : Multi-UART, networking, security features exceed Arduino scope Team Requirements : Professional development practices vs simple prototyping Delivery Timeline Trade-off Justification While Native SDK has initial setup overhead (-3 points), this is offset by: Quality Foundation : Reduces rework and debugging time later Team Expertise : C skills minimize learning curve impact Industrial Requirements : Mandatory for MISRA-C compliance and advanced features Long-term Velocity : Better maintainability and debugging capabilities Consequences Positive ‚úÖ Professional Development Environment : Industry-standard toolchain with mature debugging and analysis tools ‚úÖ Full Platform Capability : Access to all RP2350 advanced features required for product requirements ‚úÖ Industrial Compliance : Native support for MISRA-C, static analysis, and testing frameworks ‚úÖ Team Productivity : Direct application of existing embedded C expertise ‚úÖ Vendor Support : Comprehensive Raspberry Pi documentation and examples ‚úÖ Future-Proof Architecture : Foundation for advanced features and scaling Negative ‚ö†Ô∏è Initial Setup Complexity : More manual configuration compared to PlatformIO ‚ö†Ô∏è Learning Curve : CMake and SDK-specific concepts for team members unfamiliar with Pico development ‚ö†Ô∏è Dependency Management : Manual library management vs automated PlatformIO approach ‚ö†Ô∏è IDE Integration : Requires configuration vs out-of-box PlatformIO experience Risks and Mitigation Development Environment Setup Risk : Mitigate with standardized Docker development containers and comprehensive setup documentation Team Learning Curve Risk : Mitigate with focused training sessions and pair programming during initial implementation Dependency Management Complexity : Mitigate with Git submodules and clear dependency documentation Critical Ethernet Controller Ecosystem Dependency Risk HIGH RISK : The viability of our development ecosystem choice is significantly impacted by ADR-002 (Ethernet Controller Selection) : W5500 Ecosystem Support : ‚úÖ Official WIZnet Libraries : Native Pico SDK integration (WIZnet-PICO-C, WIZnet-PICO-LWIP-C) ‚úÖ Vendor Documentation : Comprehensive examples and industrial deployment guides ‚úÖ Community Support : Multiple professional implementations and maintained libraries ‚úÖ Industrial Examples : Azure IoT, AWS IoT integrations with proven reliability ENC28J60 Ecosystem Support : ‚ö†Ô∏è Individual Open Source Efforts : Limited to individual developers (e.g., Juddling/pi-pico-enc28j60) ‚ö†Ô∏è No Official RP2350 Support : No vendor libraries for RP2350+ENC28J60 combination ‚ö†Ô∏è Arduino-Focused : Most examples conflict with our C language choice ( ADR-003 ) ‚ö†Ô∏è Custom Integration Required : Significant lwIP integration effort needed ‚ö†Ô∏è Maintenance Risk : Dependency on individual maintainer vs corporate support Risk Assessment : ENC28J60 choice significantly increases development effort and long-term maintenance risk for our chosen development ecosystem. Mitigation Options : Accept Risk : Proceed with ENC28J60 and allocate 1-2 weeks for custom integration development Reconsider ADR-002 : Evaluate W5500 based on ecosystem maturity and development efficiency Hybrid Approach : Prototype with both controllers to validate integration effort Recommendation : This ecosystem dependency should be factored into ADR-002 reconsideration. üö® Critical Contradiction Discovery During ecosystem research, significant issues were discovered with ADR-002 (ENC28J60 selection) : ENC28J60 + RP2350 Development Challenges Limited RP2350 Support : No official vendor libraries for RP2350+ENC28J60 Arduino-Only Examples : Most implementations require Arduino framework, conflicting with ADR-003 (C language choice) Complex Integration : Requires custom lwIP integration with significant development effort Performance Limitation : 10Mbps only vs 100Mbps capability needed Industrial Reliability Risk : Less mature integration, more complex software stack Alternative: W5500 + RP2350 Ecosystem Maturity Official RP2350 Support : WIZnet W5500-EVB-Pico2 with comprehensive SDK integration Native Pico SDK Libraries : WIZnet-PICO-C, WIZnet-PICO-LWIP-C, industrial examples Hardware TCP/IP Stack : Reduces microcontroller overhead, improves determinism 100Mbps Performance : Meets bandwidth requirements Industrial Deployments : Proven in Azure IoT, AWS IoT applications Recommendation : ADR-002 should be reconsidered in light of development ecosystem requirements. Implementation Notes Development Environment Components Toolchain : ARM GCC toolchain provided with Pico SDK Build System : CMake with Pico SDK build extensions IDE Integration : VS Code with C/C++ and CMake extensions Debugging : OpenOCD + GDB with Picoprobe or compatible debugger Static Analysis : PC-lint Plus or Cppcheck integration Testing Framework : Unity or CppUTest for unit testing CI/CD : GitHub Actions with standardized build and test pipelines Required Dependencies Pico SDK v2.1+ : Full RP2350 support with security features W5500 Libraries : WIZnet-PICO-C for ethernet integration (if ADR-002 reconsidered) lwIP Stack : For TCP/IP implementation (ENC28J60) or hardware stack interface (W5500) Testing Framework : Unity for embedded unit testing Static Analysis Tools : MISRA-C compliance checking Development Standards MISRA-C Compliance : Enforce via static analysis in CI pipeline Code Coverage : 100% requirement with automated reporting Documentation : Doxygen-style comments for all public interfaces Version Control : Git with semantic versioning and conventional commits Code Reviews : Mandatory reviews for all production code changes Interdependency with ADR-002 This ADR reveals critical issues with ADR-002 (ENC28J60 selection) : Development Ecosystem Mismatch : ENC28J60 lacks mature RP2350 SDK integration Performance vs Requirements : 10Mbps limitation vs 100Mbps capability needed Industrial Reliability Concerns : Complex software stack vs proven hardware solutions Team Productivity Impact : Months of custom development vs immediate integration Recommendation : ADR-002 should be reopened with updated technical analysis considering: Ecosystem maturity and vendor support Development velocity and team productivity impact Industrial deployment requirements and reliability Follow-up Actions Evaluate ADR-002 Impact : Technical reassessment of ethernet controller choice with ecosystem considerations Development Environment Setup : Create standardized Docker containers and setup documentation Toolchain Integration : Configure CMake, static analysis, and testing framework integration Team Training Plan : Develop Pico SDK and CMake training materials Prototype Development : Create proof-of-concept demonstrating ecosystem capabilities CI/CD Pipeline : Implement automated build, test, and quality gates Review Notes: &#10063; CRITICAL : This ADR recommends reconsidering ADR-002 based on technical evidence &#10063; Confirm W5500 ecosystem advantages align with project requirements &#10063; Validate team acceptance of Native SDK approach vs PlatformIO preference &#10063; Review industrial compliance requirements vs ecosystem capabilities &#10063; Assess impact of ADR-002 change on project timeline and budget "
},

{
    "id": 3,
    "uri": "adrs/ADR-002-ethernet-controller-selection.html",
    "menu": "adrs",
    "title": "ADR-002-ethernet-controller-selection.adoc",
    "text": " Table of Contents ADR-002: Ethernet Controller Selection for UART2ETH Context Decision Drivers Primary Requirements Constraints Options Considered Option A: WIZnet W5500 Option B: Microchip ENC28J60 PUGH Matrix Analysis Decision Rationale Why ENC28J60 Over W5500 Trade-offs Accepted Consequences Positive Negative Risks and Mitigation Implementation Notes Performance Optimization Follow-up Actions ADR-002: Ethernet Controller Selection for UART2ETH Status: PROPOSED Date: 2025-07-26 Deciders: Architecture Team Consulted: Senior Developer Informed: Development Team Context The UART2ETH system requires an Ethernet controller that interfaces with the RP2350 microcontroller via SPI to provide reliable TCP/IP connectivity. This component is critical for the core networking functionality of our product. Based on our microcontroller selection (ADR-001), we need to determine the most appropriate Ethernet controller solution that can: Support 100 Mbps Ethernet connectivity Interface with the RP2350 via SPI Handle the networking requirements of up to 4 concurrent UART-to-TCP bridges Operate reliably in industrial environments (-40¬∞C to +85¬∞C) Maintain low latency while supporting our 500 kbps per port requirement Simplify firmware development with minimal microcontroller overhead Meet our cost target for volume production Does not contain firmware on its own Comes from a 'western' supplier The Ethernet controller selection impacts system performance, reliability, development complexity, and overall BOM cost. Decision Drivers Primary Requirements Network Performance : Support for full 100 Mbps Ethernet with sufficient throughput for our use case Memory Buffer Size : Sufficient buffer for packet handling and multiple connections SPI Interface Speed : Fast and efficient communication with the microcontroller Industrial Reliability : Operating temperature range and robustness for industrial use Cost Effectiveness : Component cost for volume production Development Complexity : Readily available OpenSource library for integration Constraints Must use SPI interface to connect with the RP2350 microcontroller Must operate reliably in industrial environments (-40¬∞C to +85¬∞C) Must fit within the overall $10 system cost target for volume production Must use open-source compatible software stacks (GPL license compatible) Options Considered Option A: WIZnet W5500 Interface : SPI (up to 80 MHz) Network Speed : 10/100 Mbps Ethernet TCP/IP Stack : Hardwired TCP/IP stack (integrated) Buffer Memory : 32 KB internal buffer Concurrent Connections : 8 independent hardware sockets Protocols Support : TCP, UDP, IPv4, ICMP, ARP, IGMP, PPPoE Temperature Range : -40¬∞C to +85¬∞C Voltage Supply : 2.97V to 3.63V Power Consumption : 132mA typical Package Options : 48-LQFP (7x7mm) Cost (Volume) : ~$2.00 per unit Development Ecosystem : Extensive documentation, libraries for multiple platforms Manufacturer : WIZnet.io (South Korea) Option B: Microchip ENC28J60 Interface : SPI (up to 20 MHz) Network Speed : 10 Mbps Ethernet only TCP/IP Stack : Software stack required (on microcontroller) Buffer Memory : 8 KB internal buffer Concurrent Connections : Limited by microcontroller implementation Protocols Support : Requires microcontroller implementation (typically lwIP) Temperature Range : 0¬∞C to +70¬∞C (commercial), -40¬∞C to +85¬∞C (industrial version) Voltage Supply : 3.1V to 3.6V Power Consumption : 160mA typical Package Options : 28-pin SPDIP, SOIC, SSOP, QFN Cost (Volume) : ~$2.50 per unit Development Ecosystem : Mature, widely used in Arduino and other platforms Manufacturer : Microchip Technology (USA) PUGH Matrix Analysis Scoring: Better than baseline (+1, +2), Same as baseline (0), Worse than baseline (-1, -2) Baseline: ENC28J60 (all scores = 0) Criteria Weight ENC28J60 W5500 Network Speed 1 0 (baseline) +1 (100 Mbps vs 10 Mbps) TCP/IP Implementation 1 0 (baseline) +1 (hardwired vs software) Microcontroller Overhead 1 0 (baseline) +1 (minimal vs significant) Buffer Size 1 0 (baseline) +1 (32KB vs 8KB) SPI Interface Performance 1 0 (baseline) +1 (80MHz vs 20MHz) Industrial Temperature Range 1 0 (baseline) 0 (standard -40¬∞C to +85¬∞C) Development Ecosystem 1 0 (baseline) 0 (both well-supported) Firmware Complexity 1 0 (baseline) +1 (simple socket programming) Open Internal Firmware 3 0 (baseline) -1 (Complex, Closed Source) Western Manufacturer 3 0 (baseline) -1 (South Korea) Auditable Sourcecode 3 0 (baseline) -2 (Closed Source) Total PUGH Score 1 0 (baseline) -6 Decision Selected: ENC28J60 While the W5500 is technically superior in every aspect and more easy to integrate, the ENC28J60 is a dumb device, which is, given to goal of maximum control, auditable software and upgradeable software, exactly what we want. And additionally it is from a 'western' manufacturer. Rationale Why ENC28J60 Over W5500 Dumb : The ENC28J60 has no complex firmware. Auditable Sourcecode : The main network code is in the microcontrollers firmware, which we have total control over. This allows us to show all relevant code for audits. Western Manufacturer : Because of supply chain considerations we want this project to contain only 'western' manufacturers. While technically South Korea is a western ally, it is still in the east. Trade-offs Accepted Cost Premium : The $0.50 additional cost per unit for the W5500 is justified by the significant performance advantages, reduced development complexity, and system resource savings. Lower Performance : The W5500 is superior in all aspects of performance. But the ENC28J60 is good enough to match the performance criteria. Consequences Positive ‚úÖ Minimal Performance : ENC28J60 provides enough network bandwidth for current needs ‚úÖ Physical Size : 28SSOP package requires slightly less PCB space ‚úÖ Industrial Reliability : Full industrial temperature range support ‚úÖ External Dependency : Reliance on a more generic controller with more alternatives Negative ‚ö†Ô∏è Resource Spending : More microcontroller overhead diminishes resources for other features ‚ö†Ô∏è Slightly Higher Cost : $0.50 cost premium per unit compared to W5500 ‚ö†Ô∏è More Complex Development : Software TCP/IP stack incraeses code complexity and development time Risks and Mitigation Supply Chain Risk : Establish multiple supplier relationships, consider inventory strategy Single-Source Component : Document adaptation path to alternative controllers if necessary Integration Complexity : Thoroughly validate the ENC28J60-RP2350 integration early in development Implementation Notes Performance Optimization Use burst SPI mode for maximum throughput (up to 25 MHz) Optimize buffer management for latency-sensitive applications) Follow-up Actions Procurement : Source ENC28J60 components from multiple suppliers to validate availability Prototyping : Develop initial integration test for RP2350 + ENC28J60 communication Performance Testing : Benchmark SPI communication speeds and TCP throughput Industrial Validation : Test operation across full temperature range Review Notes: &#10063; Validate pricing from multiple suppliers &#10063; Confirm SPI bus configuration with other peripherals &#10063; Verify EMI/EMC considerations with ENC28J60 placement &#10063; Test actual power consumption under various load scenarios "
},

{
    "id": 4,
    "uri": "adrs/ADR-005-buffer-allocation-strategy.html",
    "menu": "adrs",
    "title": "ADR-005: Ring Buffer Memory Allocation Strategy for UART2ETH",
    "text": " Table of Contents ADR-005: Ring Buffer Memory Allocation Strategy for UART2ETH Context Decision Drivers Options Considered PUGH Matrix Analysis Decision Rationale Consequences Implementation Notes Future Optimization Path Alternative Approaches Considered Follow-up Actions ADR-005: Ring Buffer Memory Allocation Strategy for UART2ETH Status: PROPOSED Date: 2025-07-27 Deciders: Architecture Team Consulted: Senior Developer Informed: Development Team Context The UART2ETH system requires a ring buffer allocation strategy for inter-core communication between Core 0 (UART processing) and Core 1 (network processing). Based on our solution strategy (Chapter 4), we use cache-aligned ring buffers with fixed-size entries to enable deterministic, high-performance data transfer. This ADR documents the critical decision between different buffer allocation approaches given our realistic packet size analysis: Maximum payload size : 1024 bytes (worst-case industrial protocol) Minimum payload size : 10 bytes (small sensor readings) Average payload size : 40 bytes (typical industrial data) The buffer allocation strategy directly impacts: Memory efficiency and utilization System determinism and real-time behavior Implementation complexity and maintainability Development timeline and risk This decision is architecturally significant because it affects the fundamental memory model of our dual-core architecture and determines whether we can achieve our non-negotiable requirements within the 520KB SRAM constraints of the RP2350. Decision Drivers Primary Requirements Industrial Reliability : Must enable deterministic, predictable behavior for industrial applications Static Memory Allocation : All memory must be allocated at compile time (no dynamic allocation) Sub-5ms Latency : Latency requirement limits buffering depth, reducing total memory impact Cache-Aligned Performance : Inter-core communication must be optimized for dual-core RP2350 TDD Implementation : Must be testable and maintainable using test-driven development Constraints Limited to 520KB SRAM total on RP2350 platform Static allocation only (no malloc/free) Cache-line alignment required (64-byte boundaries) Maximum 2-3 packets buffered per UART due to latency constraints Must support worst-case 1024-byte payload scenarios Options Considered Option A: Static Worst-Case Allocation (Baseline) Approach : Fixed ring buffer entries sized for maximum payload (1024 bytes + 16 bytes management = 1040 bytes per entry) Memory Usage : Each entry wastes 984 bytes when storing 40-byte average payloads (96% waste) Determinism : Completely predictable, compile-time allocation Implementation Complexity : Minimal - simple fixed-size array Cache Alignment : Straightforward alignment to cache boundaries Testing : Simple to test, no dynamic allocation edge cases Option B: Protocol-Aware Multi-Pool Approach : Three separate buffer pools sized for different payload ranges Small Pool: 64-byte entries (for ‚â§40 byte packets) Medium Pool: 256-byte entries (for 41-200 byte packets) Large Pool: 1024-byte entries (for 201-1024 byte packets) Memory Usage : Significantly more efficient (~20-30% waste vs 96%) Determinism : Still predictable, but requires pool management logic Implementation Complexity : Requires pool allocation logic, protocol size prediction Cache Alignment : More complex alignment across multiple pools Testing : Complex testing scenarios for pool exhaustion, allocation failures Option C: Variable-Length with Fragmentation Approach : Variable-length entries with fragmentation and reassembly Memory Usage : Most efficient possible memory utilization Determinism : Unpredictable due to fragmentation and reassembly timing Implementation Complexity : High - fragmentation logic, reassembly buffers Cache Alignment : Complex alignment with variable sizes Testing : Very complex testing for fragmentation edge cases PUGH Matrix Analysis Scoring: Better than baseline (+1, +2), Same as baseline (0), Worse than baseline (-1, -2) Baseline: Static Worst-Case Allocation (all scores = 0) Criteria Weight Static Worst-Case Multi-Pool Variable-Length Industrial Reliability 3 0 (baseline) -1 (pool management risk) -2 (fragmentation unpredictability) Memory Efficiency 2 0 (baseline) +2 (20-30% waste vs 96%) +2 (optimal utilization) Implementation Simplicity 3 0 (baseline) -1 (pool allocation logic) -2 (fragmentation complexity) Deterministic Behavior 3 0 (baseline) -1 (pool allocation timing) -2 (fragmentation timing) Testing Complexity 2 0 (baseline) -1 (pool edge cases) -2 (fragmentation edge cases) Development Timeline 2 0 (baseline) -1 (additional development) -2 (significant additional work) Cache Optimization 2 0 (baseline) -1 (multi-pool alignment) -2 (variable alignment complexity) Future Maintainability 1 0 (baseline) +1 (documented optimization path) -1 (complex maintenance) Weighted Scores Multi-Pool Total Score: Reliability: 3√ó(-1) = -3 Memory: 2√ó(+2) = +4 Simplicity: 3√ó(-1) = -3 Determinism: 3√ó(-1) = -3 Testing: 2√ó(-1) = -2 Timeline: 2√ó(-1) = -2 Cache: 2√ó(-1) = -2 Maintainability: 1√ó(+1) = +1 Total: -10 Variable-Length Total Score: Reliability: 3√ó(-2) = -6 Memory: 2√ó(+2) = +4 Simplicity: 3√ó(-2) = -6 Determinism: 3√ó(-2) = -6 Testing: 2√ó(-2) = -4 Timeline: 2√ó(-2) = -4 Cache: 2√ó(-2) = -4 Maintainability: 1√ó(-1) = -1 Total: -23 Decision Selected: Static Worst-Case Allocation Despite the significant memory inefficiency (96% waste in typical scenarios), static worst-case allocation scores highest in our weighted analysis due to our reliability-first architecture principles and aggressive sub-5ms latency requirements . Rationale Why Static Allocation Over Multi-Pool (-10 score) Reliability Trumps Efficiency: Industrial reliability is our non-negotiable #1 priority Static allocation provides completely predictable behavior No pool exhaustion scenarios or allocation failures Simpler testing with fewer edge cases Latency Constraint Mitigation: Sub-5ms requirement limits buffer depth to ~2-3 packets maximum Total memory waste: 4 UARTs √ó 3 packets √ó 1024 bytes = ~12KB 12KB waste is acceptable within 520KB total SRAM Implementation Risk Reduction: TDD requirement favors simpler, more testable implementation Aggressive delivery timeline cannot accommodate complex allocation logic Static allocation enables immediate development progress Why Static Allocation Over Variable-Length (-23 score) Variable-length fails completely on reliability and determinism Fragmentation creates unpredictable latency - incompatible with sub-5ms requirement Testing complexity would significantly impact TDD implementation Memory Efficiency Analysis Realistic Memory Impact: Worst-case buffer usage: 4 UARTs √ó 3 packets/UART √ó 1024 bytes/packet = 12KB total Percentage of available SRAM: 12KB / 520KB = 2.3% Total system memory budget impact: Acceptable Latency-Limited Buffering: Sub-5ms latency inherently limits packet accumulation Small buffer depths make absolute memory waste manageable Quality goal (latency) constraints enable architectural simplification Consequences Positive ‚úÖ Industrial Reliability : Completely predictable memory behavior ‚úÖ Development Velocity : Immediate implementation, no complex allocation logic ‚úÖ Testing Simplicity : Straightforward test scenarios, high confidence ‚úÖ Cache Optimization : Simple 64-byte alignment for optimal inter-core performance ‚úÖ Future Flexibility : Clear optimization path documented for later enhancement Negative ‚ùå Memory Inefficiency : 96% waste in typical scenarios (1024B allocated, 40B used) ‚ùå Resource Utilization : Suboptimal use of precious SRAM resource ‚ùå Scalability Limitation : Inefficiency grows with larger maximum packet sizes Risks and Mitigation Primary Risk: Memory Inefficiency Probability : High (96% waste is certain) Impact : Medium (limited by latency constraints to ~12KB total) Mitigation : Document multi-pool optimization path, monitor actual memory usage Secondary Risk: Future Scalability Probability : Low (latency requirements unlikely to change) Impact : Medium (could require architectural changes) Mitigation : Protocol-aware multi-pool approach documented as known optimization Implementation Notes Ring Buffer Entry Structure // Each entry = 1024 bytes payload + 16 bytes management + padding to cache line typedef struct { // Management Data (16 bytes) uint8_t uart_channel; // 0-3 uint8_t direction; // TX/RX uint8_t status; // FILLING/DRAINING/FULL/EMPTY uint8_t payload_length; // Actual data length (‚â§1024) uint32_t timestamp; // Fill timestamp uint32_t sequence_id; // For ordering/debugging uint32_t reserved; // Future use/alignment // Payload Data (1024 bytes fixed) uint8_t payload[1024]; // Fixed maximum size } __attribute__((aligned(64))) ring_entry_t; // Cache-aligned Memory Allocation Strategy Total Buffer Size : (available_memory - static_variables) / sizeof(ring_entry_t) - 1 entries Per-UART Allocation : Dynamic allocation from shared pool based on actual usage Overflow Policy : Drop oldest packets (deterministic behavior) Future Optimization Path When memory efficiency becomes critical (e.g., adding features that require more SRAM), implement Protocol-Aware Multi-Pool allocation: Multi-Pool Implementation Strategy // Future optimization - three separate pools typedef struct { ring_entry_t small_pool[SMALL_POOL_SIZE]; // 64-byte entries ring_entry_t medium_pool[MEDIUM_POOL_SIZE]; // 256-byte entries ring_entry_t large_pool[LARGE_POOL_SIZE]; // 1024-byte entries // Pool allocation logic pool_allocator_t allocator; } multi_pool_ring_buffer_t; Protocol Size Prediction Runtime Analysis : Monitor actual packet sizes during operation Protocol Configuration : Per-UART protocol profiles specifying expected size ranges Adaptive Allocation : Adjust pool usage based on observed patterns Migration Path Phase 1 : Implement size monitoring in current static allocation Phase 2 : Develop pool allocation logic with same interfaces Phase 3 : A/B test multi-pool vs static allocation Phase 4 : Switch to multi-pool if memory pressure requires it Alternative Approaches Considered Per-UART Configurable Sizing Concept : Compile-time configuration of maximum packet size per UART Rejection Reason : Adds complexity without addressing core efficiency problem Example : UART0=64B, UART1=128B, UART2=1024B, UART3=256B Hybrid Static + Overflow Concept : Small static buffers + large overflow buffer for rare large packets Rejection Reason : Violates deterministic behavior requirement Risk : Overflow scenarios create unpredictable timing Follow-up Actions Memory Monitoring : Implement runtime memory usage tracking in debug builds Size Analysis : Log actual packet sizes during development and testing Pool Design : Document detailed multi-pool implementation specifications Performance Validation : Benchmark static allocation performance characteristics Future Review : Schedule memory efficiency review after core implementation Review Notes: &#10063; Validate 12KB memory impact against other system memory requirements &#10063; Confirm cache-line alignment performance benefits on RP2350 &#10063; Review multi-pool optimization trigger conditions &#10063; Document protocol size prediction strategies &#10063; Establish memory usage monitoring in CI/CD pipeline "
},

{
    "id": 5,
    "uri": "arc42/arc42.html",
    "menu": "arc42",
    "title": "image:arc42-logo.png[arc42] Template",
    "text": " Table of Contents Template Architecture Communication Canvas 1. Introduction and Goals 1.1. Requirements Overview 1.2. Quality Goals 1.3. Stakeholders 2. Architecture Constraints 2.1. Technical Constraints 2.2. Organizational Constraints 2.3. Economic Constraints 2.4. Regulatory and Legal Constraints 3. Context and Scope 3.1. System Overview 3.2. System Scope and Boundaries 3.3. Business Context 3.4. Technical Context 3.5. Operating Mode Contexts 3.6. Integration Architecture 3.7. Future State Considerations 4. Solution Strategy 4.1. Quality Goals Foundation 4.2. Architectural Drivers 4.3. Architecture Significant Requirements (ASRs) 4.4. Solution Approach Overview 4.5. Technology Strategy 4.6. Decomposition Strategy 4.7. Quality Achievement Strategy 4.8. Strategic Decisions and Trade-offs 4.9. Implementation Strategy 4.10. Risk Assessment and Mitigation 4.11. Architecture Evolution Strategy 4.12. Conclusion 5. Building Block View 5.1. Whitebox Overall System 5.2. Level 2 5.3. Level 3 6. Runtime View 6.1. &lt;Runtime Scenario 1&gt; 6.2. &lt;Runtime Scenario 2&gt; 6.3. &#8230;&#8203; 6.4. &lt;Runtime Scenario n&gt; 7. Deployment View 7.1. System Context 7.2. Operational Requirements Summary 7.3. Deployment Environments 7.4. Firmware Deployment Architecture 7.5. Infrastructure Components 7.6. Deployment Strategies 7.7. Operational Procedures 7.8. Configuration Management 8. Cross-cutting Concepts 8.1. &lt;Concept 1&gt; 8.2. &lt;Concept 2&gt; 8.3. &lt;Concept n&gt; 9. Architecture Decisions 9.1. Hardware Platform Decisions 9.2. Software Platform Decisions 9.3. Implementation Strategy Decisions 9.4. Decision Interdependencies 10. Quality Requirements 10.1. Quality Tree 10.2. Quality Scenarios 10.3. Quality Scenarios Integration 10.4. Quality Scenario Priority Matrix 10.5. Quality Requirements Summary 10.6. Security-Industrial Operation Balance 11. Risks and Technical Debts 12. Glossary Template .arc42help {font-size:small; width: 14px; height: 16px; overflow: hidden; position: absolute; right: 0; padding: 2px 0 3px 2px;} .arc42help::before {content: \"?\";} .arc42help:hover {width:auto; height: auto; z-index: 100; padding: 10px;} .arc42help:hover::before {content: \"\";} @media print { .arc42help {display:none;} } About arc42 arc42, the template for documentation of software and system architecture. Template Version 8.2 EN. (based upon AsciiDoc version), January 2023 Created, maintained and &#169; by Dr. Peter Hruschka, Dr. Gernot Starke and contributors. See https://arc42.org . :jbake-status: published :jbake-order: 0 :jbake-type: page_toc :jbake-menu: arc42 :jbake-title: Architecture Communication Canvas .canvas ul { margin-left: 0px; padding-left: 1em; list-style: square; } .canvas tr:nth-child(1) td:nth-child(1), .canvas tr:nth-child(1) td:nth-child(2), .canvas tr:nth-child(2) td:nth-child(1), .canvas tr:nth-child(3) td:nth-child(1), .canvas tr:nth-child(4) td:nth-child(1) { background-color: #8fe4b4; border: 1px solid black; } .canvas tr:nth-child(1) td:nth-child(3), .canvas tr:nth-child(1) td:nth-child(4), .canvas tr:nth-child(4) td:nth-child(2) { background-color: #94d7ef; border: 1px solid black; } .canvas tr:nth-child(5) td:nth-child(1), .canvas tr:nth-child(5) td:nth-child(2) { background-color: #ffc7c6; border: 1px solid black; } Architecture Communication Canvas Designed for: UART2ETH Designed by: Development Team Value Proposition Provide a low-cost, open source, western-component based, regulatory-compliant alternative to expensive or black-box UART-to-TCP bridge solutions for adding networking capabilities to legacy equipment. Core Functions Full Bridge mode: Transparent UART over TCP for distant device connections Gateway mode: Add networking capabilities to products without development Up to 4 UARTs exposed as TCP sockets on individual ports Secure OTA firmware updates with A/B update mechanism Custom pluggable serial protocol filters for efficient TCP packaging Package caching with custom transmit timeouts for latency/bulk optimization Core Decisions - Good or Bad Good: RP2350 selection for open ecosystem, long-term support, and secure update capabilities Moving from ATMega328 due to baudrate inflexibility and security limitations Western-only component supply chain for regulatory compliance Bad: No major problematic decisions identified yet Strategic: Anticipating new regulations requiring updateable and auditable firmware Addressing gap left by discontinued commercial solutions Technologies Programming: C/C++ with Arduino framework Development: VSCodium IDE, PlatformIO build system Hardware: RP2350 microcontroller, ENC28J60 SPI Ethernet controller Protocols: Raw TCP sockets, HTTP for WebUI Security: RP2350 Boot ROM provided security mechanisms Infrastructure: GitHub runners for CI/CD Documentation: docToolchain with AsciiDoc Key Stakeholder Industrial engineers dealing with infrastructure challenges (noise, cable length issues) requiring networking solutions for existing equipment System integrators needing regulatory-compliant, ready-to-use networking solutions for their products without custom development Quality Requirements Performance: 500kBaud sustained throughput, &lt;5ms latency Reliability: Critical uptime as long as hardware operates within environmental specifications Security: Prevention of data distortion and lateral network movement attacks Usability: Users need basic understanding of serial communication and TCP/IP Scalability: 1 TCP connection per UART port Compliance: CE certification for hardware Business Context Data Sources: Legacy PLCs, sensors, measurement instruments, and older industrial equipment with serial interfaces but no networking capabilities Data Sinks: SCADA systems, custom data processing software, other UART2ETH devices (in Full Bridge mode) Network Environment: Industrial and household LANs operating at 100Mbit Dependencies: Only requires correctly routed network infrastructure No risky external interfaces or operational costs Components / Modules Hardware Components: * RP2350 microcontroller * Microchip ENC28J60 SPI Ethernet Controller * RJ45 connector with integrated magnetics * Crystal clock source * SPI EEPROM for firmware storage Software Modules: * TCP/IP communication module * UART instance modules (up to 4) * OTA update manager with A/B update support * Protocol filtering/packet splitting engine * Caching module with flexible ring buffer * Configuration management module * Optional WebUI module * PIO-based UART implementation (send/receive tasks on GPIO) Core Risks Primary security risk: Device compromise allowing data distortion or use as attack vector for lateral network movement Hardware component availability and supply chain disruptions Regulatory changes requiring additional compliance measures Performance degradation under high concurrent load scenarios Missing Information Testing framework selection not yet decided Specific cryptographic implementation details for OTA security WebUI design and user experience specifications Detailed protocol filter plugin architecture Performance benchmarking under various network conditions Industrial certification requirements beyond CE marking Software Architecture Canvas by Gernot Starke, Patrick Roos and arc42 Contributors is licensed under Attribution-ShareAlike 4.0 International Note This version of the template contains some help and explanations. It is used for familiarization with arc42 and the understanding of the concepts. For documentation of your own system you use better the plain version. 1. Introduction and Goals Describes the relevant requirements and the driving forces that software architects and development team must consider. These include underlying business goals, essential features, essential functional requirements, quality goals for the architecture and relevant stakeholders and their expectations 1.1. Requirements Overview 1.1.1. Purpose UART2ETH provides a hardware and firmware solution for bridging UART interfaces to TCP sockets, enabling network connectivity for legacy industrial equipment and embedded systems. 1.1.2. Core Functional Requirements Hardware Capabilities: Support up to 4 independent UART interfaces 100Mbit network interface with RJ45 connector Networking Features: Each UART exposed as individual TCP socket on dedicated port Raw TCP socket communication for transparent data transmission Support for concurrent connections (1 TCP connection per UART) Operating Modes: Full Bridge Mode: Transparent UART-over-TCP for remote device connections Gateway Mode: Add networking capabilities to existing products without firmware modifications Firmware Management: Secure Over-The-Air (OTA) firmware updates A/B update mechanism for rollback capability Protocol Optimization: Custom pluggable serial protocol filters for efficient TCP packaging Configurable packet caching with ring buffer implementation Adjustable transmit timeouts for latency or bulk transfer optimization 1.1.3. Target Use Cases Use Case Description Legacy Equipment Integration Connect PLCs, sensors, and measurement instruments to SCADA systems via network Infrastructure Problem Solving Overcome noise and cable length limitations in industrial environments System Integration Add networking to existing products without custom development effort Remote Device Access Enable distant connections to serial devices through Full Bridge mode 1.1.4. Driving Forces Regulatory Compliance: Western-only component supply chain for regulatory compliance Anticipation of new regulations requiring updateable and auditable firmware CE certification requirement for hardware Market Requirements: Address gap left by discontinued commercial UART-to-TCP solutions Provide open source alternative to expensive or black-box commercial products Enable cost-effective networking solutions for system integrators Substantial per-unit cost savings when deploying multiple units in-house compared to commercial alternatives Technical Requirements: 500kBaud sustained throughput capability Sub-5ms latency for real-time applications Critical system uptime within environmental specifications 1.2. Quality Goals The following quality goals are prioritized by importance to our major stakeholders (industrial engineers and system integrators): Priority Quality Goal Concrete Scenario 1 Reliability Critical system uptime for industrial applications A UART2ETH device deployed in a manufacturing line must maintain continuous operation for the duration that the connected hardware operates within environmental specifications. System failure should not occur due to software issues during normal operation. 2 Performance Real-time data transmission capabilities The system must sustain 500kBaud throughput with less than 5ms latency end-to-end. A PLC sending time-critical control data to a SCADA system must not experience delays that could affect industrial process control. 3 Compatibility Seamless integration with diverse industrial systems The system must work reliably with a broad range of custom baud rates and protocol parameters. It should reliably auto-negotiate ethernet connection parameters. 4 Usability Simple deployment without specialized knowledge A system integrator with basic understanding of serial communication and TCP/IP should be able to deploy and configure the device without extensive training. Configuration should be straightforward with clear error messages for common misconfigurations. 5 Maintainability Secure field updates without physical access Firmware updates must be deployable remotely via OTA mechanism with A/B rollback capability. A device installed in a remote location must be updatable without requiring on-site technician visits, while ensuring update integrity and system recovery from failed updates. 1.3. Stakeholders Role/Name Contact Expectations Industrial Engineers End user organizations, manufacturing facilities Clear documentation of network integration capabilities, performance specifications, and compatibility with existing industrial equipment. Need confidence in reliability and uptime guarantees. System Integrators Engineering consultancies, automation solution providers Comprehensive deployment guides, configuration documentation, and troubleshooting procedures. Expect regulatory compliance documentation (CE certification) and clear cost-benefit analysis. Development Team Internal project contributors Detailed architectural decisions, coding standards, build procedures, and testing frameworks. Need clear module interfaces and dependencies for parallel development work. Hardware Engineers PCB designers, component selection specialists Hardware interface specifications, power requirements, environmental constraints, and component selection rationale. Need mechanical and electrical interface documentation. Field Technicians Installation and maintenance personnel Simple installation procedures, diagnostic capabilities, and field troubleshooting guides. Need clear error indicators and recovery procedures for common failure modes. Regulatory Authorities CE certification bodies, industrial standards organizations Compliance documentation, safety analysis, electromagnetic compatibility evidence, and audit trails for component sourcing and manufacturing processes. Open Source Community Contributors, adopters, derivative projects Clear licensing terms (GPL), contribution guidelines, architectural documentation enabling modifications and extensions. Expect maintainable and well-documented code structure. 2. Architecture Constraints Contents Any requirement that constraints software architects in their freedom of design and implementation decisions or decision about the development process. These constraints sometimes go beyond individual systems and are valid for whole organizations and companies. Motivation Architects should know exactly where they are free in their design decisions and where they must adhere to constraints. Constraints must always be dealt with; they may be negotiable, though. Form Simple tables of constraints with explanations. If needed you can subdivide them into technical constraints, organizational and political constraints and conventions (e.g. programming or versioning guidelines, documentation or naming conventions) Further Information See Architecture Constraints in the arc42 documentation. 2.1. Technical Constraints Constraint Description Rationale Hardware Platform Must use RP2350 microcontroller as primary processing unit Provides required security features for OTA updates, sufficient processing power for 4 UART channels, and western supply chain compliance Component Sourcing All components must be sourced from western suppliers only Regulatory compliance requirement for target markets and supply chain security considerations Performance Requirements Minimum 500kBaud sustained throughput with sub-5ms latency per UART channel Industrial application requirements for real-time data transmission Network Interface 100Mbit Ethernet connectivity via SPI-based controller Cost constraints and sufficient bandwidth for target applications while maintaining hardware simplicity UART Channel Limit Maximum 4 independent UART interfaces Hardware resource limitations of chosen microcontroller platform and cost optimization 2.2. Organizational Constraints Constraint Description Rationale Open Source License Complete system must be released under GPL license Leverage existing open source libraries and reduce implementation effort by reusing proven components Development Process Test-driven development (TDD) approach mandatory for all production code Quality assurance and maintainability requirements for industrial application reliability Documentation Standard Architecture documentation must follow arc42 template structure Standardized documentation approach for future maintainers and contributors Version Control GitHub-based development workflow with mandatory pull request reviews Code quality control and collaborative development coordination 2.3. Economic Constraints Constraint Description Rationale Hardware Cost Hardware target price per unit must be significantly below commercially available solutions Competitive market positioning requires substantial cost advantage to justify adoption over established commercial products Development Effort Development effort must achieve return on investment within first year of deployment Resource allocation constraint limits project scope and complexity to ensure economic viability and timely market entry 2.4. Regulatory and Legal Constraints Constraint Description Rationale CE Certification Hardware must achieve CE compliance for European market Legal requirement for commercial deployment in target markets Firmware Security Must implement secure boot and signed firmware update mechanisms Anticipated regulatory requirements for updateable industrial devices EMC Compliance Electromagnetic compatibility requirements for industrial environments Regulatory requirement and operational necessity in electrically noisy industrial settings Export Control No components or technologies subject to export restrictions Unrestricted distribution and deployment capability Patent Avoidance Must not infringe on existing patents in communication protocols or hardware interfaces Legal risk mitigation and freedom to operate requirements 3. Context and Scope Contents Context and scope - as the name suggests - delimits your system (i.e. your scope) from all its communication partners (neighboring systems and users, i.e. the context of your system). It thereby specifies the external interfaces. If necessary, differentiate the business context (domain specific inputs and outputs) from the technical context (channels, protocols, hardware). Motivation The domain interfaces and technical interfaces to communication partners are among your system&#8217;s most critical aspects. Make sure that you completely understand them. Form Various options: Context diagrams Lists of communication partners and their interfaces. Further Information See Context and Scope in the arc42 documentation. 3.1. System Overview UART2ETH operates as a networking bridge that enables legacy industrial equipment with UART interfaces to communicate over TCP/IP networks. The system serves as a critical integration point in industrial automation environments, supporting two distinct operating modes: Gateway Mode : UART2ETH adds networking capabilities to existing Host Systems without requiring firmware modifications. The Host System maintains its original UART-based communication while Client Systems access it via TCP sockets over the network. Full Bridge Mode : UART2ETH provides transparent UART-over-TCP connectivity, allowing two Host Systems with UART interfaces to communicate over network infrastructure as if they were directly connected via serial cable. 3.2. System Scope and Boundaries Inside the System Boundary: RP2350 microcontroller Up to 4 UART interfaces Network interface controller (100Mbit Ethernet) Protocol filtering and optimization engines OTA update mechanism with A/B partitioning Device configuration and management interfaces Outside the System Boundary: Host Systems (PLCs, sensors, measurement instruments) Client Systems (SCADA systems, monitoring applications) Network infrastructure (switches, routers, firewalls) Firmware update servers and management systems 3.3. Business Context 3.3.1. Primary Stakeholders Stakeholder Role Primary Business Interactions Industrial Engineers Solution designers and specifiers Define networking requirements for automation projects, specify UART2ETH configurations for integrating legacy equipment into modern networks System Integrators Implementation specialists Deploy UART2ETH devices in customer facilities, configure networking parameters, integrate with existing SCADA and monitoring systems Field Technicians Installation and maintenance personnel Physical installation of devices, diagnostic troubleshooting, basic configuration changes, routine maintenance procedures Equipment Manufacturers Original equipment makers Embed UART2ETH into products to add networking capabilities, specify custom protocol filters, integrate with product lifecycle management 3.3.2. Business Use Cases Legacy Equipment Integration: Industrial Engineers specify UART2ETH to network aging PLCs, sensors, and measurement instruments that lack modern connectivity. System Integrators deploy these solutions to extend equipment lifecycles and enable remote monitoring without costly equipment replacement. Infrastructure Problem Solving: Field installations requiring long cable runs or operating in electrically noisy environments use UART2ETH to overcome serial communication limitations through network-based transmission. Remote Access Enablement: SCADA systems and monitoring applications access distributed serial devices through UART2ETH bridges, enabling centralized control and data collection across geographically dispersed facilities. 3.4. Technical Context 3.4.1. Technical Interface Specifications Interface Type Technical Details Communication Pattern UART Ports (4x) Host System Interface UART/RS232/RS422, 300-500k baud, configurable parameters Bidirectional serial, protocol-agnostic Ethernet Port Network Interface 100BASE-TX, RJ45 connector, Auto-MDIX TCP/IP networking, DHCP/Static IP TCP Sockets Client Interface Ports configurable, single connection per port TCP client connections, application protocols Management Interface Configuration Interface Web UI (HTTP), configuration interface HTTP, JSON configuration OTA Update Interface Firmware Interface Secure update server, A/B partition management HTTP, signed firmware images 3.4.2. Communication Protocols and Data Formats UART Communication: Raw serial data transmission (protocol-agnostic) Configurable baud rates: 300 bps to 500 kbps Support for custom frame formats and timing requirements Network Communication: TCP socket connections for data transmission JSON for configuration and management data Binary protocol passthrough with optional filtering HTTP for management and OTA updates Network Protocols: IPv4 with DHCP or static configuration NTP for time synchronization DNS for name resolution 3.5. Operating Mode Contexts 3.5.1. Gateway Mode Context Gateway Mode Data Flow: 1. Host System sends serial data using original protocol to UART2ETH 2. UART2ETH receives serial data and applies protocol filtering/optimization 3. Processed data is transmitted to Client Systems via TCP sockets 4. Client Systems send responses back through TCP connections 5. UART2ETH forwards responses to Host System via UART interface 3.5.2. Full Bridge Mode Context Full Bridge Mode Data Flow: 1. Host System A sends serial data to UART2ETH A 2. UART2ETH A encapsulates serial data in TCP packets and transmits over network 3. UART2ETH B receives TCP packets and extracts original serial data 4. UART2ETH B forwards serial data to Host System B via UART 5. Bidirectional communication maintains transparent serial connection 3.6. Integration Architecture 3.6.1. Critical Dependencies Network Infrastructure Dependencies: Reliable Ethernet connectivity for TCP/IP communication Network switches with appropriate bandwidth and latency characteristics DHCP services for automatic IP configuration (or static IP management) Network time synchronization for accurate timestamping Power and Environmental Dependencies: 3.3V-24V power supply within industrial specifications Operating temperature range suitable for industrial environments Protection from electromagnetic interference in industrial settings Security Dependencies: Network firewall configuration to allow necessary TCP ports Firmware signing infrastructure for secure OTA updates Network segmentation appropriate for industrial security requirements 3.6.2. Security and Compliance Boundaries Network Security: Cryptographic signatures for firmware validation and integrity Configurable TCP port ranges to support firewall policies Input validation and sanitization for all network interfaces Industrial Compliance: CE certification for European industrial markets Electromagnetic compatibility (EMC) for industrial environments Component sourcing from Western suppliers for regulatory compliance Audit trail for firmware updates and configuration changes 3.6.3. Performance and Scalability Characteristics Performance Requirements: 500 kbps sustained throughput per UART port Sub-5ms end-to-end latency for real-time applications Concurrent TCP connections (one per UART port) Configurable buffering for latency vs. throughput optimization Scalability Considerations: Up to 4 simultaneous UART-to-TCP bridges per device Network deployment limited by IP address availability and network bandwidth Protocol filtering reduces network traffic for efficient bulk transfers A/B firmware updates enable fleet-wide updates without service interruption 3.7. Future State Considerations 3.7.1. Planned Integrations Enhanced Protocol Support: Additional protocol filters for common industrial protocols (Modbus, DNP3, IEC 61850) HTTPS/TLS on-the-wire encryption Advanced Management Features: Integration with network management systems (SNMP, NETCONF) Enhanced diagnostic and monitoring capabilities 4. Solution Strategy Contents A short summary and explanation of the fundamental decisions and solution strategies, that shape system architecture. It includes technology decisions decisions about the top-level decomposition of the system, e.g. usage of an architectural pattern or design pattern decisions on how to achieve key quality goals relevant organizational decisions, e.g. selecting a development process or delegating certain tasks to third parties. Motivation These decisions form the cornerstones for your architecture. They are the foundation for many other detailed decisions or implementation rules. Form Keep the explanations of such key decisions short. Motivate what was decided and why it was decided that way, based upon problem statement, quality goals and key constraints. Refer to details in the following sections. Further Information See Solution Strategy in the arc42 documentation. 4.1. Quality Goals Foundation 4.1.1. Primary Quality Goals Quality Goal Priority Description &amp; Success Criteria Reliability 1 (Primary Driver) Critical system uptime for industrial applications. Must not fail due to software issues during normal operation within environmental specifications. Compatibility 2 (Secondary Driver) Seamless integration with diverse industrial systems. Support broad range of custom baud rates and protocol parameters with reliable auto-negotiation. Performance 3 (Supporting Driver) 500kBaud sustained throughput with sub-5ms end-to-end latency. Real-time data transmission capabilities for industrial process control. 4.1.2. Quality Scenarios Summary Quality Attribute Scenario Measurable Requirement Reliability Industrial Operation Continuous operation for duration of connected hardware operation within environmental specifications Performance Real-time Control PLC sending time-critical control data must experience &lt;5ms latency to SCADA system Compatibility Protocol Flexibility Work reliably with broad range of custom baud rates and protocol parameters 4.2. Architectural Drivers 4.2.1. Business Drivers (Priority Order) Regulatory Compliance - Western-only components, anticipating new regulations for updateable/auditable firmware Market Gap - Address discontinued commercial solutions, provide open source alternative to expensive/black-box products Industrial Deployment - Must operate reliably in harsh industrial environments ROI - First-year return on investment (afterthought, minimal architectural influence) 4.2.2. Technical Drivers (Priority Order) 4-UART Requirement - Multiple concurrent serial bridges, each must operate independently Static Memory Model - No dynamic allocation, all memory allocated at compile time for predictable behavior RP2350 Platform - Dual-core ARM, PIO capabilities, security features enable advanced functionality 4.2.3. Organizational Drivers (Priority Order) TDD + C Expertise - Mandatory test-driven development, deep embedded C knowledge in team Arc42 Documentation - Standardized architecture documentation approach Open Source GPL - Complete transparency (minimal architectural influence) 4.3. Architecture Significant Requirements (ASRs) 4.3.1. Non-Negotiable (System Fails Without These) Industrial Reliability - Must not fail during normal operation Static Resource Allocation - Enables reliability through predictability 500kBaud Sustained Rate - Crucial performance baseline Secure OTA with A/B Updates - \"We can fix everything if this works\" 4.3.2. Negotiable (Important but Flexible) 4 UARTs (important but not crucial) Protocol agnostic operation (debatable) Compliance auditability (debatable) 4.4. Solution Approach Overview Fundamental Architecture: Dual-Core Separation + Interrupts/DMA 4.5. Technology Strategy 4.5.1. Core Technology Decisions Technology Area Strategic Decision &amp; Rationale Architecture Pattern Dual-core separation with interrupt/DMA - provides fault isolation while achieving hardware-driven performance Programming Language C with Native Pico SDK - leverages team expertise, provides full platform access, enables deterministic behavior Memory Management Static allocation only - enables industrial reliability through predictable behavior, no dynamic allocation risks Inter-Core Communication Cache-aligned ring buffers with mutexes - optimal performance with deterministic behavior Ethernet Controller ENC28J60 with software TCP/IP - \"dumb\" controller enables full code auditability and control 4.5.2. Communication Architecture Ring Buffer Design: // Each entry = 1 cache line (64 bytes base + 1024 payload) typedef struct { // Management Data (16 bytes) uint8_t uart_channel; // 0-3 uint8_t direction; // TX/RX uint8_t status; // FILLING/DRAINING/FULL/EMPTY uint8_t payload_length; // Actual data length uint32_t timestamp; // Fill timestamp uint32_t sequence_id; // For ordering/debugging uint32_t reserved; // Future use/alignment // Payload Data (1024 bytes max) uint8_t payload[1024]; // Fixed max size for worst case } ring_entry_t; Memory Allocation Strategy: Buffer Size: (total_mem - static_vars) / sizeof(ring_entry_t) - 1 entries Cache Aligned: No core contention, optimal performance Overflow Policy: Drop oldest packets (deterministic, simple) 4.6. Decomposition Strategy 4.6.1. System Decomposition Approach Dual-core functional separation - Each core specializes in distinct responsibilities with clean interfaces through shared memory ring buffers. 4.6.2. Major Components/Services Component/Service Responsibilities Key Interfaces Core 0 UART Manager All 4 UART interfaces, interrupt/DMA handling, stream-to-packet conversion Hardware UARTs, Ring buffer producer Core 1 Network Manager TCP/IP stack, ENC28J60 control, packet-to-network conversion Ring buffer consumer, SPI to ENC28J60 Ring Buffer System Inter-core communication, cache-aligned data transfer Shared memory + mutex interfaces HTTP Management UI Device configuration, diagnostics, OTA trigger HTTP server on Core 1 OTA Update System Secure firmware updates, A/B partition management Secure boot, flash management 4.6.3. Component Interaction Strategy Interaction Principles: Core 0 ‚Üí Ring Buffer: UART streams converted to fixed-size packets, cache-aligned writes Ring Buffer ‚Üí Core 1: Packet consumption for TCP transmission Overflow Policy: Drop oldest packets (deterministic, simple) Priority: UART processing takes priority over HTTP UI 4.7. Quality Achievement Strategy 4.7.1. Quality Goal Implementation Quality Goal Architectural Mechanisms Validation Approach Reliability Core separation, static allocation, deterministic behavior, drop-oldest overflow Extended operation testing, fault injection, environmental testing Compatibility Protocol-agnostic packet handling, configurable UART parameters Testing with diverse industrial protocols, auto-negotiation validation Performance Interrupt/DMA driven I/O, cache-aligned buffers, hardware-optimized data paths Sustained 500kBaud testing, latency measurements, stress testing 4.7.2. Cross-Cutting Concerns Strategy Cross-Cutting Concern Implementation Strategy Error Handling Graceful degradation, fault isolation between cores, deterministic error responses Memory Management Static allocation only, pre-calculated buffer sizes, cache-aligned data structures Security Secure OTA updates, A/B partitioning, auditable code paths Testing Host-based testing with abstracted semaphores, hardware-in-the-loop validation 4.8. Strategic Decisions and Trade-offs 4.8.1. Major Architectural Decisions Decision Rationale Trade-offs Dual-Core Separation Fault isolation + performance, leverages RP2350 capabilities Increased complexity vs single-core simplicity Fixed 1024-byte Packets Deterministic behavior, handles worst-case scenarios 96% memory waste (avg 40 bytes vs 1024 max) accepted for simplicity Drop-Oldest Overflow Deterministic, reliable behavior under overload Data loss vs flow control complexity Cache-Aligned Buffers Optimal inter-core performance Memory overhead vs efficiency 4.8.2. Key Trade-off: Fixed Packet Size Inefficiency The Challenge: Realistic scenario: Max=1024 bytes, Average=40 bytes ‚Üí 96% memory waste Risk: Significant resource inefficiency in typical use cases Mitigation Rationale: Sub-5ms latency requirement limits buffering depth anyway (~2-3 packets maximum) Total waste limited: 4 UARTs √ó 3 packets √ó 1024 bytes = ~12KB (acceptable in 520KB system) Implementation simplicity enables reliable delivery Future Optimization Path: Protocol-aware multi-pool approach documented for later enhancement: Small Pool: 64-byte entries (for ‚â§40 byte packets) Medium Pool: 256-byte entries (for 41-200 byte packets) Large Pool: 1024-byte entries (for 201-1024 byte packets) 4.8.3. Alternative Approaches Considered Alternative Why Not Selected Key Insight Single-Core Design Cannot achieve 4-UART + network performance simultaneously Core separation essential for real-time requirements Dynamic Memory Allocation Conflicts with industrial reliability requirements Static allocation mandatory for predictable behavior W5500 Ethernet Controller Hardware TCP/IP stack not auditable, conflicts with compliance goals \"Dumb\" controller enables full code control 4.9. Implementation Strategy 4.9.1. Development Approach Implementation Aspect Strategy Development Methodology Test-driven development with host-based testing using abstracted semaphores Testing Strategy Host simulation with pthread/threads, then hardware validation Risk Mitigation Single UART + single TCP proof-of-concept first Platform Abstraction Abstract semaphores/mutexes for host testing: platform_mutex_t , platform_semaphore_t 4.9.2. Implementation Phases Phase 1: Proof of Concept Single UART + Single TCP socket Mock ring buffer with abstracted semaphores Host-based testing with thread simulation Validate core architecture concepts Phase 2: Full System Implementation All 4 UARTs on Core 0 Complete ring buffer system Full TCP/IP integration on Core 1 HTTP management UI Phase 3: Advanced Features Secure OTA implementation A/B update mechanism Industrial hardening and optimization 4.9.3. Validation and Success Metrics Milestone Success Criteria Validation Method Ring Buffer Validation Concurrent producer/consumer without data corruption Host-based stress testing Performance Achievement 500kBaud sustained, &lt;5ms latency Hardware-in-the-loop measurement Reliability Demonstration 24+ hour continuous operation Extended testing under load 4.10. Risk Assessment and Mitigation 4.10.1. Strategic Risks Risk Probability/Impact Mitigation Strategy Fixed Packet Size Inefficiency High/Medium Document multi-pool optimization path, validate memory usage early Inter-Core Communication Complexity Medium/High Prove with host-based testing first, extensive validation Performance Under Load Medium/High Early prototyping, stress testing, hardware validation 4.11. Architecture Evolution Strategy 4.11.1. Future Optimization Path Protocol-Aware Enhancements: Multi-pool buffer management for memory efficiency Protocol-specific packet sizing based on message type analysis Dynamic buffer allocation per UART based on usage patterns Security and Compliance Evolution: Enhanced security features for evolving compliance requirements Extended audit trail capabilities Additional cryptographic features as regulations develop Performance Optimizations: Fine-tuned based on real-world deployment data Protocol filter optimizations Network stack performance improvements 4.11.2. Success Factors Critical Dependencies: Early validation of ring buffer architecture with host-based testing Incremental implementation starting with single UART proof-of-concept Comprehensive testing at each phase before proceeding Key Assumptions: RP2350 dual-core performance meets concurrent processing requirements Cache-aligned ring buffers provide sufficient inter-core bandwidth Static memory allocation provides adequate resource management Monitoring and Adaptation: Continuous validation of memory efficiency in real deployments Performance monitoring under various industrial load scenarios Regular assessment of compliance requirement evolution 4.12. Conclusion This solution strategy establishes UART2ETH as an \"unbreakable foundation with field-updateable capability\" through: Core Architectural Principles: Reliability-first dual-core separation Static allocation for predictable behavior Hardware-driven performance with software control Protocol-agnostic flexibility Strategic Advantages: Fault isolation enables industrial reliability Deterministic behavior supports real-time requirements Full code auditability meets compliance needs Incremental implementation reduces development risk Success Enablers: TDD approach with host-based validation Clear module boundaries for team development Documented optimization paths for future enhancement Strong foundation for scaling and feature evolution The strategy balances immediate reliability requirements with long-term flexibility, ensuring UART2ETH can serve as a robust industrial networking solution while maintaining the ability to evolve with changing requirements and regulations. 5. Building Block View Content The building block view shows the static decomposition of the system into building blocks (modules, components, subsystems, classes, interfaces, packages, libraries, frameworks, layers, partitions, tiers, functions, macros, operations, data structures, &#8230;&#8203;) as well as their dependencies (relationships, associations, &#8230;&#8203;) This view is mandatory for every architecture documentation. In analogy to a house this is the floor plan . Motivation Maintain an overview of your source code by making its structure understandable through abstraction. This allows you to communicate with your stakeholder on an abstract level without disclosing implementation details. Form The building block view is a hierarchical collection of black boxes and white boxes (see figure below) and their descriptions. Level 1 is the white box description of the overall system together with black box descriptions of all contained building blocks. Level 2 zooms into some building blocks of level 1. Thus it contains the white box description of selected building blocks of level 1, together with black box descriptions of their internal building blocks. Level 3 zooms into selected building blocks of level 2, and so on. Further Information See Building Block View in the arc42 documentation. 5.1. Whitebox Overall System The UART2ETH system follows a dual-core separation strategy that provides fault isolation while achieving hardware-driven performance. The system is decomposed into five major building blocks that each handle distinct responsibilities in the UART-to-TCP bridge functionality. 5.1.1. Motivation The dual-core separation strategy from our solution approach drives this decomposition to achieve: Fault isolation : Each core has distinct responsibilities to prevent cascading failures Performance optimization : Hardware-driven I/O with software control for real-time requirements Industrial reliability : Predictable behavior through static allocation and deterministic interfaces Bidirectional communication : Both UART and TCP interfaces require full-duplex operation 5.1.2. Contained Building Blocks Name Responsibility Core 0 UART Subsystem Manages all 4 UART interfaces with interrupt/DMA handling. Performs bidirectional stream-to-packet conversion for communication with the ring buffer system. Core 1 Network Subsystem Implements TCP/IP stack and Ethernet controller interface with interrupt/DMA handling. Copies packets from and to the network stack and manages TCP socket connections. Ring Buffer Communication Provides bidirectional inter-core data transfer using a shared memory pool with cache-aligned, mutex-protected buffers. Handles dynamic burst allocation by being channel and driection agnostic. Management Interface Offers web-based configuration, monitoring, and administration through HTTP server with authentication, statistics collection, and configuration UIs. OTA Update System Manages secure firmware updates with A/B partition management, signature validation, and automatic rollback capabilities. 5.1.3. Important Interfaces Ring Buffer Interface Shared Pool Design : Single buffer pool serves both directions dynamically Core 0 : Producer (UART RX) + Consumer (UART TX) using shared pool Core 1 : Producer (TCP RX) + Consumer (TCP TX) using shared pool Entry Format : Fixed 1088-byte entries (64-byte header + 1024-byte payload) Synchronization : Mutex-protected operations for shared pool access Overflow Policy : Drop-oldest across entire pool (direction-agnostic) Network Interface External : 10BASE-T Ethernet, RJ45 connector (ENC28J60 limitation) Internal : SPI to ENC28J60 controller, software TCP/IP stack (lwIP) UART Interface Hardware : 4 independent UART channels with configurable parameters Protocols : UART/RS232/RS422 support with 300-500kBaud range Configuration : Per-channel baud rate, data bits, stop bits, parity settings 5.2. Level 2 5.2.1. Whitebox Core 0 UART Subsystem The Core 0 UART Subsystem specializes in handling all UART communication with dedicated hardware management, interrupt processing, and bidirectional data conversion between stream and packet formats. Motivation Core 0 specialization enables real-time UART processing without interference from network operations. The bidirectional packet conversion allows seamless translation between continuous UART streams and discrete network packets. Contained Building Blocks Name Responsibility UART Hardware Manager Direct control of 4 UART channels with configurable parameters (baud rate, data bits, parity). Manages hardware registers and status monitoring. Interrupt Handler Processes time-critical UART events (RX data available, TX buffer empty) with minimal latency for real-time performance. DMA Controller Optimizes bulk data transfers in both directions to reduce CPU load and improve throughput for high-baud applications. Packet Assembler Converts incoming UART streams into fixed-size packets for ring buffer storage. Handles framing and timestamp metadata. Packet Disassembler Extracts UART data from ring buffer packets and converts back to continuous streams for transmission. Ring Buffer Interface Provides producer operations (UART RX data) and consumer operations (UART TX data) with proper synchronization. 5.2.2. Whitebox Core 1 Network Subsystem The Core 1 Network Subsystem manages all network communication including TCP/IP protocol processing, Ethernet controller interface, and bidirectional packet routing between ring buffer and network clients. Motivation Core 1 specialization allows network processing to operate independently from time-critical UART operations. The modular design enables efficient TCP/IP processing while maintaining clear separation between hardware drivers and application logic. Contained Building Blocks Name Responsibility lwIP TCP/IP Stack Complete software-based TCP/IP implementation providing standard network protocols and socket interfaces. ENC28J60 Driver Low-level SPI driver for the 10BASE-T Ethernet controller, handling frame transmission and reception. Socket Manager Manages TCP socket connections with one dedicated socket per UART channel. Handles connection lifecycle and error recovery. Packet Router Maps UART channel numbers to TCP port numbers and routes data bidirectionally between network and ring buffer interfaces. Packet Assembler Converts incoming TCP data streams into ring buffer packets for transmission to Core 0. Packet Disassembler Extracts data from ring buffer packets and formats for TCP transmission to network clients. Ring Buffer Interface Provides producer operations (TCP RX data) and consumer operations (TCP TX data) with shared pool access. 5.2.3. Whitebox Ring Buffer Communication System The Ring Buffer Communication System provides the critical inter-core communication mechanism using a shared memory pool that dynamically handles bursts from either direction while maintaining deterministic behavior. Motivation The shared buffer pool design provides elegant burst handling by allowing dynamic allocation to whichever direction needs capacity. This approach is more efficient than fixed per-direction pools and gracefully handles real-world traffic patterns. Contained Building Blocks Name Responsibility Shared Buffer Pool Single memory pool that dynamically serves both UART‚ÜíTCP and TCP‚ÜíUART directions with fixed-size entries. Mutex Manager Provides thread-safe access to the shared pool using FreeRTOS mutexes and semaphores for inter-core synchronization. Memory Manager Handles allocation and deallocation of fixed-size buffer entries with cache-aligned addressing for optimal performance. Overflow Handler Implements drop-oldest policy when buffer reaches capacity, ensuring deterministic behavior under overload conditions. Statistics Collector Tracks buffer utilization, message counts, throughput metrics, and error conditions for monitoring and diagnostics. 5.2.4. Whitebox Management Interface The Management Interface provides comprehensive web-based administration through modular components handling authentication, configuration, and monitoring functions. Motivation The modular management interface design separates concerns between web serving, authentication, data collection, and configuration UIs. This enables independent development and testing of each component while providing a comprehensive administration solution. Contained Building Blocks Name Responsibility HTTP Web Server Processes HTTP/1.1 requests, serves static content (HTML/CSS/JS), provides REST API endpoints, and manages user sessions. Authentication System Handles user login validation, JWT session token management, role-based access control, and security header implementation. Statistical Data Module Collects real-time metrics from system components, maintains historical data, tracks performance counters, and monitors system health. UART Configuration UI Provides web interface for configuring UART channel settings, hardware control options, protocol filters, and parameter validation. TCP/IP Configuration UI Offers web interface for network settings, TCP port mapping, connection limits, and security configurations. 5.3. Level 3 5.3.1. Whitebox Core 0 UART Handler Subsystem The Core 0 UART Subsystem specializes in handling all UART communication with dedicated hardware management, interrupt processing, and bidirectional data conversion between stream and packet formats. Motivation UART processing utilizing UART specific ISR and DMA transfers for maximum troughput. Contained Building Blocks Name Responsibility UART Hardware Manager Direct control of 4 UART channels with configurable parameters (baud rate, data bits, parity). Manages hardware registers and status monitoring. Interrupt Handler Processes time-critical UART events (RX data available, TX buffer empty) with minimal latency for real-time performance. DMA Controller Controls bulk data transfers in both directions DMA Channel Optimizes bulk data transfers in both directions to reduce CPU load and improve throughput for high-baud applications. Packet Assembler Converts incoming UART streams into fixed-size packets for ring buffer storage. Handles framing and timestamp metadata. Packet Disassembler Extracts UART data from ring buffer packets and converts back to continuous streams for transmission. Ring Buffer Interface Provides producer operations (UART RX data) and consumer operations (UART TX data) with proper synchronization. 5.3.2. Whitebox Ring Buffer System Internal Structure The Ring Buffer System provides the foundational inter-core communication with detailed memory management, helper functions, and synchronization primitives. Purpose Provides efficient, thread-safe, bidirectional communication between cores with deterministic behavior and comprehensive monitoring capabilities. Internal Structure Memory Layout Manager Manages the physical organization of the ring buffer in memory with cache-aligned addressing and efficient index calculations. Ring Buffer Array : Contiguous memory block with cache-aligned entries Index Management : Head/tail pointers with wrap-around logic Memory Addressing : Base address + (index √ó entry_size) calculations Buffer Management Functions Core API providing the helper functions for ring buffer operations and monitoring. // Core buffer operations ring_entry_t* find_next_free_block(void); ring_entry_t* find_next_ready_block(uint8_t uart_channel, uint8_t direction); bool is_buffer_full(void); bool is_buffer_empty(void); // Statistics and monitoring uint32_t get_cached_message_count(void); uint32_t get_cached_message_count_by_channel(uint8_t uart_channel); uint32_t get_cached_message_count_by_direction(uint8_t direction); uint32_t get_free_block_count(void); uint32_t get_overflow_count(void); // Dropped messages uint32_t get_total_throughput_bytes(void); // Advanced operations ring_entry_t* peek_next_block(uint8_t uart_channel, uint8_t direction); void mark_block_ready(ring_entry_t* entry); void mark_block_consumed(ring_entry_t* entry); void reset_buffer_statistics(void); Memory Layout Structure Complete ring buffer system data structure with metadata, statistics, and synchronization primitives. typedef struct { // Ring buffer metadata (cache-aligned) volatile uint32_t head_index; // Producer index volatile uint32_t tail_index; // Consumer index volatile uint32_t entry_count; // Current entries uint32_t max_entries; // Buffer capacity // Statistics (cache-aligned) uint32_t total_produced; uint32_t total_consumed; uint32_t overflow_count; uint32_t underflow_count; // Synchronization mutex_t buffer_mutex; semaphore_t free_space_sem; semaphore_t data_ready_sem; // Entry array (cache-aligned) ring_entry_t entries[]; } ring_buffer_system_t; Data Entry Format Individual ring buffer entry structure used for both communication directions. typedef struct { // Management Data (16 bytes) uint8_t uart_channel; // 0-3 uint8_t direction; // RX_UART_TO_TCP / RX_TCP_TO_UART uint8_t status; // FILLING/DRAINING/FULL/EMPTY uint8_t payload_length; // Actual data length uint32_t timestamp; // Fill timestamp uint32_t sequence_id; // For ordering/debugging uint32_t next_in_use; // Packets in use (within ring buffer) are a single linked list uint32_t reserved; // Future use/alignment // Payload Data (1024 bytes max) uint8_t payload[1024]; // Fixed max size for worst case } ring_entry_t; 5.3.3. Whitebox UART Hardware Manager Internal Structure The UART Hardware Manager provides unified control over all 4 UART channels with individual controllers, parameter management, and comprehensive status monitoring. Purpose Provides unified interface to all 4 UART channels with configurable parameters, comprehensive status monitoring, and efficient interrupt handling. Internal Structure UART Configuration Interface Complete configuration structure for UART channel parameters. typedef struct { uint32_t baud_rate; // 300-500000 bps uint8_t data_bits; // 5-8 bits uint8_t stop_bits; // 1-2 bits uint8_t parity; // NONE/ODD/EVEN bool flow_control; // Hardware flow control bool rs485_mode; // RS485 half-duplex mode } uart_config_t; UART Operations API Core function interface for UART channel operations. // Channel operations int uart_channel_configure(uint8_t channel, uart_config_t* config); int uart_channel_read(uint8_t channel, uint8_t* buffer, size_t length); int uart_channel_write(uint8_t channel, const uint8_t* data, size_t length); bool uart_channel_is_ready(uint8_t channel); uint32_t uart_channel_get_status(uint8_t channel); Status Monitoring Structure Comprehensive status tracking for each UART channel. typedef struct { bool carrier_detect; bool clear_to_send; bool data_set_ready; uint32_t rx_errors; uint32_t tx_errors; uint32_t frames_received; uint32_t frames_transmitted; } uart_channel_status_t; 5.3.4. Whitebox Management Interface Internal Structure The Management Interface provides comprehensive web-based administration through specialized components for HTTP serving, authentication, statistics, and configuration management. Purpose Provides comprehensive web-based configuration, monitoring, and administration interface with modular components for different management aspects. Internal Structure HTTP Web Server Components Request Handler typedef struct { uint16_t port; // Default: 80 uint32_t max_connections; // Concurrent sessions char document_root[256]; // Static content path } webserver_config_t; int webserver_start(webserver_config_t* config); int webserver_register_endpoint(const char* path, http_handler_t handler); int webserver_send_response(int client_fd, http_response_t* response); Authentication System Components User Management typedef enum { AUTH_ROLE_ADMIN, // Full configuration access AUTH_ROLE_OPERATOR, // Monitor + basic config AUTH_ROLE_READONLY // Monitor only } auth_role_t; typedef struct { char username[32]; char password_hash[64]; // SHA-256 hash auth_role_t role; bool enabled; } user_account_t; bool authenticate_user(const char* username, const char* password); const char* create_session_token(const char* username); bool validate_session_token(const char* token); Statistical Data Components System Statistics Structure typedef struct { // Per-channel statistics struct { uint64_t bytes_transmitted; uint64_t bytes_received; uint32_t messages_transmitted; uint32_t messages_received; uint32_t error_count; uint32_t overflow_count; float average_latency_ms; uint32_t current_baud_rate; } uart_stats[4]; // Network statistics uint64_t tcp_bytes_sent; uint64_t tcp_bytes_received; uint32_t tcp_connections_active; uint32_t tcp_connections_total; // System statistics uint32_t uptime_seconds; uint32_t cpu_usage_percent; uint32_t memory_used_bytes; uint32_t ring_buffer_utilization_percent; } system_statistics_t; Configuration Interface Components UART Configuration Structure typedef struct { bool enabled; uart_config_t config; // From UART Hardware Manager char description[64]; // User-friendly name bool protocol_filter_enabled; char protocol_filter_type[32]; // \"SharkNet\", \"custom\", etc. } uart_channel_settings_t; Network Configuration Structure typedef struct { // Network configuration bool use_dhcp; char ip_address[16]; // \"192.168.1.100\" char subnet_mask[16]; // \"255.255.255.0\" char gateway[16]; // \"192.168.1.1\" char dns_primary[16]; char dns_secondary[16]; // Port mapping struct { uint16_t tcp_port; // 4001-4004 default bool enabled; uint32_t connection_timeout_ms; char allowed_clients[256]; // IP ranges: \"192.168.1.0/24\" } port_config[4]; // Security bool enable_firewall; char hostname[64]; uint16_t management_port; // Web UI port (default 80) } network_config_t; 6. Runtime View Contents The runtime view describes concrete behavior and interactions of the system‚Äôs building blocks in form of scenarios from the following areas: important use cases or features: how do building blocks execute them? interactions at critical external interfaces: how do building blocks cooperate with users and neighboring systems? operation and administration: launch, start-up, stop error and exception scenarios Remark: The main criterion for the choice of possible scenarios (sequences, workflows) is their architectural relevance . It is not important to describe a large number of scenarios. You should rather document a representative selection. Motivation You should understand how (instances of) building blocks of your system perform their job and communicate at runtime. You will mainly capture scenarios in your documentation to communicate your architecture to stakeholders that are less willing or able to read and understand the static models (building block view, deployment view). Form There are many notations for describing scenarios, e.g. numbered list of steps (in natural language) activity diagrams or flow charts sequence diagrams BPMN or EPCs (event process chains) state machines &#8230;&#8203; Further Information See Runtime View in the arc42 documentation. 6.1. &lt;Runtime Scenario 1&gt; &lt;insert runtime diagram or textual description of the scenario&gt; &lt;insert description of the notable aspects of the interactions between the building block instances depicted in this diagram.&gt; 6.2. &lt;Runtime Scenario 2&gt; 6.3. &#8230;&#8203; 6.4. &lt;Runtime Scenario n&gt; 7. Deployment View 7.1. System Context The UART2ETH system is an embedded hardware solution based on the RPI RP2350 microcontroller that bridges UART interfaces to TCP sockets. The deployment view focuses on the firmware deployment pipeline, from development through QA validation to field deployment via Over-The-Air (OTA) updates. 7.2. Operational Requirements Summary Requirement Type Target Description Availability Zero-downtime updates A/B partition switching maintains device operation until manual reboot Security Signed firmware delivery Cryptographic signing, secure boot, initial key embedding at factory Reliability Automatic rollback Watchdog-based rollback mechanism for failed firmware updates Auditability Version tracking Git tags and commit checksums embedded in firmware builds Control Manual operations No remote device reboots, QA gatekeeping for all releases 7.3. Deployment Environments 7.3.1. Environment Overview 7.3.2. Environment Specifications Environment Purpose Hardware Deployment Method Development Feature development and local testing Individual RP2350 devices per developer Direct flash programming QA Testing Release validation with real hardware Single testbench with RP2350 hardware Automated test deployment Production Live firmware distribution Customer-deployed field devices OTA HTTP downloads Factory Initial device provisioning Manufacturing test fixtures Flash programming + key embedding 7.4. Firmware Deployment Architecture 7.4.1. High-Level Architecture 7.4.2. A/B Partition Strategy 7.5. Infrastructure Components 7.5.1. Build and Release Infrastructure Component Technology &amp; Configuration Purpose &amp; Responsibilities CMake Build System Pico SDK integration, firmware signing Compile source code, embed version info, sign binaries Developer Hardware Individual RP2350 devices Local development and unit testing QA Testbench Single automated test fixture with RP2350 Hardware-in-the-loop validation of release candidates Cloud OTA Server HTTP-based firmware distribution Serve approved firmware to field devices Key Management Secure cryptographic key storage Firmware signing keys, device authentication 7.5.2. Security Architecture Security Layer Implementation Factory Key Embedding Cryptographic keys installed during initial manufacturing flash Firmware Signing All firmware builds cryptographically signed before distribution Secure Boot RP2350 ROM bootloader verifies firmware signatures before execution OTA Authentication Device authenticates with OTA server before firmware download Partition Verification Each partition validated before boot attempt 7.6. Deployment Strategies 7.6.1. Firmware Update Process Stage Process Validation &amp; Control Development Build CMake compilation with embedded version tags Local developer testing on real hardware QA Validation Automated testbench execution Hardware-in-the-loop testing, manual approval gate Production Release QA promotes approved firmware to OTA server Single gatekeeper model, full traceability Field Deployment Device pulls firmware via HTTP when configured Manual reboot required, automatic rollback protection 7.6.2. A/B Partition Management 7.7. Operational Procedures 7.7.1. Version Management and Auditability Aspect Implementation Benefits Version Identification Git tags and commit checksums embedded in firmware Precise traceability of deployed firmware versions Build Reproducibility Deterministic build process with version tagging Ability to rebuild exact firmware for debugging Release Documentation QA approval records linked to firmware versions Clear audit trail for all production releases Field Identification Device reports firmware version via management interface Support teams can identify deployed firmware versions 7.7.2. Rollback and Recovery Procedures Scenario Recovery Method Implementation Boot Failure Automatic rollback via watchdog timeout RP2350 ROM bootloader switches to backup partition Corrupted Download Signature verification failure Device rejects invalid firmware, retains current version Network Issues Download retry mechanism Device continues with current firmware, retries later Total Firmware Corruption Device replacement No field recovery possible when both partitions corrupted 7.7.3. Monitoring and Maintenance Monitoring Aspect Implementation Firmware Version Tracking Git checksums embedded in firmware, reported via management UI Update Success Rate Device reports successful updates to management interface Rollback Events Watchdog rollback events logged in device memory OTA Server Health HTTP availability monitoring for firmware distribution 7.8. Configuration Management 7.8.1. OTA Server Configuration The UART2ETH device supports flexible OTA server configuration: Default Server : Company-hosted cloud OTA server for standard deployments Customer Servers : Configurable OTA server URL via management interface HTTP Protocol : Simple HTTP-based firmware downloads (no HTTPS requirement) Pull-based Updates : Devices initiate update checks, no push capability 8. Cross-cutting Concepts Content This section describes overall, principal regulations and solution ideas that are relevant in multiple parts (= cross-cutting) of your system. Such concepts are often related to multiple building blocks. They can include many different topics, such as models, especially domain models architecture or design patterns rules for using specific technology principal, often technical decisions of an overarching (= cross-cutting) nature implementation rules Motivation Concepts form the basis for conceptual integrity (consistency, homogeneity) of the architecture. Thus, they are an important contribution to achieve inner qualities of your system. Some of these concepts cannot be assigned to individual building blocks, e.g. security or safety. Form The form can be varied: concept papers with any kind of structure cross-cutting model excerpts or scenarios using notations of the architecture views sample implementations, especially for technical concepts reference to typical usage of standard frameworks (e.g. using Hibernate for object/relational mapping) Structure A potential (but not mandatory) structure for this section could be: Domain concepts User Experience concepts (UX) Safety and security concepts Architecture and design patterns \"Under-the-hood\" development concepts operational concepts Note: it might be difficult to assign individual concepts to one specific topic on this list. Further Information See Concepts in the arc42 documentation. 8.1. &lt;Concept 1&gt; &lt;explanation&gt; 8.2. &lt;Concept 2&gt; &lt;explanation&gt; &#8230;&#8203; 8.3. &lt;Concept n&gt; &lt;explanation&gt; 9. Architecture Decisions Contents Important, expensive, large scale or risky architecture decisions including rationales. With \"decisions\" we mean selecting one alternative based on given criteria. Please use your judgement to decide whether an architectural decision should be documented here in this central section or whether you better document it locally (e.g. within the white box template of one building block). Avoid redundancy. Refer to section 4, where you already captured the most important decisions of your architecture. Motivation Stakeholders of your system should be able to comprehend and retrace your decisions. Form Various options: ADR ( Documenting Architecture Decisions ) for every important decision List or table, ordered by importance and consequences or: more detailed in form of separate sections per decision Further Information See Architecture Decisions in the arc42 documentation. There you will find links and examples about ADR. This section references the Architecture Decision Records (ADRs) that document key technical decisions for the UART2ETH project. These decisions form the foundation of the system architecture and significantly influence capabilities, performance characteristics, and development approach. 9.1. Hardware Platform Decisions ADR-001: Microcontroller Platform Selection - Documents the decision to use the Raspberry Pi RP2350 as the core microcontroller platform. ADR-002: Ethernet Controller Selection - Documents the decision to use the ENC28J60 as the Ethernet controller. 9.2. Software Platform Decisions ADR-003: Programming Language Selection - Documents the decision to use C programming language for firmware development, considering team expertise, delivery timeline, and memory model constraints. ADR-004: Development Ecosystem Selection - Documents the decision to use Native Pico SDK + CMake development ecosystem for professional, industrial-grade development. 9.3. Implementation Strategy Decisions ADR-005: Ring Buffer Memory Allocation Strategy - Documents the decision to use static worst-case allocation for inter-core communication buffers, prioritizing reliability and determinism over memory efficiency. 9.4. Decision Interdependencies The ADRs reveal important interdependencies that influence architectural coherence: ADR-004 (Development Ecosystem) challenges ADR-002 (Ethernet Controller) : The ecosystem analysis revealed that ENC28J60 lacks mature RP2350 SDK integration, potentially requiring significant custom development effort and impacting industrial reliability goals. ADR-003 (C Language) reinforces ADR-004 (Native SDK) : The choice of C programming language aligns optimally with the Native Pico SDK approach, enabling direct application of team expertise. ADR-005 (Buffer Strategy) supports ADR-003 (C Language) : Static allocation strategy leverages C&#8217;s deterministic memory model and supports industrial reliability requirements. These interdependencies demonstrate the systemic nature of architectural decisions and highlight areas requiring ongoing technical evaluation. 10. Quality Requirements Content This section contains all quality requirements as quality tree with scenarios. The most important ones have already been described in section 1.2. (quality goals) Here you can also capture quality requirements with lesser priority, which will not create high risks when they are not fully achieved. Motivation Since quality requirements will have a lot of influence on architectural decisions you should know for every stakeholder what is really important to them, concrete and measurable. Further Information See Quality Requirements in the arc42 documentation. 10.1. Quality Tree The quality tree organizes our quality requirements hierarchically, derived from stakeholder expectations and our industrial embedded systems context. Priority levels reflect architectural significance and business impact. Priority Levels: Critical (1) : System failure without this quality - business showstopper High (2) : Essential for reliable operation and long-term maintenance High (3) : Significant impact on user satisfaction and adoption Important (4) : Affects usability, deployment efficiency, and operational monitoring Medium (5) : Enhances user experience and compatibility but system functional without them Desired (6) : Nice-to-have features for future releases and enhanced security Resource and Performance Context: Platform : RP2350 dual-core ARM Cortex-M33 at 150MHz, 520KB SRAM, 4MB Flash Network : ENC28J60 10BASE-T Ethernet controller via SPI Expected Load : Up to 4 concurrent UART channels at combined 500kBaud maximum throughput 10.2. Quality Scenarios 10.2.1. Reliability Requirements (Priority 1 - Critical) Scenario R1: Industrial Continuous Operation Quality Attribute Reliability Context Manufacturing environment with 24/7 operation during normal environmental conditions (temperature, humidity, power within specifications) Stimulus UART2ETH device deployed in production line handling PLC communication Response System maintains continuous operation without software-induced failure Response Measure 99.99% uptime during scheduled production hours (876 hours/year), maximum 0.876 hours downtime annually due to software issues Priority Critical (1) Rationale Manufacturing downtime costs thousands per minute; industrial systems require exceptional reliability for business viability Verification Extended operation testing for 100+ continuous hours with simulated industrial traffic patterns, watchdog timer validation, memory leak detection tools Scenario R2: Hardware Component Failure Recovery Quality Attribute Reliability Context Production deployment with active UART and network connections Stimulus Single hardware component failure (e.g., ENC28J60 controller malfunction) Response System logs error with timestamp and component identifier, maintains UART data buffering, activates error LED with specific blink pattern, continues UART processing while disabling affected network functions Response Measure Failure detection within 100ms, no data corruption in ring buffer, error LED pattern visible, automatic recovery within 2 seconds when component functionality restored Priority Critical (1) Rationale Hardware failures are inevitable; system must handle them gracefully to maintain industrial reliability standards Verification Fault injection testing using SPI line manipulation and network disconnection. Verified with oscilloscope timing measurements and data integrity checksums Scenario R3: Power Cycle Recovery Quality Attribute Reliability Context Industrial environment with occasional power fluctuations or maintenance shutdowns Stimulus Unexpected power loss followed by power restoration Response System restarts cleanly, restores previous configuration, resumes operation without manual intervention Response Measure Full operational restart within 10 seconds, 100% configuration preservation, automatic reconnection from previous TCP clients within 15 seconds Priority Critical (1) Rationale Power interruptions are common in industrial settings; system must resume operation automatically to avoid service calls Scenario R4: Memory Exhaustion Protection Quality Attribute Reliability Context High-throughput operation with all 4 UARTs active at maximum baud rates Stimulus Ring buffer approaches capacity due to traffic burst or consumer processing delays Response System applies drop-oldest policy deterministically, continues operation without crash or memory leak Response Measure No system crash under any traffic conditions, maximum 5% packet loss during extreme bursts (&gt;150% of sustained capacity), recovery to normal operation within 1 second after burst ends Priority Critical (1) Rationale Static memory architecture must handle overload gracefully; crashes are unacceptable in industrial applications Verification Traffic generation testing at 200% rated capacity for 30 minutes, memory usage monitoring, packet loss measurement with statistical analysis 10.2.2. Performance Requirements (Mixed Priority: High/Important) Scenario P1: Real-time Industrial Control Latency Quality Attribute Performance Context PLC communicating time-critical control data to SCADA system via UART2ETH bridge Stimulus PLC sends control command that must reach SCADA system with minimal delay Response Data transmitted through UART‚ÜíRing Buffer‚ÜíTCP path with optimized processing Response Measure End-to-end latency &lt;5ms for 95% of packets under normal load (up to 300kBaud sustained across all channels) Priority High (3) Rationale Industrial control loops require predictable, low latency to maintain process stability and safety Verification Measured using hardware timestamp injection at UART TX and TCP packet capture analysis. Test with 10,000 message sequences under sustained 300kBaud load Scenario P2: Sustained High Throughput Quality Attribute Performance Context Data-intensive application requiring bulk data transfer (e.g., measurement data logging) Stimulus Continuous data stream at maximum specified throughput across multiple UART channels Response System maintains data flow without drops or significant queuing delays Response Measure Sustain 500kBaud combined throughput across all active channels for 8+ hour periods with &lt;0.1% packet loss Priority High (2) Rationale High-volume applications require consistent throughput to avoid data loss and maintain system efficiency Verification Automated throughput testing with UART traffic generators, network packet capture analysis, 24-hour continuous operation validation Scenario P3: Resource Utilization Under Load Quality Attribute Performance Context System operating at 80% of maximum specified capacity across CPU, memory, and network resources Stimulus Normal industrial traffic patterns with occasional bursts Response System maintains responsive operation with efficient resource usage Response Measure CPU utilization &lt;70%, memory usage &lt;80% of available RAM, network buffer utilization &lt;60% during normal operation Priority Important (4) Rationale Efficient resource usage ensures headroom for traffic spikes and maintains system responsiveness Scenario P4: Network Congestion Handling Quality Attribute Performance Context Network infrastructure experiencing intermittent congestion or high latency Stimulus TCP connection experiences delays or temporary packet loss Response System adapts transmission patterns while maintaining UART data flow integrity Response Measure Automatic TCP retry within 50ms, UART data buffering up to 2 seconds during network issues, no UART data loss during network recovery Priority High (2) Rationale Network infrastructure issues are common; system must adapt while protecting serial data integrity 10.2.3. Security Requirements (Mixed Priority: Critical/Important/Desired) Scenario S1: Unauthorized Network Access Prevention Quality Attribute Security Context UART2ETH deployed in production network with potential access from unauthorized devices Stimulus Unauthorized device attempts TCP connection to UART bridge ports (4001-4004) Response System validates connection using IP whitelist and optional TLS client certificate authentication, rejects unauthorized connections with RST packet, logs security events with ISO 8601 timestamp and source details to encrypted flash storage Response Measure 100% of unauthorized connection attempts blocked within 10ms, zero false positives for whitelisted IPs, security events logged with integrity protection, system remains operational during connection flood attacks (up to 1000 attempts/second) Priority Desired (6) Rationale Industrial networks require protection against unauthorized access to prevent data interception and system manipulation Verification OWASP-based penetration testing with unauthorized IP addresses, automated port scanning from external networks, TLS certificate validation testing, connection flood testing with 1000+ concurrent attempts Scenario S2: Firmware Integrity Validation Quality Attribute Security Context OTA firmware update process or system boot sequence with secure boot enabled Stimulus System receives firmware image or boots from flash memory Response System validates cryptographic signature using embedded public key, verifies SHA-256 image hash, implements secure boot chain from RP2350 ROM, validates firmware version to prevent rollback attacks, rejects invalid firmware Response Measure 100% signature validation before execution using, invalid firmware rejected within 500ms, automatic rollback to previous version if post-update health check fails within 15 seconds, firmware version monotonically increasing Priority Critical (1) Rationale Firmware integrity ensures system operates only trusted code, preventing malicious modifications in industrial environments Verification Test with tampered firmware images using invalid signatures, downgrade attack testing with older firmware versions, signature validation timing measurements on RP2350 hardware, secure boot chain validation, rollback procedure validation Scenario S3: Configuration Data Protection Quality Attribute Security Context Device configuration contains network credentials and operational parameters Stimulus Power cycle, configuration backup Response System validates configuration integrity with HMAC-SHA256, keeps 2 copies configuration, uses monotonic revision counter to keep track of latest vaild revision Response Measure Configuration tampering or corruption detected with HMAC-SHA256 validation triggering rollback to latest valid version Priority Critical (1) Rationale Configuration data must not be corrupted Verification Flash memory hexdump analysis to verify HMAC-SHA256 and revision counter, configuration integrity validation after power cycles, forced corruption to verify configuration rollback Scenario S4: Communication Security Quality Attribute Security Context UART data transmitted over TCP connections in potentially untrusted network environments Stimulus Sensitive industrial data (PLC commands, sensor readings) transmitted between UART devices and network clients Response System provides optional TLS 1.3 encryption for TCP connections with industrial-grade cipher suites, maintains data integrity during transmission, implements connection authentication Response Measure TLS 1.3 available for all TCP connections, &lt;10ms additional latency for TLS handshake, 100% data integrity verification using TLS record layer, certificate-based client authentication supported Priority Desired (6) Rationale Industrial data may contain sensitive process information requiring protection during network transmission Verification Network packet capture analysis to verify TLS encryption, latency measurement with TLS enabled/disabled, certificate validation testing, man-in-the-middle attack testing Scenario S5: Security Event Logging and Monitoring Quality Attribute Security Context Industrial environment requiring audit trails and security incident detection Stimulus Security events including authentication failures, unauthorized access attempts, configuration changes, firmware updates Response System logs all security events to encrypted flash storage with tamper-evident integrity protection, provides secure export capability, maintains event timestamps with NTP synchronization Response Measure 100% of events logged with ISO 8601 timestamps, log integrity protected with HMAC-SHA256, encrypted log storage using device-unique keys, log retention for 1000 events, log export via HTTP Web UI Priority Important (4) Rationale Industrial systems require comprehensive audit trails for compliance and security incident investigation Verification Security event generation testing, log integrity validation, encrypted storage verification, timestamp accuracy testing, log export functionality testing 10.2.4. Compatibility Requirements (Mixed Priority: Critical/Medium) Scenario C1: Diverse Industrial Protocol Support Quality Attribute Compatibility Context System integrator deploying UART2ETH with various industrial equipment (PLCs, sensors, measurement devices) Stimulus Configuration requests for non-standard baud rates, unusual frame formats, or custom protocol timing Response System accepts and maintains stable communication with diverse protocol requirements Response Measure Support for baud rates 300-500000, all standard frame formats (5-8 data bits, 1-2 stop bits, none/odd/even parity), stable operation with 99.9% of industrial serial devices Priority Medium (5) Rationale Industrial environments contain diverse legacy equipment; broad compatibility enables market adoption and reduces integration effort Verification Protocol compliance testing with representative industrial devices (PLCs from 3+ vendors, measurement instruments), baud rate accuracy measurement with oscilloscope Scenario C2: Network Infrastructure Integration Quality Attribute Compatibility Context Deployment in existing network infrastructure with various switches, routers, and network management systems Stimulus Connection to different network environments (managed switches, VLANs, different subnet configurations) Response System auto-negotiates network parameters and maintains stable operation Response Measure Successful auto-negotiation with 95% of standard Ethernet infrastructure, stable operation across different network topologies, DHCP and static IP support Priority Critical (1) Rationale Network environments vary significantly between sites; automatic adaptation reduces deployment complexity and support costs Scenario C3: SCADA System Integration Quality Attribute Compatibility Context Integration with existing SCADA/HMI systems from various vendors Stimulus SCADA system establishes TCP connection with specific protocol expectations or timing requirements Response System provides transparent TCP socket interface compatible with SCADA expectations Response Measure Successful integration with 90% of common SCADA systems, transparent protocol forwarding without modification, support for multiple simultaneous connections per UART Priority Medium (5) Rationale SCADA integration is primary use case; broad compatibility ensures market viability and reduces customer integration effort 10.2.5. Usability Requirements (Mixed Priority: Important/Medium) Scenario U1: Field Technician Deployment Quality Attribute Usability Context Field technician with basic networking knowledge deploying device in industrial facility Stimulus Technician needs to configure device for first-time operation Response System provides intuitive configuration interface with clear guidance and validation Response Measure Complete basic configuration (IP settings, UART parameters, port mapping) within 15 minutes by technician with minimal training, configuration errors caught with helpful error messages Priority Important (4) Rationale Simple deployment reduces installation time, training costs, and field support requirements Scenario U2: Troubleshooting and Diagnostics Quality Attribute Usability Context System experiencing communication issues in production environment Stimulus Field technician or system integrator needs to diagnose and resolve connectivity problems Response System provides clear diagnostic information and status indicators Response Measure Problem identification within 5 minutes using web interface diagnostics, LED status indicators visible from 2 meters, error messages identify specific issue and suggest resolution steps Priority Medium (5) Rationale Clear diagnostics reduce troubleshooting time, minimize production downtime, and reduce support costs Scenario U3: Configuration Management Quality Attribute Usability Context System integrator managing multiple UART2ETH devices across different sites Stimulus Need to backup, restore, or replicate device configurations Response System provides configuration export/import functionality with validation Response Measure Complete configuration backup/restore within 2 minutes, configuration file validation with clear error reporting, bulk configuration deployment to multiple devices Priority Medium (5) Rationale Configuration management reduces deployment time for multiple devices and simplifies maintenance procedures 10.2.6. Maintainability Requirements (Mixed Priority: Critical/High/Desired) Scenario M1: Secure Over-the-Air Updates Quality Attribute Maintainability Context Deployed devices requiring firmware update for bug fixes or feature enhancements Stimulus Administrator initiates OTA update from management server Response System securely downloads, validates, and applies firmware update with automatic rollback on failure Response Measure Update completion within 10 minutes, 100% signature validation, automatic rollback within 2 minutes if update fails, zero configuration loss during successful updates Priority High (2) Rationale Field updates are essential for long-term maintenance; secure OTA capability reduces service costs and improves security posture Verification OTA update testing with valid/invalid signatures, network interruption during update, rollback timing measurement, configuration persistence validation Scenario M2: A/B Partition Rollback Quality Attribute Maintainability Context Recently updated device experiencing issues with new firmware version Stimulus Automatic rollback trigger due to system health check failure or manual rollback command Response System switches to previous firmware version and restores operation Response Measure Rollback completion within 30 seconds, 100% restoration of previous functionality, all user configurations preserved during rollback process Priority Critical (1) Rationale Rollback capability ensures update safety and reduces risk of system unavailability due to problematic firmware Scenario M3: Development and Testing Support Quality Attribute Maintainability Context Development team implementing new features or debugging reported issues Stimulus Developer needs to analyze system behavior or verify fix implementation Response System provides comprehensive debugging interfaces and test capabilities Response Measure Debug interface access within 30 seconds, comprehensive logging of system events, test mode operation without affecting production traffic Priority Desired (6) Rationale Development efficiency directly impacts time-to-market and bug resolution speed, affecting overall product quality 10.3. Quality Scenarios Integration 10.3.1. Architectural Decision Impact These quality scenarios directly influence key architectural decisions documented in our ADRs: Hardware Platform Decisions: - Reliability Scenarios R1-R4 ‚Üí ADR-001: RP2350 Selection provides dual-core architecture for fault isolation - Performance Scenarios P1-P2 ‚Üí Static memory allocation strategy eliminates runtime allocation failures Software Architecture Decisions: - Performance Scenarios P1-P4 ‚Üí ADR-003: C Language Selection enables deterministic, real-time behavior - Reliability Scenarios R2-R4 ‚Üí Ring buffer design with drop-oldest policy provides predictable overload behavior Network Architecture Decisions: - Compatibility Scenarios C1-C3 ‚Üí ENC28J60 selection with software TCP/IP stack enables full protocol control and auditability 10.3.2. Testing and Validation Framework Each quality scenario translates directly into test cases: Reliability Testing: - Extended operation testing (1000+ hours) to validate R1 - Fault injection testing for hardware failure scenarios (R2) - Power cycle testing with configuration persistence validation (R3) - Memory stress testing with overload conditions (R4) Performance Testing: - Real-time latency measurement under various loads (P1) - Sustained throughput testing for extended periods (P2) - Resource monitoring during peak operations (P3) - Network resilience testing with simulated congestion (P4) Compatibility Testing: - Protocol compliance testing with diverse industrial equipment (C1) - Network infrastructure compatibility testing (C2) - SCADA system integration testing (C3) Usability Testing: - Field deployment simulation with time measurements (U1) - Diagnostic effectiveness testing with problem scenarios (U2) - Configuration management workflow testing (U3) Maintainability Testing: - OTA update testing with various failure scenarios (M1) - A/B rollback testing with timing and data integrity validation (M2) - Development workflow testing and debugging interface validation (M3) 10.4. Quality Scenario Priority Matrix The following table summarizes all quality scenarios by priority level: Priority Scenario ID Scenario Name Key Metric Critical (1) R1, R2, R3, R4, S2, S3, C2, M2 Industrial Operation, Hardware Failure, Power Recovery, Memory Protection, Firmware Integrity, Configuration Protection, Network Integration, A/B Rollback 99.99% uptime, &lt;100ms failure detection, 100% signature validation, automatic network compatibility High (2) P2, P4, M1 High Throughput, Network Congestion Handling, OTA Updates 500kBaud sustained throughput, &lt;10min OTA updates, network resilience High (3) P1 Real-time Industrial Control Latency &lt;5ms latency for 95% of packets Important (4) P3, S5, U1 Resource Utilization, Security Logging, Field Deployment &lt;70% CPU utilization, comprehensive audit trails, &lt;15min deployment Medium (5) C1, C3, U2, U3 Protocol Support, SCADA Integration, Diagnostics, Configuration Management 99.9% device compatibility, &lt;5min troubleshooting, configuration backup/restore Desired (6) S1, S4, M3 Network Access Control, Communication Security, Development Support TLS 1.3 encryption, unauthorized access blocking, debug interface access 10.5. Quality Requirements Summary The quality scenarios establish measurable success criteria that guide both architectural decisions and validation approaches. Critical scenarios represent non-negotiable requirements where system failure would render the product unsuitable for industrial deployment. High priority scenarios significantly impact user satisfaction and market adoption. Lower priority scenarios enhance user experience and reduce operational costs. 10.6. Security-Industrial Operation Balance Industrial systems require a careful balance between security measures and operational requirements: Security vs. Availability Trade-offs: - Security features (authentication, encryption) must not compromise the 99.99% uptime requirement - TLS encryption adds &lt;10ms latency, acceptable for industrial control loops - Security event logging uses &lt;1% of flash storage, preserving system resources Platform-Specific Security Considerations: - RP2350 hardware security features (secure boot, unique device ID) integrated into security architecture - Lightweight cryptographic algorithms chosen to minimize CPU overhead (&lt;5% utilization) - Static memory allocation prevents security-related memory leaks - Hardware random number generator used for cryptographic operations Fail-Safe Security Principles: - Security failures default to secure state (deny access, maintain logging) - Industrial operation continues during security incidents where possible - Critical security events trigger controlled degradation, not system shutdown - Recovery procedures restore both security and operational functionality These scenarios serve as the foundation for: - Architecture decision evaluation criteria - Test case development and acceptance criteria - Performance benchmarking and validation - Stakeholder communication about quality expectations - Risk assessment and mitigation planning - Security-operational trade-off analysis The concrete, measurable nature of these scenarios enables objective validation and provides clear guidance for architectural trade-offs throughout the development process. 11. Risks and Technical Debts Contents A list of identified technical risks or technical debts, ordered by priority Motivation ‚ÄúRisk management is project management for grown-ups‚Äù (Tim Lister, Atlantic Systems Guild.) This should be your motto for systematic detection and evaluation of risks and technical debts in the architecture, which will be needed by management stakeholders (e.g. project managers, product owners) as part of the overall risk analysis and measurement planning. Form List of risks and/or technical debts, probably including suggested measures to minimize, mitigate or avoid risks or reduce technical debts. Further Information See Risks and Technical Debt in the arc42 documentation. 12. Glossary Contents The most important domain and technical terms that your stakeholders use when discussing the system. You can also see the glossary as source for translations if you work in multi-language teams. Motivation You should clearly define your terms, so that all stakeholders have an identical understanding of these terms do not use synonyms and homonyms Form A table with columns &lt;Term&gt; and &lt;Definition&gt;. Potentially more columns in case you need translations. Further Information See Glossary in the arc42 documentation. Term Definition A/B Updates Dual partition firmware update strategy that maintains two separate flash memory partitions (A and B) containing different firmware versions. During updates, the new firmware is written to the inactive partition while the system continues running from the active partition. If the new firmware fails or becomes corrupted, the system can automatically rollback to the previous working version, ensuring system reliability and preventing brick situations in remote deployments. Arduino Open-source electronics platform consisting of both hardware boards (microcontroller development boards) and software (integrated development environment). Arduino provides a simplified programming framework with pre-built libraries and functions that abstract complex microcontroller operations, making embedded programming accessible to beginners while remaining powerful enough for professional applications. The Arduino ecosystem includes thousands of community-contributed libraries and shields (expansion boards). CI/CD Continuous Integration/Continuous Deployment - modern software development methodology that automates the building, testing, and deployment pipeline. CI automatically builds and tests code changes when developers commit to version control, catching integration issues early. CD extends this by automatically deploying tested code to production environments, reducing manual errors and enabling rapid, reliable software releases. Client System In Gateway Mode, the networked device or application that connects to UART2ETH via TCP sockets to communicate with legacy serial equipment. Client systems can be computers, servers, mobile devices, or other networked equipment that need to access serial devices remotely over Ethernet networks. Examples include monitoring software, configuration tools, or remote control applications. CMake Cross-platform, open-source build system generator that creates native build files (Makefiles, Visual Studio projects, Xcode projects) from platform-independent configuration files. CMake manages complex build dependencies, compiler flags, and linking requirements across different operating systems and compilers, simplifying the build process for C/C++ projects and enabling consistent builds across development teams. ENC28J60 Low-cost Ethernet controller chip from Microchip Technology that provides 10Base-T Ethernet connectivity via SPI interface. This single-chip solution includes MAC (Media Access Control) and PHY (Physical Layer) functions, making it popular for adding basic Ethernet capabilities to microcontroller projects. It requires external TCP/IP stack implementation and offers a cost-effective alternative to more integrated solutions. Full Bridge Mode UART2ETH operating mode that creates a transparent network bridge between two serial devices located at different physical locations. Both devices communicate through their UART interfaces as if they were directly connected with a serial cable, but the connection is actually routed through TCP/IP networks. This mode enables legacy serial equipment to communicate across long distances, through existing network infrastructure, without requiring protocol modifications. Gateway Mode UART2ETH operating mode that adds network connectivity to existing serial-only equipment without modifying the original device. The UART2ETH device acts as a protocol gateway, translating between the legacy device&#8217;s serial communication and modern TCP/IP networking. This allows multiple network clients to simultaneously access serial equipment, enabling remote monitoring, configuration, and control of industrial equipment, embedded systems, or test instruments. Host System The serial equipment or device connected to UART2ETH&#8217;s physical UART interface. In Gateway Mode, this is typically legacy industrial equipment, embedded systems, or test instruments that only support serial communication. In Full Bridge Mode, both endpoints are considered Host Systems. Host Systems are unaware of the network translation and continue using their native serial protocols. HW UART Hardware Universal Asynchronous Receiver-Transmitter - dedicated silicon circuitry within microcontrollers that handles serial communication at the hardware level. HW UARTs provide precise timing, automatic start/stop bit handling, parity checking, and interrupt generation without CPU intervention. This contrasts with software-based UART implementations that consume CPU cycles and may have timing limitations, especially at higher baud rates. Misra-c Motor Industry Software Reliability Association C - comprehensive coding standard that defines strict guidelines for writing safety-critical C code. MISRA-C rules cover language subset restrictions, coding practices, and documentation requirements designed to eliminate common programming errors, undefined behaviors, and implementation-defined constructs. Originally developed for automotive software, it&#8217;s now widely used in aerospace, medical devices, and industrial control systems. OTA (Over-The-Air) Remote firmware update mechanism that allows devices to receive and install new firmware through their existing communication channels (WiFi, Ethernet, cellular) without requiring physical access. OTA updates enable field devices to receive bug fixes, security patches, and feature updates remotely, reducing maintenance costs and enabling rapid deployment of improvements across device fleets. Critical for IoT devices in remote or inaccessible locations. PIO Programmable Input/Output - specialized hardware feature of the Raspberry Pi RP2350 microcontroller that provides highly flexible, real-time I/O processing independent of the main CPU cores. PIO consists of state machines that can execute custom assembly-like programs to handle precise timing requirements for protocols like WS2812 LEDs, custom serial formats, or parallel interfaces. Each PIO block can run multiple state machines simultaneously, enabling complex I/O operations without CPU intervention. PLC (Programmable Logic Controller) Industrial computer designed for automation of manufacturing processes, machinery control, and industrial monitoring systems. PLCs are ruggedized for harsh industrial environments and provide real-time control with deterministic response times. They typically use ladder logic programming and offer extensive I/O capabilities for sensors, actuators, and communication networks. Common in factory automation, process control, and building management systems. platformio Modern, open-source ecosystem for embedded and IoT development that provides unified tooling across multiple microcontroller platforms, frameworks, and boards. PlatformIO includes cross-platform IDE, library manager, unit testing framework, remote debugging capabilities, and continuous integration support. It abstracts away toolchain complexity while supporting hundreds of development boards and frameworks including Arduino, ESP-IDF, STM32, and many others. Protocol Filter Pluggable software component within UART2ETH that intelligently processes and optimizes serial data streams before TCP transmission. Protocol filters can implement packet framing, data compression, error correction, or protocol-specific optimizations to reduce network bandwidth, improve latency, or enhance reliability. Examples include buffering strategies for bulk data transfers, real-time filtering for control systems, or custom packet structures for specific industrial protocols. RPI RP2350 Second-generation microcontroller chip from Raspberry Pi Foundation featuring dual ARM Cortex-M33 cores running up to 150MHz, 520KB SRAM, advanced security features, and flexible I/O capabilities including PIO state machines. The RP2350 provides enhanced performance and security compared to the original RP2040, making it suitable for industrial applications requiring real-time processing, secure communications, and complex I/O handling. SCADA (Supervisory Control and Data Acquisition) Industrial control system architecture used for monitoring and controlling large-scale processes across multiple locations. SCADA systems collect data from remote sensors and equipment, provide centralized monitoring through human-machine interfaces (HMIs), and enable operators to control distributed processes. Common in utilities (power grids, water treatment), manufacturing, and transportation systems where real-time monitoring and control of geographically dispersed equipment is essential. SPI Ethernet Controller Ethernet controller chip that communicates with microcontrollers through the Serial Peripheral Interface (SPI) protocol rather than parallel buses. These controllers handle the complex Ethernet physical layer operations (signal encoding, collision detection, carrier sensing) while presenting a simple SPI interface to the host microcontroller. This approach reduces pin count requirements and simplifies PCB design while providing reliable network connectivity for embedded systems. SPI TCP/IP Controller Integrated circuit that implements the complete TCP/IP protocol stack in hardware and communicates with host microcontrollers via SPI interface. These chips handle all network protocol processing (IP, TCP, UDP, ARP, DHCP) independently, presenting socket-based APIs through SPI commands. This offloads complex network processing from the main microcontroller, simplifying firmware development and improving real-time performance for applications requiring both networking and real-time control. TCP Socket Network communication endpoint that provides reliable, ordered, and error-checked delivery of data streams between applications over IP networks. TCP sockets establish connections, handle flow control, retransmission of lost packets, and ensure data integrity through checksums and acknowledgments. Unlike UDP, TCP guarantees that data arrives in the correct order and without errors, making it essential for applications requiring reliable data transmission such as file transfers, web browsing, and industrial control protocols. UART (Universal Asynchronous Receiver-Transmitter) Serial communication protocol and hardware interface that transmits data character by character without requiring a shared clock signal between communicating devices. UART uses start and stop bits to frame each character, with configurable data bits (5-9), parity (none, even, odd), and stop bits (1, 1.5, 2). This asynchronous approach makes UART simple to implement and widely compatible, leading to its extensive use in embedded systems, industrial equipment, and debugging interfaces. UART2ETH Complete hardware and firmware solution that bridges between UART serial interfaces and TCP/IP Ethernet networks, supporting up to 4 simultaneous UART connections. The system provides bidirectional data translation, protocol filtering, secure OTA updates, and flexible operating modes (Gateway and Full Bridge) to enable legacy serial equipment integration with modern networks. Built on the RPI RP2350 platform with support for various Ethernet controller options. W5500 Fully integrated Ethernet controller from WIZnet that combines 10/100 Ethernet MAC, PHY, and a complete TCP/IP protocol stack in a single chip. The W5500 communicates with host microcontrollers via SPI and provides hardware-accelerated socket operations, automatic packet processing, and wake-on-LAN capabilities. Its integrated approach simplifies network integration for embedded systems by handling all low-level networking operations transparently, allowing developers to focus on application logic rather than network protocols. "
},

{
    "id": 6,
    "uri": "arc42/src/08_concepts.html",
    "menu": "arc42",
    "title": "Cross-cutting Concepts",
    "text": " Table of Contents Cross-cutting Concepts &lt;Concept 1&gt; &lt;Concept 2&gt; &lt;Concept n&gt; Cross-cutting Concepts &lt;Concept 1&gt; &lt;explanation&gt; &lt;Concept 2&gt; &lt;explanation&gt; &#8230;&#8203; &lt;Concept n&gt; &lt;explanation&gt; "
},

{
    "id": 7,
    "uri": "arc42/src/03_context_and_scope.html",
    "menu": "arc42",
    "title": "Context and Scope",
    "text": " Table of Contents Context and Scope System Overview System Scope and Boundaries Business Context Technical Context Operating Mode Contexts Integration Architecture Future State Considerations Context and Scope System Overview UART2ETH operates as a networking bridge that enables legacy industrial equipment with UART interfaces to communicate over TCP/IP networks. The system serves as a critical integration point in industrial automation environments, supporting two distinct operating modes: Gateway Mode : UART2ETH adds networking capabilities to existing Host Systems without requiring firmware modifications. The Host System maintains its original UART-based communication while Client Systems access it via TCP sockets over the network. Full Bridge Mode : UART2ETH provides transparent UART-over-TCP connectivity, allowing two Host Systems with UART interfaces to communicate over network infrastructure as if they were directly connected via serial cable. System Scope and Boundaries Inside the System Boundary: RP2350 microcontroller Up to 4 UART interfaces Network interface controller (100Mbit Ethernet) Protocol filtering and optimization engines OTA update mechanism with A/B partitioning Device configuration and management interfaces Outside the System Boundary: Host Systems (PLCs, sensors, measurement instruments) Client Systems (SCADA systems, monitoring applications) Network infrastructure (switches, routers, firewalls) Firmware update servers and management systems Business Context Primary Stakeholders Stakeholder Role Primary Business Interactions Industrial Engineers Solution designers and specifiers Define networking requirements for automation projects, specify UART2ETH configurations for integrating legacy equipment into modern networks System Integrators Implementation specialists Deploy UART2ETH devices in customer facilities, configure networking parameters, integrate with existing SCADA and monitoring systems Field Technicians Installation and maintenance personnel Physical installation of devices, diagnostic troubleshooting, basic configuration changes, routine maintenance procedures Equipment Manufacturers Original equipment makers Embed UART2ETH into products to add networking capabilities, specify custom protocol filters, integrate with product lifecycle management Business Use Cases Legacy Equipment Integration: Industrial Engineers specify UART2ETH to network aging PLCs, sensors, and measurement instruments that lack modern connectivity. System Integrators deploy these solutions to extend equipment lifecycles and enable remote monitoring without costly equipment replacement. Infrastructure Problem Solving: Field installations requiring long cable runs or operating in electrically noisy environments use UART2ETH to overcome serial communication limitations through network-based transmission. Remote Access Enablement: SCADA systems and monitoring applications access distributed serial devices through UART2ETH bridges, enabling centralized control and data collection across geographically dispersed facilities. Technical Context Technical Interface Specifications Interface Type Technical Details Communication Pattern UART Ports (4x) Host System Interface UART/RS232/RS422, 300-500k baud, configurable parameters Bidirectional serial, protocol-agnostic Ethernet Port Network Interface 100BASE-TX, RJ45 connector, Auto-MDIX TCP/IP networking, DHCP/Static IP TCP Sockets Client Interface Ports configurable, single connection per port TCP client connections, application protocols Management Interface Configuration Interface Web UI (HTTP), configuration interface HTTP, JSON configuration OTA Update Interface Firmware Interface Secure update server, A/B partition management HTTP, signed firmware images Communication Protocols and Data Formats UART Communication: Raw serial data transmission (protocol-agnostic) Configurable baud rates: 300 bps to 500 kbps Support for custom frame formats and timing requirements Network Communication: TCP socket connections for data transmission JSON for configuration and management data Binary protocol passthrough with optional filtering HTTP for management and OTA updates Network Protocols: IPv4 with DHCP or static configuration NTP for time synchronization DNS for name resolution Operating Mode Contexts Gateway Mode Context Gateway Mode Data Flow: 1. Host System sends serial data using original protocol to UART2ETH 2. UART2ETH receives serial data and applies protocol filtering/optimization 3. Processed data is transmitted to Client Systems via TCP sockets 4. Client Systems send responses back through TCP connections 5. UART2ETH forwards responses to Host System via UART interface Full Bridge Mode Context Full Bridge Mode Data Flow: 1. Host System A sends serial data to UART2ETH A 2. UART2ETH A encapsulates serial data in TCP packets and transmits over network 3. UART2ETH B receives TCP packets and extracts original serial data 4. UART2ETH B forwards serial data to Host System B via UART 5. Bidirectional communication maintains transparent serial connection Integration Architecture Critical Dependencies Network Infrastructure Dependencies: Reliable Ethernet connectivity for TCP/IP communication Network switches with appropriate bandwidth and latency characteristics DHCP services for automatic IP configuration (or static IP management) Network time synchronization for accurate timestamping Power and Environmental Dependencies: 3.3V-24V power supply within industrial specifications Operating temperature range suitable for industrial environments Protection from electromagnetic interference in industrial settings Security Dependencies: Network firewall configuration to allow necessary TCP ports Firmware signing infrastructure for secure OTA updates Network segmentation appropriate for industrial security requirements Security and Compliance Boundaries Network Security: Cryptographic signatures for firmware validation and integrity Configurable TCP port ranges to support firewall policies Input validation and sanitization for all network interfaces Industrial Compliance: CE certification for European industrial markets Electromagnetic compatibility (EMC) for industrial environments Component sourcing from Western suppliers for regulatory compliance Audit trail for firmware updates and configuration changes Performance and Scalability Characteristics Performance Requirements: 500 kbps sustained throughput per UART port Sub-5ms end-to-end latency for real-time applications Concurrent TCP connections (one per UART port) Configurable buffering for latency vs. throughput optimization Scalability Considerations: Up to 4 simultaneous UART-to-TCP bridges per device Network deployment limited by IP address availability and network bandwidth Protocol filtering reduces network traffic for efficient bulk transfers A/B firmware updates enable fleet-wide updates without service interruption Future State Considerations Planned Integrations Enhanced Protocol Support: Additional protocol filters for common industrial protocols (Modbus, DNP3, IEC 61850) HTTPS/TLS on-the-wire encryption Advanced Management Features: Integration with network management systems (SNMP, NETCONF) Enhanced diagnostic and monitoring capabilities "
},

{
    "id": 8,
    "uri": "arc42/src/09_architecture_decisions.html",
    "menu": "arc42",
    "title": "Architecture Decisions",
    "text": " Table of Contents Architecture Decisions Hardware Platform Decisions Software Platform Decisions Implementation Strategy Decisions Decision Interdependencies Architecture Decisions This section references the Architecture Decision Records (ADRs) that document key technical decisions for the UART2ETH project. These decisions form the foundation of the system architecture and significantly influence capabilities, performance characteristics, and development approach. Hardware Platform Decisions ADR-001: Microcontroller Platform Selection - Documents the decision to use the Raspberry Pi RP2350 as the core microcontroller platform. ADR-002: Ethernet Controller Selection - Documents the decision to use the ENC28J60 as the Ethernet controller. Software Platform Decisions ADR-003: Programming Language Selection - Documents the decision to use C programming language for firmware development, considering team expertise, delivery timeline, and memory model constraints. ADR-004: Development Ecosystem Selection - Documents the decision to use Native Pico SDK + CMake development ecosystem for professional, industrial-grade development. Implementation Strategy Decisions ADR-005: Ring Buffer Memory Allocation Strategy - Documents the decision to use static worst-case allocation for inter-core communication buffers, prioritizing reliability and determinism over memory efficiency. Decision Interdependencies The ADRs reveal important interdependencies that influence architectural coherence: ADR-004 (Development Ecosystem) challenges ADR-002 (Ethernet Controller) : The ecosystem analysis revealed that ENC28J60 lacks mature RP2350 SDK integration, potentially requiring significant custom development effort and impacting industrial reliability goals. ADR-003 (C Language) reinforces ADR-004 (Native SDK) : The choice of C programming language aligns optimally with the Native Pico SDK approach, enabling direct application of team expertise. ADR-005 (Buffer Strategy) supports ADR-003 (C Language) : Static allocation strategy leverages C&#8217;s deterministic memory model and supports industrial reliability requirements. These interdependencies demonstrate the systemic nature of architectural decisions and highlight areas requiring ongoing technical evaluation. "
},

{
    "id": 9,
    "uri": "arc42/src/06_runtime_view.html",
    "menu": "arc42",
    "title": "Runtime View",
    "text": " Table of Contents Runtime View &lt;Runtime Scenario 1&gt; &lt;Runtime Scenario 2&gt; &#8230;&#8203; &lt;Runtime Scenario n&gt; Runtime View &lt;Runtime Scenario 1&gt; &lt;insert runtime diagram or textual description of the scenario&gt; &lt;insert description of the notable aspects of the interactions between the building block instances depicted in this diagram.&gt; &lt;Runtime Scenario 2&gt; &#8230;&#8203; &lt;Runtime Scenario n&gt; "
},

{
    "id": 10,
    "uri": "arc42/src/01_introduction_and_goals.html",
    "menu": "arc42",
    "title": "Introduction and Goals",
    "text": " Table of Contents Introduction and Goals Requirements Overview Quality Goals Stakeholders Introduction and Goals Requirements Overview Purpose UART2ETH provides a hardware and firmware solution for bridging UART interfaces to TCP sockets, enabling network connectivity for legacy industrial equipment and embedded systems. Core Functional Requirements Hardware Capabilities: Support up to 4 independent UART interfaces 100Mbit network interface with RJ45 connector Networking Features: Each UART exposed as individual TCP socket on dedicated port Raw TCP socket communication for transparent data transmission Support for concurrent connections (1 TCP connection per UART) Operating Modes: Full Bridge Mode: Transparent UART-over-TCP for remote device connections Gateway Mode: Add networking capabilities to existing products without firmware modifications Firmware Management: Secure Over-The-Air (OTA) firmware updates A/B update mechanism for rollback capability Protocol Optimization: Custom pluggable serial protocol filters for efficient TCP packaging Configurable packet caching with ring buffer implementation Adjustable transmit timeouts for latency or bulk transfer optimization Target Use Cases Use Case Description Legacy Equipment Integration Connect PLCs, sensors, and measurement instruments to SCADA systems via network Infrastructure Problem Solving Overcome noise and cable length limitations in industrial environments System Integration Add networking to existing products without custom development effort Remote Device Access Enable distant connections to serial devices through Full Bridge mode Driving Forces Regulatory Compliance: Western-only component supply chain for regulatory compliance Anticipation of new regulations requiring updateable and auditable firmware CE certification requirement for hardware Market Requirements: Address gap left by discontinued commercial UART-to-TCP solutions Provide open source alternative to expensive or black-box commercial products Enable cost-effective networking solutions for system integrators Substantial per-unit cost savings when deploying multiple units in-house compared to commercial alternatives Technical Requirements: 500kBaud sustained throughput capability Sub-5ms latency for real-time applications Critical system uptime within environmental specifications Quality Goals The following quality goals are prioritized by importance to our major stakeholders (industrial engineers and system integrators): Priority Quality Goal Concrete Scenario 1 Reliability Critical system uptime for industrial applications A UART2ETH device deployed in a manufacturing line must maintain continuous operation for the duration that the connected hardware operates within environmental specifications. System failure should not occur due to software issues during normal operation. 2 Performance Real-time data transmission capabilities The system must sustain 500kBaud throughput with less than 5ms latency end-to-end. A PLC sending time-critical control data to a SCADA system must not experience delays that could affect industrial process control. 3 Compatibility Seamless integration with diverse industrial systems The system must work reliably with a broad range of custom baud rates and protocol parameters. It should reliably auto-negotiate ethernet connection parameters. 4 Usability Simple deployment without specialized knowledge A system integrator with basic understanding of serial communication and TCP/IP should be able to deploy and configure the device without extensive training. Configuration should be straightforward with clear error messages for common misconfigurations. 5 Maintainability Secure field updates without physical access Firmware updates must be deployable remotely via OTA mechanism with A/B rollback capability. A device installed in a remote location must be updatable without requiring on-site technician visits, while ensuring update integrity and system recovery from failed updates. Stakeholders Role/Name Contact Expectations Industrial Engineers End user organizations, manufacturing facilities Clear documentation of network integration capabilities, performance specifications, and compatibility with existing industrial equipment. Need confidence in reliability and uptime guarantees. System Integrators Engineering consultancies, automation solution providers Comprehensive deployment guides, configuration documentation, and troubleshooting procedures. Expect regulatory compliance documentation (CE certification) and clear cost-benefit analysis. Development Team Internal project contributors Detailed architectural decisions, coding standards, build procedures, and testing frameworks. Need clear module interfaces and dependencies for parallel development work. Hardware Engineers PCB designers, component selection specialists Hardware interface specifications, power requirements, environmental constraints, and component selection rationale. Need mechanical and electrical interface documentation. Field Technicians Installation and maintenance personnel Simple installation procedures, diagnostic capabilities, and field troubleshooting guides. Need clear error indicators and recovery procedures for common failure modes. Regulatory Authorities CE certification bodies, industrial standards organizations Compliance documentation, safety analysis, electromagnetic compatibility evidence, and audit trails for component sourcing and manufacturing processes. Open Source Community Contributors, adopters, derivative projects Clear licensing terms (GPL), contribution guidelines, architectural documentation enabling modifications and extensions. Expect maintainable and well-documented code structure. "
},

{
    "id": 11,
    "uri": "arc42/src/11_technical_risks.html",
    "menu": "arc42",
    "title": "Risks and Technical Debts",
    "text": " Table of Contents Risks and Technical Debts Risks and Technical Debts "
},

{
    "id": 12,
    "uri": "arc42/src/12_glossary.html",
    "menu": "arc42",
    "title": "Glossary",
    "text": " Table of Contents Glossary Glossary Term Definition A/B Updates Dual partition firmware update strategy that maintains two separate flash memory partitions (A and B) containing different firmware versions. During updates, the new firmware is written to the inactive partition while the system continues running from the active partition. If the new firmware fails or becomes corrupted, the system can automatically rollback to the previous working version, ensuring system reliability and preventing brick situations in remote deployments. Arduino Open-source electronics platform consisting of both hardware boards (microcontroller development boards) and software (integrated development environment). Arduino provides a simplified programming framework with pre-built libraries and functions that abstract complex microcontroller operations, making embedded programming accessible to beginners while remaining powerful enough for professional applications. The Arduino ecosystem includes thousands of community-contributed libraries and shields (expansion boards). CI/CD Continuous Integration/Continuous Deployment - modern software development methodology that automates the building, testing, and deployment pipeline. CI automatically builds and tests code changes when developers commit to version control, catching integration issues early. CD extends this by automatically deploying tested code to production environments, reducing manual errors and enabling rapid, reliable software releases. Client System In Gateway Mode, the networked device or application that connects to UART2ETH via TCP sockets to communicate with legacy serial equipment. Client systems can be computers, servers, mobile devices, or other networked equipment that need to access serial devices remotely over Ethernet networks. Examples include monitoring software, configuration tools, or remote control applications. CMake Cross-platform, open-source build system generator that creates native build files (Makefiles, Visual Studio projects, Xcode projects) from platform-independent configuration files. CMake manages complex build dependencies, compiler flags, and linking requirements across different operating systems and compilers, simplifying the build process for C/C++ projects and enabling consistent builds across development teams. ENC28J60 Low-cost Ethernet controller chip from Microchip Technology that provides 10Base-T Ethernet connectivity via SPI interface. This single-chip solution includes MAC (Media Access Control) and PHY (Physical Layer) functions, making it popular for adding basic Ethernet capabilities to microcontroller projects. It requires external TCP/IP stack implementation and offers a cost-effective alternative to more integrated solutions. Full Bridge Mode UART2ETH operating mode that creates a transparent network bridge between two serial devices located at different physical locations. Both devices communicate through their UART interfaces as if they were directly connected with a serial cable, but the connection is actually routed through TCP/IP networks. This mode enables legacy serial equipment to communicate across long distances, through existing network infrastructure, without requiring protocol modifications. Gateway Mode UART2ETH operating mode that adds network connectivity to existing serial-only equipment without modifying the original device. The UART2ETH device acts as a protocol gateway, translating between the legacy device&#8217;s serial communication and modern TCP/IP networking. This allows multiple network clients to simultaneously access serial equipment, enabling remote monitoring, configuration, and control of industrial equipment, embedded systems, or test instruments. Host System The serial equipment or device connected to UART2ETH&#8217;s physical UART interface. In Gateway Mode, this is typically legacy industrial equipment, embedded systems, or test instruments that only support serial communication. In Full Bridge Mode, both endpoints are considered Host Systems. Host Systems are unaware of the network translation and continue using their native serial protocols. HW UART Hardware Universal Asynchronous Receiver-Transmitter - dedicated silicon circuitry within microcontrollers that handles serial communication at the hardware level. HW UARTs provide precise timing, automatic start/stop bit handling, parity checking, and interrupt generation without CPU intervention. This contrasts with software-based UART implementations that consume CPU cycles and may have timing limitations, especially at higher baud rates. Misra-c Motor Industry Software Reliability Association C - comprehensive coding standard that defines strict guidelines for writing safety-critical C code. MISRA-C rules cover language subset restrictions, coding practices, and documentation requirements designed to eliminate common programming errors, undefined behaviors, and implementation-defined constructs. Originally developed for automotive software, it&#8217;s now widely used in aerospace, medical devices, and industrial control systems. OTA (Over-The-Air) Remote firmware update mechanism that allows devices to receive and install new firmware through their existing communication channels (WiFi, Ethernet, cellular) without requiring physical access. OTA updates enable field devices to receive bug fixes, security patches, and feature updates remotely, reducing maintenance costs and enabling rapid deployment of improvements across device fleets. Critical for IoT devices in remote or inaccessible locations. PIO Programmable Input/Output - specialized hardware feature of the Raspberry Pi RP2350 microcontroller that provides highly flexible, real-time I/O processing independent of the main CPU cores. PIO consists of state machines that can execute custom assembly-like programs to handle precise timing requirements for protocols like WS2812 LEDs, custom serial formats, or parallel interfaces. Each PIO block can run multiple state machines simultaneously, enabling complex I/O operations without CPU intervention. PLC (Programmable Logic Controller) Industrial computer designed for automation of manufacturing processes, machinery control, and industrial monitoring systems. PLCs are ruggedized for harsh industrial environments and provide real-time control with deterministic response times. They typically use ladder logic programming and offer extensive I/O capabilities for sensors, actuators, and communication networks. Common in factory automation, process control, and building management systems. platformio Modern, open-source ecosystem for embedded and IoT development that provides unified tooling across multiple microcontroller platforms, frameworks, and boards. PlatformIO includes cross-platform IDE, library manager, unit testing framework, remote debugging capabilities, and continuous integration support. It abstracts away toolchain complexity while supporting hundreds of development boards and frameworks including Arduino, ESP-IDF, STM32, and many others. Protocol Filter Pluggable software component within UART2ETH that intelligently processes and optimizes serial data streams before TCP transmission. Protocol filters can implement packet framing, data compression, error correction, or protocol-specific optimizations to reduce network bandwidth, improve latency, or enhance reliability. Examples include buffering strategies for bulk data transfers, real-time filtering for control systems, or custom packet structures for specific industrial protocols. RPI RP2350 Second-generation microcontroller chip from Raspberry Pi Foundation featuring dual ARM Cortex-M33 cores running up to 150MHz, 520KB SRAM, advanced security features, and flexible I/O capabilities including PIO state machines. The RP2350 provides enhanced performance and security compared to the original RP2040, making it suitable for industrial applications requiring real-time processing, secure communications, and complex I/O handling. SCADA (Supervisory Control and Data Acquisition) Industrial control system architecture used for monitoring and controlling large-scale processes across multiple locations. SCADA systems collect data from remote sensors and equipment, provide centralized monitoring through human-machine interfaces (HMIs), and enable operators to control distributed processes. Common in utilities (power grids, water treatment), manufacturing, and transportation systems where real-time monitoring and control of geographically dispersed equipment is essential. SPI Ethernet Controller Ethernet controller chip that communicates with microcontrollers through the Serial Peripheral Interface (SPI) protocol rather than parallel buses. These controllers handle the complex Ethernet physical layer operations (signal encoding, collision detection, carrier sensing) while presenting a simple SPI interface to the host microcontroller. This approach reduces pin count requirements and simplifies PCB design while providing reliable network connectivity for embedded systems. SPI TCP/IP Controller Integrated circuit that implements the complete TCP/IP protocol stack in hardware and communicates with host microcontrollers via SPI interface. These chips handle all network protocol processing (IP, TCP, UDP, ARP, DHCP) independently, presenting socket-based APIs through SPI commands. This offloads complex network processing from the main microcontroller, simplifying firmware development and improving real-time performance for applications requiring both networking and real-time control. TCP Socket Network communication endpoint that provides reliable, ordered, and error-checked delivery of data streams between applications over IP networks. TCP sockets establish connections, handle flow control, retransmission of lost packets, and ensure data integrity through checksums and acknowledgments. Unlike UDP, TCP guarantees that data arrives in the correct order and without errors, making it essential for applications requiring reliable data transmission such as file transfers, web browsing, and industrial control protocols. UART (Universal Asynchronous Receiver-Transmitter) Serial communication protocol and hardware interface that transmits data character by character without requiring a shared clock signal between communicating devices. UART uses start and stop bits to frame each character, with configurable data bits (5-9), parity (none, even, odd), and stop bits (1, 1.5, 2). This asynchronous approach makes UART simple to implement and widely compatible, leading to its extensive use in embedded systems, industrial equipment, and debugging interfaces. UART2ETH Complete hardware and firmware solution that bridges between UART serial interfaces and TCP/IP Ethernet networks, supporting up to 4 simultaneous UART connections. The system provides bidirectional data translation, protocol filtering, secure OTA updates, and flexible operating modes (Gateway and Full Bridge) to enable legacy serial equipment integration with modern networks. Built on the RPI RP2350 platform with support for various Ethernet controller options. W5500 Fully integrated Ethernet controller from WIZnet that combines 10/100 Ethernet MAC, PHY, and a complete TCP/IP protocol stack in a single chip. The W5500 communicates with host microcontrollers via SPI and provides hardware-accelerated socket operations, automatic packet processing, and wake-on-LAN capabilities. Its integrated approach simplifies network integration for embedded systems by handling all low-level networking operations transparently, allowing developers to focus on application logic rather than network protocols. "
},

{
    "id": 13,
    "uri": "arc42/src/05_building_block_view.html",
    "menu": "arc42",
    "title": "Building Block View",
    "text": " Table of Contents Building Block View Whitebox Overall System Level 2 Level 3 Building Block View Whitebox Overall System The UART2ETH system follows a dual-core separation strategy that provides fault isolation while achieving hardware-driven performance. The system is decomposed into five major building blocks that each handle distinct responsibilities in the UART-to-TCP bridge functionality. Motivation The dual-core separation strategy from our solution approach drives this decomposition to achieve: Fault isolation : Each core has distinct responsibilities to prevent cascading failures Performance optimization : Hardware-driven I/O with software control for real-time requirements Industrial reliability : Predictable behavior through static allocation and deterministic interfaces Bidirectional communication : Both UART and TCP interfaces require full-duplex operation Contained Building Blocks Name Responsibility Core 0 UART Subsystem Manages all 4 UART interfaces with interrupt/DMA handling. Performs bidirectional stream-to-packet conversion for communication with the ring buffer system. Core 1 Network Subsystem Implements TCP/IP stack and Ethernet controller interface with interrupt/DMA handling. Copies packets from and to the network stack and manages TCP socket connections. Ring Buffer Communication Provides bidirectional inter-core data transfer using a shared memory pool with cache-aligned, mutex-protected buffers. Handles dynamic burst allocation by being channel and driection agnostic. Management Interface Offers web-based configuration, monitoring, and administration through HTTP server with authentication, statistics collection, and configuration UIs. OTA Update System Manages secure firmware updates with A/B partition management, signature validation, and automatic rollback capabilities. Important Interfaces Ring Buffer Interface Shared Pool Design : Single buffer pool serves both directions dynamically Core 0 : Producer (UART RX) + Consumer (UART TX) using shared pool Core 1 : Producer (TCP RX) + Consumer (TCP TX) using shared pool Entry Format : Fixed 1088-byte entries (64-byte header + 1024-byte payload) Synchronization : Mutex-protected operations for shared pool access Overflow Policy : Drop-oldest across entire pool (direction-agnostic) Network Interface External : 10BASE-T Ethernet, RJ45 connector (ENC28J60 limitation) Internal : SPI to ENC28J60 controller, software TCP/IP stack (lwIP) UART Interface Hardware : 4 independent UART channels with configurable parameters Protocols : UART/RS232/RS422 support with 300-500kBaud range Configuration : Per-channel baud rate, data bits, stop bits, parity settings Level 2 Whitebox Core 0 UART Subsystem The Core 0 UART Subsystem specializes in handling all UART communication with dedicated hardware management, interrupt processing, and bidirectional data conversion between stream and packet formats. Motivation Core 0 specialization enables real-time UART processing without interference from network operations. The bidirectional packet conversion allows seamless translation between continuous UART streams and discrete network packets. Contained Building Blocks Name Responsibility UART Hardware Manager Direct control of 4 UART channels with configurable parameters (baud rate, data bits, parity). Manages hardware registers and status monitoring. Interrupt Handler Processes time-critical UART events (RX data available, TX buffer empty) with minimal latency for real-time performance. DMA Controller Optimizes bulk data transfers in both directions to reduce CPU load and improve throughput for high-baud applications. Packet Assembler Converts incoming UART streams into fixed-size packets for ring buffer storage. Handles framing and timestamp metadata. Packet Disassembler Extracts UART data from ring buffer packets and converts back to continuous streams for transmission. Ring Buffer Interface Provides producer operations (UART RX data) and consumer operations (UART TX data) with proper synchronization. Whitebox Core 1 Network Subsystem The Core 1 Network Subsystem manages all network communication including TCP/IP protocol processing, Ethernet controller interface, and bidirectional packet routing between ring buffer and network clients. Motivation Core 1 specialization allows network processing to operate independently from time-critical UART operations. The modular design enables efficient TCP/IP processing while maintaining clear separation between hardware drivers and application logic. Contained Building Blocks Name Responsibility lwIP TCP/IP Stack Complete software-based TCP/IP implementation providing standard network protocols and socket interfaces. ENC28J60 Driver Low-level SPI driver for the 10BASE-T Ethernet controller, handling frame transmission and reception. Socket Manager Manages TCP socket connections with one dedicated socket per UART channel. Handles connection lifecycle and error recovery. Packet Router Maps UART channel numbers to TCP port numbers and routes data bidirectionally between network and ring buffer interfaces. Packet Assembler Converts incoming TCP data streams into ring buffer packets for transmission to Core 0. Packet Disassembler Extracts data from ring buffer packets and formats for TCP transmission to network clients. Ring Buffer Interface Provides producer operations (TCP RX data) and consumer operations (TCP TX data) with shared pool access. Whitebox Ring Buffer Communication System The Ring Buffer Communication System provides the critical inter-core communication mechanism using a shared memory pool that dynamically handles bursts from either direction while maintaining deterministic behavior. Motivation The shared buffer pool design provides elegant burst handling by allowing dynamic allocation to whichever direction needs capacity. This approach is more efficient than fixed per-direction pools and gracefully handles real-world traffic patterns. Contained Building Blocks Name Responsibility Shared Buffer Pool Single memory pool that dynamically serves both UART‚ÜíTCP and TCP‚ÜíUART directions with fixed-size entries. Mutex Manager Provides thread-safe access to the shared pool using FreeRTOS mutexes and semaphores for inter-core synchronization. Memory Manager Handles allocation and deallocation of fixed-size buffer entries with cache-aligned addressing for optimal performance. Overflow Handler Implements drop-oldest policy when buffer reaches capacity, ensuring deterministic behavior under overload conditions. Statistics Collector Tracks buffer utilization, message counts, throughput metrics, and error conditions for monitoring and diagnostics. Whitebox Management Interface The Management Interface provides comprehensive web-based administration through modular components handling authentication, configuration, and monitoring functions. Motivation The modular management interface design separates concerns between web serving, authentication, data collection, and configuration UIs. This enables independent development and testing of each component while providing a comprehensive administration solution. Contained Building Blocks Name Responsibility HTTP Web Server Processes HTTP/1.1 requests, serves static content (HTML/CSS/JS), provides REST API endpoints, and manages user sessions. Authentication System Handles user login validation, JWT session token management, role-based access control, and security header implementation. Statistical Data Module Collects real-time metrics from system components, maintains historical data, tracks performance counters, and monitors system health. UART Configuration UI Provides web interface for configuring UART channel settings, hardware control options, protocol filters, and parameter validation. TCP/IP Configuration UI Offers web interface for network settings, TCP port mapping, connection limits, and security configurations. Level 3 Whitebox Core 0 UART Handler Subsystem The Core 0 UART Subsystem specializes in handling all UART communication with dedicated hardware management, interrupt processing, and bidirectional data conversion between stream and packet formats. Motivation UART processing utilizing UART specific ISR and DMA transfers for maximum troughput. Contained Building Blocks Name Responsibility UART Hardware Manager Direct control of 4 UART channels with configurable parameters (baud rate, data bits, parity). Manages hardware registers and status monitoring. Interrupt Handler Processes time-critical UART events (RX data available, TX buffer empty) with minimal latency for real-time performance. DMA Controller Controls bulk data transfers in both directions DMA Channel Optimizes bulk data transfers in both directions to reduce CPU load and improve throughput for high-baud applications. Packet Assembler Converts incoming UART streams into fixed-size packets for ring buffer storage. Handles framing and timestamp metadata. Packet Disassembler Extracts UART data from ring buffer packets and converts back to continuous streams for transmission. Ring Buffer Interface Provides producer operations (UART RX data) and consumer operations (UART TX data) with proper synchronization. Whitebox Ring Buffer System Internal Structure The Ring Buffer System provides the foundational inter-core communication with detailed memory management, helper functions, and synchronization primitives. Purpose Provides efficient, thread-safe, bidirectional communication between cores with deterministic behavior and comprehensive monitoring capabilities. Internal Structure Memory Layout Manager Manages the physical organization of the ring buffer in memory with cache-aligned addressing and efficient index calculations. Ring Buffer Array : Contiguous memory block with cache-aligned entries Index Management : Head/tail pointers with wrap-around logic Memory Addressing : Base address + (index √ó entry_size) calculations Buffer Management Functions Core API providing the helper functions for ring buffer operations and monitoring. // Core buffer operations ring_entry_t* find_next_free_block(void); ring_entry_t* find_next_ready_block(uint8_t uart_channel, uint8_t direction); bool is_buffer_full(void); bool is_buffer_empty(void); // Statistics and monitoring uint32_t get_cached_message_count(void); uint32_t get_cached_message_count_by_channel(uint8_t uart_channel); uint32_t get_cached_message_count_by_direction(uint8_t direction); uint32_t get_free_block_count(void); uint32_t get_overflow_count(void); // Dropped messages uint32_t get_total_throughput_bytes(void); // Advanced operations ring_entry_t* peek_next_block(uint8_t uart_channel, uint8_t direction); void mark_block_ready(ring_entry_t* entry); void mark_block_consumed(ring_entry_t* entry); void reset_buffer_statistics(void); Memory Layout Structure Complete ring buffer system data structure with metadata, statistics, and synchronization primitives. typedef struct { // Ring buffer metadata (cache-aligned) volatile uint32_t head_index; // Producer index volatile uint32_t tail_index; // Consumer index volatile uint32_t entry_count; // Current entries uint32_t max_entries; // Buffer capacity // Statistics (cache-aligned) uint32_t total_produced; uint32_t total_consumed; uint32_t overflow_count; uint32_t underflow_count; // Synchronization mutex_t buffer_mutex; semaphore_t free_space_sem; semaphore_t data_ready_sem; // Entry array (cache-aligned) ring_entry_t entries[]; } ring_buffer_system_t; Data Entry Format Individual ring buffer entry structure used for both communication directions. typedef struct { // Management Data (16 bytes) uint8_t uart_channel; // 0-3 uint8_t direction; // RX_UART_TO_TCP / RX_TCP_TO_UART uint8_t status; // FILLING/DRAINING/FULL/EMPTY uint8_t payload_length; // Actual data length uint32_t timestamp; // Fill timestamp uint32_t sequence_id; // For ordering/debugging uint32_t next_in_use; // Packets in use (within ring buffer) are a single linked list uint32_t reserved; // Future use/alignment // Payload Data (1024 bytes max) uint8_t payload[1024]; // Fixed max size for worst case } ring_entry_t; Whitebox UART Hardware Manager Internal Structure The UART Hardware Manager provides unified control over all 4 UART channels with individual controllers, parameter management, and comprehensive status monitoring. Purpose Provides unified interface to all 4 UART channels with configurable parameters, comprehensive status monitoring, and efficient interrupt handling. Internal Structure UART Configuration Interface Complete configuration structure for UART channel parameters. typedef struct { uint32_t baud_rate; // 300-500000 bps uint8_t data_bits; // 5-8 bits uint8_t stop_bits; // 1-2 bits uint8_t parity; // NONE/ODD/EVEN bool flow_control; // Hardware flow control bool rs485_mode; // RS485 half-duplex mode } uart_config_t; UART Operations API Core function interface for UART channel operations. // Channel operations int uart_channel_configure(uint8_t channel, uart_config_t* config); int uart_channel_read(uint8_t channel, uint8_t* buffer, size_t length); int uart_channel_write(uint8_t channel, const uint8_t* data, size_t length); bool uart_channel_is_ready(uint8_t channel); uint32_t uart_channel_get_status(uint8_t channel); Status Monitoring Structure Comprehensive status tracking for each UART channel. typedef struct { bool carrier_detect; bool clear_to_send; bool data_set_ready; uint32_t rx_errors; uint32_t tx_errors; uint32_t frames_received; uint32_t frames_transmitted; } uart_channel_status_t; Whitebox Management Interface Internal Structure The Management Interface provides comprehensive web-based administration through specialized components for HTTP serving, authentication, statistics, and configuration management. Purpose Provides comprehensive web-based configuration, monitoring, and administration interface with modular components for different management aspects. Internal Structure HTTP Web Server Components Request Handler typedef struct { uint16_t port; // Default: 80 uint32_t max_connections; // Concurrent sessions char document_root[256]; // Static content path } webserver_config_t; int webserver_start(webserver_config_t* config); int webserver_register_endpoint(const char* path, http_handler_t handler); int webserver_send_response(int client_fd, http_response_t* response); Authentication System Components User Management typedef enum { AUTH_ROLE_ADMIN, // Full configuration access AUTH_ROLE_OPERATOR, // Monitor + basic config AUTH_ROLE_READONLY // Monitor only } auth_role_t; typedef struct { char username[32]; char password_hash[64]; // SHA-256 hash auth_role_t role; bool enabled; } user_account_t; bool authenticate_user(const char* username, const char* password); const char* create_session_token(const char* username); bool validate_session_token(const char* token); Statistical Data Components System Statistics Structure typedef struct { // Per-channel statistics struct { uint64_t bytes_transmitted; uint64_t bytes_received; uint32_t messages_transmitted; uint32_t messages_received; uint32_t error_count; uint32_t overflow_count; float average_latency_ms; uint32_t current_baud_rate; } uart_stats[4]; // Network statistics uint64_t tcp_bytes_sent; uint64_t tcp_bytes_received; uint32_t tcp_connections_active; uint32_t tcp_connections_total; // System statistics uint32_t uptime_seconds; uint32_t cpu_usage_percent; uint32_t memory_used_bytes; uint32_t ring_buffer_utilization_percent; } system_statistics_t; Configuration Interface Components UART Configuration Structure typedef struct { bool enabled; uart_config_t config; // From UART Hardware Manager char description[64]; // User-friendly name bool protocol_filter_enabled; char protocol_filter_type[32]; // \"SharkNet\", \"custom\", etc. } uart_channel_settings_t; Network Configuration Structure typedef struct { // Network configuration bool use_dhcp; char ip_address[16]; // \"192.168.1.100\" char subnet_mask[16]; // \"255.255.255.0\" char gateway[16]; // \"192.168.1.1\" char dns_primary[16]; char dns_secondary[16]; // Port mapping struct { uint16_t tcp_port; // 4001-4004 default bool enabled; uint32_t connection_timeout_ms; char allowed_clients[256]; // IP ranges: \"192.168.1.0/24\" } port_config[4]; // Security bool enable_firewall; char hostname[64]; uint16_t management_port; // Web UI port (default 80) } network_config_t; "
},

{
    "id": 14,
    "uri": "arc42/src/00_architecture_communication_canvas.html",
    "menu": "arc42",
    "title": "Architecture Communication Canvas",
    "text": " Table of Contents Architecture Communication Canvas .canvas ul { margin-left: 0px; padding-left: 1em; list-style: square; } .canvas tr:nth-child(1) td:nth-child(1), .canvas tr:nth-child(1) td:nth-child(2), .canvas tr:nth-child(2) td:nth-child(1), .canvas tr:nth-child(3) td:nth-child(1), .canvas tr:nth-child(4) td:nth-child(1) { background-color: #8fe4b4; border: 1px solid black; } .canvas tr:nth-child(1) td:nth-child(3), .canvas tr:nth-child(1) td:nth-child(4), .canvas tr:nth-child(4) td:nth-child(2) { background-color: #94d7ef; border: 1px solid black; } .canvas tr:nth-child(5) td:nth-child(1), .canvas tr:nth-child(5) td:nth-child(2) { background-color: #ffc7c6; border: 1px solid black; } Architecture Communication Canvas Designed for: UART2ETH Designed by: Development Team Value Proposition Provide a low-cost, open source, western-component based, regulatory-compliant alternative to expensive or black-box UART-to-TCP bridge solutions for adding networking capabilities to legacy equipment. Core Functions Full Bridge mode: Transparent UART over TCP for distant device connections Gateway mode: Add networking capabilities to products without development Up to 4 UARTs exposed as TCP sockets on individual ports Secure OTA firmware updates with A/B update mechanism Custom pluggable serial protocol filters for efficient TCP packaging Package caching with custom transmit timeouts for latency/bulk optimization Core Decisions - Good or Bad Good: RP2350 selection for open ecosystem, long-term support, and secure update capabilities Moving from ATMega328 due to baudrate inflexibility and security limitations Western-only component supply chain for regulatory compliance Bad: No major problematic decisions identified yet Strategic: Anticipating new regulations requiring updateable and auditable firmware Addressing gap left by discontinued commercial solutions Technologies Programming: C/C++ with Arduino framework Development: VSCodium IDE, PlatformIO build system Hardware: RP2350 microcontroller, ENC28J60 SPI Ethernet controller Protocols: Raw TCP sockets, HTTP for WebUI Security: RP2350 Boot ROM provided security mechanisms Infrastructure: GitHub runners for CI/CD Documentation: docToolchain with AsciiDoc Key Stakeholder Industrial engineers dealing with infrastructure challenges (noise, cable length issues) requiring networking solutions for existing equipment System integrators needing regulatory-compliant, ready-to-use networking solutions for their products without custom development Quality Requirements Performance: 500kBaud sustained throughput, &lt;5ms latency Reliability: Critical uptime as long as hardware operates within environmental specifications Security: Prevention of data distortion and lateral network movement attacks Usability: Users need basic understanding of serial communication and TCP/IP Scalability: 1 TCP connection per UART port Compliance: CE certification for hardware Business Context Data Sources: Legacy PLCs, sensors, measurement instruments, and older industrial equipment with serial interfaces but no networking capabilities Data Sinks: SCADA systems, custom data processing software, other UART2ETH devices (in Full Bridge mode) Network Environment: Industrial and household LANs operating at 100Mbit Dependencies: Only requires correctly routed network infrastructure No risky external interfaces or operational costs Components / Modules Hardware Components: * RP2350 microcontroller * Microchip ENC28J60 SPI Ethernet Controller * RJ45 connector with integrated magnetics * Crystal clock source * SPI EEPROM for firmware storage Software Modules: * TCP/IP communication module * UART instance modules (up to 4) * OTA update manager with A/B update support * Protocol filtering/packet splitting engine * Caching module with flexible ring buffer * Configuration management module * Optional WebUI module * PIO-based UART implementation (send/receive tasks on GPIO) Core Risks Primary security risk: Device compromise allowing data distortion or use as attack vector for lateral network movement Hardware component availability and supply chain disruptions Regulatory changes requiring additional compliance measures Performance degradation under high concurrent load scenarios Missing Information Testing framework selection not yet decided Specific cryptographic implementation details for OTA security WebUI design and user experience specifications Detailed protocol filter plugin architecture Performance benchmarking under various network conditions Industrial certification requirements beyond CE marking Software Architecture Canvas by Gernot Starke, Patrick Roos and arc42 Contributors is licensed under Attribution-ShareAlike 4.0 International "
},

{
    "id": 15,
    "uri": "arc42/src/10_quality_requirements.html",
    "menu": "arc42",
    "title": "Quality Requirements",
    "text": " Table of Contents Quality Requirements Quality Tree Quality Scenarios Quality Scenarios Integration Quality Scenario Priority Matrix Quality Requirements Summary Security-Industrial Operation Balance Quality Requirements Quality Tree The quality tree organizes our quality requirements hierarchically, derived from stakeholder expectations and our industrial embedded systems context. Priority levels reflect architectural significance and business impact. Priority Levels: Critical (1) : System failure without this quality - business showstopper High (2) : Essential for reliable operation and long-term maintenance High (3) : Significant impact on user satisfaction and adoption Important (4) : Affects usability, deployment efficiency, and operational monitoring Medium (5) : Enhances user experience and compatibility but system functional without them Desired (6) : Nice-to-have features for future releases and enhanced security Resource and Performance Context: Platform : RP2350 dual-core ARM Cortex-M33 at 150MHz, 520KB SRAM, 4MB Flash Network : ENC28J60 10BASE-T Ethernet controller via SPI Expected Load : Up to 4 concurrent UART channels at combined 500kBaud maximum throughput Quality Scenarios Reliability Requirements (Priority 1 - Critical) Scenario R1: Industrial Continuous Operation Quality Attribute Reliability Context Manufacturing environment with 24/7 operation during normal environmental conditions (temperature, humidity, power within specifications) Stimulus UART2ETH device deployed in production line handling PLC communication Response System maintains continuous operation without software-induced failure Response Measure 99.99% uptime during scheduled production hours (876 hours/year), maximum 0.876 hours downtime annually due to software issues Priority Critical (1) Rationale Manufacturing downtime costs thousands per minute; industrial systems require exceptional reliability for business viability Verification Extended operation testing for 100+ continuous hours with simulated industrial traffic patterns, watchdog timer validation, memory leak detection tools Scenario R2: Hardware Component Failure Recovery Quality Attribute Reliability Context Production deployment with active UART and network connections Stimulus Single hardware component failure (e.g., ENC28J60 controller malfunction) Response System logs error with timestamp and component identifier, maintains UART data buffering, activates error LED with specific blink pattern, continues UART processing while disabling affected network functions Response Measure Failure detection within 100ms, no data corruption in ring buffer, error LED pattern visible, automatic recovery within 2 seconds when component functionality restored Priority Critical (1) Rationale Hardware failures are inevitable; system must handle them gracefully to maintain industrial reliability standards Verification Fault injection testing using SPI line manipulation and network disconnection. Verified with oscilloscope timing measurements and data integrity checksums Scenario R3: Power Cycle Recovery Quality Attribute Reliability Context Industrial environment with occasional power fluctuations or maintenance shutdowns Stimulus Unexpected power loss followed by power restoration Response System restarts cleanly, restores previous configuration, resumes operation without manual intervention Response Measure Full operational restart within 10 seconds, 100% configuration preservation, automatic reconnection from previous TCP clients within 15 seconds Priority Critical (1) Rationale Power interruptions are common in industrial settings; system must resume operation automatically to avoid service calls Scenario R4: Memory Exhaustion Protection Quality Attribute Reliability Context High-throughput operation with all 4 UARTs active at maximum baud rates Stimulus Ring buffer approaches capacity due to traffic burst or consumer processing delays Response System applies drop-oldest policy deterministically, continues operation without crash or memory leak Response Measure No system crash under any traffic conditions, maximum 5% packet loss during extreme bursts (&gt;150% of sustained capacity), recovery to normal operation within 1 second after burst ends Priority Critical (1) Rationale Static memory architecture must handle overload gracefully; crashes are unacceptable in industrial applications Verification Traffic generation testing at 200% rated capacity for 30 minutes, memory usage monitoring, packet loss measurement with statistical analysis Performance Requirements (Mixed Priority: High/Important) Scenario P1: Real-time Industrial Control Latency Quality Attribute Performance Context PLC communicating time-critical control data to SCADA system via UART2ETH bridge Stimulus PLC sends control command that must reach SCADA system with minimal delay Response Data transmitted through UART‚ÜíRing Buffer‚ÜíTCP path with optimized processing Response Measure End-to-end latency &lt;5ms for 95% of packets under normal load (up to 300kBaud sustained across all channels) Priority High (3) Rationale Industrial control loops require predictable, low latency to maintain process stability and safety Verification Measured using hardware timestamp injection at UART TX and TCP packet capture analysis. Test with 10,000 message sequences under sustained 300kBaud load Scenario P2: Sustained High Throughput Quality Attribute Performance Context Data-intensive application requiring bulk data transfer (e.g., measurement data logging) Stimulus Continuous data stream at maximum specified throughput across multiple UART channels Response System maintains data flow without drops or significant queuing delays Response Measure Sustain 500kBaud combined throughput across all active channels for 8+ hour periods with &lt;0.1% packet loss Priority High (2) Rationale High-volume applications require consistent throughput to avoid data loss and maintain system efficiency Verification Automated throughput testing with UART traffic generators, network packet capture analysis, 24-hour continuous operation validation Scenario P3: Resource Utilization Under Load Quality Attribute Performance Context System operating at 80% of maximum specified capacity across CPU, memory, and network resources Stimulus Normal industrial traffic patterns with occasional bursts Response System maintains responsive operation with efficient resource usage Response Measure CPU utilization &lt;70%, memory usage &lt;80% of available RAM, network buffer utilization &lt;60% during normal operation Priority Important (4) Rationale Efficient resource usage ensures headroom for traffic spikes and maintains system responsiveness Scenario P4: Network Congestion Handling Quality Attribute Performance Context Network infrastructure experiencing intermittent congestion or high latency Stimulus TCP connection experiences delays or temporary packet loss Response System adapts transmission patterns while maintaining UART data flow integrity Response Measure Automatic TCP retry within 50ms, UART data buffering up to 2 seconds during network issues, no UART data loss during network recovery Priority High (2) Rationale Network infrastructure issues are common; system must adapt while protecting serial data integrity Security Requirements (Mixed Priority: Critical/Important/Desired) Scenario S1: Unauthorized Network Access Prevention Quality Attribute Security Context UART2ETH deployed in production network with potential access from unauthorized devices Stimulus Unauthorized device attempts TCP connection to UART bridge ports (4001-4004) Response System validates connection using IP whitelist and optional TLS client certificate authentication, rejects unauthorized connections with RST packet, logs security events with ISO 8601 timestamp and source details to encrypted flash storage Response Measure 100% of unauthorized connection attempts blocked within 10ms, zero false positives for whitelisted IPs, security events logged with integrity protection, system remains operational during connection flood attacks (up to 1000 attempts/second) Priority Desired (6) Rationale Industrial networks require protection against unauthorized access to prevent data interception and system manipulation Verification OWASP-based penetration testing with unauthorized IP addresses, automated port scanning from external networks, TLS certificate validation testing, connection flood testing with 1000+ concurrent attempts Scenario S2: Firmware Integrity Validation Quality Attribute Security Context OTA firmware update process or system boot sequence with secure boot enabled Stimulus System receives firmware image or boots from flash memory Response System validates cryptographic signature using embedded public key, verifies SHA-256 image hash, implements secure boot chain from RP2350 ROM, validates firmware version to prevent rollback attacks, rejects invalid firmware Response Measure 100% signature validation before execution using, invalid firmware rejected within 500ms, automatic rollback to previous version if post-update health check fails within 15 seconds, firmware version monotonically increasing Priority Critical (1) Rationale Firmware integrity ensures system operates only trusted code, preventing malicious modifications in industrial environments Verification Test with tampered firmware images using invalid signatures, downgrade attack testing with older firmware versions, signature validation timing measurements on RP2350 hardware, secure boot chain validation, rollback procedure validation Scenario S3: Configuration Data Protection Quality Attribute Security Context Device configuration contains network credentials and operational parameters Stimulus Power cycle, configuration backup Response System validates configuration integrity with HMAC-SHA256, keeps 2 copies configuration, uses monotonic revision counter to keep track of latest vaild revision Response Measure Configuration tampering or corruption detected with HMAC-SHA256 validation triggering rollback to latest valid version Priority Critical (1) Rationale Configuration data must not be corrupted Verification Flash memory hexdump analysis to verify HMAC-SHA256 and revision counter, configuration integrity validation after power cycles, forced corruption to verify configuration rollback Scenario S4: Communication Security Quality Attribute Security Context UART data transmitted over TCP connections in potentially untrusted network environments Stimulus Sensitive industrial data (PLC commands, sensor readings) transmitted between UART devices and network clients Response System provides optional TLS 1.3 encryption for TCP connections with industrial-grade cipher suites, maintains data integrity during transmission, implements connection authentication Response Measure TLS 1.3 available for all TCP connections, &lt;10ms additional latency for TLS handshake, 100% data integrity verification using TLS record layer, certificate-based client authentication supported Priority Desired (6) Rationale Industrial data may contain sensitive process information requiring protection during network transmission Verification Network packet capture analysis to verify TLS encryption, latency measurement with TLS enabled/disabled, certificate validation testing, man-in-the-middle attack testing Scenario S5: Security Event Logging and Monitoring Quality Attribute Security Context Industrial environment requiring audit trails and security incident detection Stimulus Security events including authentication failures, unauthorized access attempts, configuration changes, firmware updates Response System logs all security events to encrypted flash storage with tamper-evident integrity protection, provides secure export capability, maintains event timestamps with NTP synchronization Response Measure 100% of events logged with ISO 8601 timestamps, log integrity protected with HMAC-SHA256, encrypted log storage using device-unique keys, log retention for 1000 events, log export via HTTP Web UI Priority Important (4) Rationale Industrial systems require comprehensive audit trails for compliance and security incident investigation Verification Security event generation testing, log integrity validation, encrypted storage verification, timestamp accuracy testing, log export functionality testing Compatibility Requirements (Mixed Priority: Critical/Medium) Scenario C1: Diverse Industrial Protocol Support Quality Attribute Compatibility Context System integrator deploying UART2ETH with various industrial equipment (PLCs, sensors, measurement devices) Stimulus Configuration requests for non-standard baud rates, unusual frame formats, or custom protocol timing Response System accepts and maintains stable communication with diverse protocol requirements Response Measure Support for baud rates 300-500000, all standard frame formats (5-8 data bits, 1-2 stop bits, none/odd/even parity), stable operation with 99.9% of industrial serial devices Priority Medium (5) Rationale Industrial environments contain diverse legacy equipment; broad compatibility enables market adoption and reduces integration effort Verification Protocol compliance testing with representative industrial devices (PLCs from 3+ vendors, measurement instruments), baud rate accuracy measurement with oscilloscope Scenario C2: Network Infrastructure Integration Quality Attribute Compatibility Context Deployment in existing network infrastructure with various switches, routers, and network management systems Stimulus Connection to different network environments (managed switches, VLANs, different subnet configurations) Response System auto-negotiates network parameters and maintains stable operation Response Measure Successful auto-negotiation with 95% of standard Ethernet infrastructure, stable operation across different network topologies, DHCP and static IP support Priority Critical (1) Rationale Network environments vary significantly between sites; automatic adaptation reduces deployment complexity and support costs Scenario C3: SCADA System Integration Quality Attribute Compatibility Context Integration with existing SCADA/HMI systems from various vendors Stimulus SCADA system establishes TCP connection with specific protocol expectations or timing requirements Response System provides transparent TCP socket interface compatible with SCADA expectations Response Measure Successful integration with 90% of common SCADA systems, transparent protocol forwarding without modification, support for multiple simultaneous connections per UART Priority Medium (5) Rationale SCADA integration is primary use case; broad compatibility ensures market viability and reduces customer integration effort Usability Requirements (Mixed Priority: Important/Medium) Scenario U1: Field Technician Deployment Quality Attribute Usability Context Field technician with basic networking knowledge deploying device in industrial facility Stimulus Technician needs to configure device for first-time operation Response System provides intuitive configuration interface with clear guidance and validation Response Measure Complete basic configuration (IP settings, UART parameters, port mapping) within 15 minutes by technician with minimal training, configuration errors caught with helpful error messages Priority Important (4) Rationale Simple deployment reduces installation time, training costs, and field support requirements Scenario U2: Troubleshooting and Diagnostics Quality Attribute Usability Context System experiencing communication issues in production environment Stimulus Field technician or system integrator needs to diagnose and resolve connectivity problems Response System provides clear diagnostic information and status indicators Response Measure Problem identification within 5 minutes using web interface diagnostics, LED status indicators visible from 2 meters, error messages identify specific issue and suggest resolution steps Priority Medium (5) Rationale Clear diagnostics reduce troubleshooting time, minimize production downtime, and reduce support costs Scenario U3: Configuration Management Quality Attribute Usability Context System integrator managing multiple UART2ETH devices across different sites Stimulus Need to backup, restore, or replicate device configurations Response System provides configuration export/import functionality with validation Response Measure Complete configuration backup/restore within 2 minutes, configuration file validation with clear error reporting, bulk configuration deployment to multiple devices Priority Medium (5) Rationale Configuration management reduces deployment time for multiple devices and simplifies maintenance procedures Maintainability Requirements (Mixed Priority: Critical/High/Desired) Scenario M1: Secure Over-the-Air Updates Quality Attribute Maintainability Context Deployed devices requiring firmware update for bug fixes or feature enhancements Stimulus Administrator initiates OTA update from management server Response System securely downloads, validates, and applies firmware update with automatic rollback on failure Response Measure Update completion within 10 minutes, 100% signature validation, automatic rollback within 2 minutes if update fails, zero configuration loss during successful updates Priority High (2) Rationale Field updates are essential for long-term maintenance; secure OTA capability reduces service costs and improves security posture Verification OTA update testing with valid/invalid signatures, network interruption during update, rollback timing measurement, configuration persistence validation Scenario M2: A/B Partition Rollback Quality Attribute Maintainability Context Recently updated device experiencing issues with new firmware version Stimulus Automatic rollback trigger due to system health check failure or manual rollback command Response System switches to previous firmware version and restores operation Response Measure Rollback completion within 30 seconds, 100% restoration of previous functionality, all user configurations preserved during rollback process Priority Critical (1) Rationale Rollback capability ensures update safety and reduces risk of system unavailability due to problematic firmware Scenario M3: Development and Testing Support Quality Attribute Maintainability Context Development team implementing new features or debugging reported issues Stimulus Developer needs to analyze system behavior or verify fix implementation Response System provides comprehensive debugging interfaces and test capabilities Response Measure Debug interface access within 30 seconds, comprehensive logging of system events, test mode operation without affecting production traffic Priority Desired (6) Rationale Development efficiency directly impacts time-to-market and bug resolution speed, affecting overall product quality Quality Scenarios Integration Architectural Decision Impact These quality scenarios directly influence key architectural decisions documented in our ADRs: Hardware Platform Decisions: - Reliability Scenarios R1-R4 ‚Üí ADR-001: RP2350 Selection provides dual-core architecture for fault isolation - Performance Scenarios P1-P2 ‚Üí Static memory allocation strategy eliminates runtime allocation failures Software Architecture Decisions: - Performance Scenarios P1-P4 ‚Üí ADR-003: C Language Selection enables deterministic, real-time behavior - Reliability Scenarios R2-R4 ‚Üí Ring buffer design with drop-oldest policy provides predictable overload behavior Network Architecture Decisions: - Compatibility Scenarios C1-C3 ‚Üí ENC28J60 selection with software TCP/IP stack enables full protocol control and auditability Testing and Validation Framework Each quality scenario translates directly into test cases: Reliability Testing: - Extended operation testing (1000+ hours) to validate R1 - Fault injection testing for hardware failure scenarios (R2) - Power cycle testing with configuration persistence validation (R3) - Memory stress testing with overload conditions (R4) Performance Testing: - Real-time latency measurement under various loads (P1) - Sustained throughput testing for extended periods (P2) - Resource monitoring during peak operations (P3) - Network resilience testing with simulated congestion (P4) Compatibility Testing: - Protocol compliance testing with diverse industrial equipment (C1) - Network infrastructure compatibility testing (C2) - SCADA system integration testing (C3) Usability Testing: - Field deployment simulation with time measurements (U1) - Diagnostic effectiveness testing with problem scenarios (U2) - Configuration management workflow testing (U3) Maintainability Testing: - OTA update testing with various failure scenarios (M1) - A/B rollback testing with timing and data integrity validation (M2) - Development workflow testing and debugging interface validation (M3) Quality Scenario Priority Matrix The following table summarizes all quality scenarios by priority level: Priority Scenario ID Scenario Name Key Metric Critical (1) R1, R2, R3, R4, S2, S3, C2, M2 Industrial Operation, Hardware Failure, Power Recovery, Memory Protection, Firmware Integrity, Configuration Protection, Network Integration, A/B Rollback 99.99% uptime, &lt;100ms failure detection, 100% signature validation, automatic network compatibility High (2) P2, P4, M1 High Throughput, Network Congestion Handling, OTA Updates 500kBaud sustained throughput, &lt;10min OTA updates, network resilience High (3) P1 Real-time Industrial Control Latency &lt;5ms latency for 95% of packets Important (4) P3, S5, U1 Resource Utilization, Security Logging, Field Deployment &lt;70% CPU utilization, comprehensive audit trails, &lt;15min deployment Medium (5) C1, C3, U2, U3 Protocol Support, SCADA Integration, Diagnostics, Configuration Management 99.9% device compatibility, &lt;5min troubleshooting, configuration backup/restore Desired (6) S1, S4, M3 Network Access Control, Communication Security, Development Support TLS 1.3 encryption, unauthorized access blocking, debug interface access Quality Requirements Summary The quality scenarios establish measurable success criteria that guide both architectural decisions and validation approaches. Critical scenarios represent non-negotiable requirements where system failure would render the product unsuitable for industrial deployment. High priority scenarios significantly impact user satisfaction and market adoption. Lower priority scenarios enhance user experience and reduce operational costs. Security-Industrial Operation Balance Industrial systems require a careful balance between security measures and operational requirements: Security vs. Availability Trade-offs: - Security features (authentication, encryption) must not compromise the 99.99% uptime requirement - TLS encryption adds &lt;10ms latency, acceptable for industrial control loops - Security event logging uses &lt;1% of flash storage, preserving system resources Platform-Specific Security Considerations: - RP2350 hardware security features (secure boot, unique device ID) integrated into security architecture - Lightweight cryptographic algorithms chosen to minimize CPU overhead (&lt;5% utilization) - Static memory allocation prevents security-related memory leaks - Hardware random number generator used for cryptographic operations Fail-Safe Security Principles: - Security failures default to secure state (deny access, maintain logging) - Industrial operation continues during security incidents where possible - Critical security events trigger controlled degradation, not system shutdown - Recovery procedures restore both security and operational functionality These scenarios serve as the foundation for: - Architecture decision evaluation criteria - Test case development and acceptance criteria - Performance benchmarking and validation - Stakeholder communication about quality expectations - Risk assessment and mitigation planning - Security-operational trade-off analysis The concrete, measurable nature of these scenarios enables objective validation and provides clear guidance for architectural trade-offs throughout the development process. "
},

{
    "id": 16,
    "uri": "arc42/src/07_deployment_view.html",
    "menu": "arc42",
    "title": "Deployment View",
    "text": " Table of Contents Deployment View System Context Operational Requirements Summary Deployment Environments Firmware Deployment Architecture Infrastructure Components Deployment Strategies Operational Procedures Configuration Management Deployment View System Context The UART2ETH system is an embedded hardware solution based on the RPI RP2350 microcontroller that bridges UART interfaces to TCP sockets. The deployment view focuses on the firmware deployment pipeline, from development through QA validation to field deployment via Over-The-Air (OTA) updates. Operational Requirements Summary Requirement Type Target Description Availability Zero-downtime updates A/B partition switching maintains device operation until manual reboot Security Signed firmware delivery Cryptographic signing, secure boot, initial key embedding at factory Reliability Automatic rollback Watchdog-based rollback mechanism for failed firmware updates Auditability Version tracking Git tags and commit checksums embedded in firmware builds Control Manual operations No remote device reboots, QA gatekeeping for all releases Deployment Environments Environment Overview Environment Specifications Environment Purpose Hardware Deployment Method Development Feature development and local testing Individual RP2350 devices per developer Direct flash programming QA Testing Release validation with real hardware Single testbench with RP2350 hardware Automated test deployment Production Live firmware distribution Customer-deployed field devices OTA HTTP downloads Factory Initial device provisioning Manufacturing test fixtures Flash programming + key embedding Firmware Deployment Architecture High-Level Architecture A/B Partition Strategy Infrastructure Components Build and Release Infrastructure Component Technology &amp; Configuration Purpose &amp; Responsibilities CMake Build System Pico SDK integration, firmware signing Compile source code, embed version info, sign binaries Developer Hardware Individual RP2350 devices Local development and unit testing QA Testbench Single automated test fixture with RP2350 Hardware-in-the-loop validation of release candidates Cloud OTA Server HTTP-based firmware distribution Serve approved firmware to field devices Key Management Secure cryptographic key storage Firmware signing keys, device authentication Security Architecture Security Layer Implementation Factory Key Embedding Cryptographic keys installed during initial manufacturing flash Firmware Signing All firmware builds cryptographically signed before distribution Secure Boot RP2350 ROM bootloader verifies firmware signatures before execution OTA Authentication Device authenticates with OTA server before firmware download Partition Verification Each partition validated before boot attempt Deployment Strategies Firmware Update Process Stage Process Validation &amp; Control Development Build CMake compilation with embedded version tags Local developer testing on real hardware QA Validation Automated testbench execution Hardware-in-the-loop testing, manual approval gate Production Release QA promotes approved firmware to OTA server Single gatekeeper model, full traceability Field Deployment Device pulls firmware via HTTP when configured Manual reboot required, automatic rollback protection A/B Partition Management Operational Procedures Version Management and Auditability Aspect Implementation Benefits Version Identification Git tags and commit checksums embedded in firmware Precise traceability of deployed firmware versions Build Reproducibility Deterministic build process with version tagging Ability to rebuild exact firmware for debugging Release Documentation QA approval records linked to firmware versions Clear audit trail for all production releases Field Identification Device reports firmware version via management interface Support teams can identify deployed firmware versions Rollback and Recovery Procedures Scenario Recovery Method Implementation Boot Failure Automatic rollback via watchdog timeout RP2350 ROM bootloader switches to backup partition Corrupted Download Signature verification failure Device rejects invalid firmware, retains current version Network Issues Download retry mechanism Device continues with current firmware, retries later Total Firmware Corruption Device replacement No field recovery possible when both partitions corrupted Monitoring and Maintenance Monitoring Aspect Implementation Firmware Version Tracking Git checksums embedded in firmware, reported via management UI Update Success Rate Device reports successful updates to management interface Rollback Events Watchdog rollback events logged in device memory OTA Server Health HTTP availability monitoring for firmware distribution Configuration Management OTA Server Configuration The UART2ETH device supports flexible OTA server configuration: Default Server : Company-hosted cloud OTA server for standard deployments Customer Servers : Configurable OTA server URL via management interface HTTP Protocol : Simple HTTP-based firmware downloads (no HTTPS requirement) Pull-based Updates : Devices initiate update checks, no push capability "
},

{
    "id": 17,
    "uri": "arc42/src/04_solution_strategy.html",
    "menu": "arc42",
    "title": "Solution Strategy",
    "text": " Table of Contents Solution Strategy Quality Goals Foundation Architectural Drivers Architecture Significant Requirements (ASRs) Solution Approach Overview Technology Strategy Decomposition Strategy Quality Achievement Strategy Strategic Decisions and Trade-offs Implementation Strategy Risk Assessment and Mitigation Architecture Evolution Strategy Conclusion Solution Strategy Quality Goals Foundation Primary Quality Goals Quality Goal Priority Description &amp; Success Criteria Reliability 1 (Primary Driver) Critical system uptime for industrial applications. Must not fail due to software issues during normal operation within environmental specifications. Compatibility 2 (Secondary Driver) Seamless integration with diverse industrial systems. Support broad range of custom baud rates and protocol parameters with reliable auto-negotiation. Performance 3 (Supporting Driver) 500kBaud sustained throughput with sub-5ms end-to-end latency. Real-time data transmission capabilities for industrial process control. Quality Scenarios Summary Quality Attribute Scenario Measurable Requirement Reliability Industrial Operation Continuous operation for duration of connected hardware operation within environmental specifications Performance Real-time Control PLC sending time-critical control data must experience &lt;5ms latency to SCADA system Compatibility Protocol Flexibility Work reliably with broad range of custom baud rates and protocol parameters Architectural Drivers Business Drivers (Priority Order) Regulatory Compliance - Western-only components, anticipating new regulations for updateable/auditable firmware Market Gap - Address discontinued commercial solutions, provide open source alternative to expensive/black-box products Industrial Deployment - Must operate reliably in harsh industrial environments ROI - First-year return on investment (afterthought, minimal architectural influence) Technical Drivers (Priority Order) 4-UART Requirement - Multiple concurrent serial bridges, each must operate independently Static Memory Model - No dynamic allocation, all memory allocated at compile time for predictable behavior RP2350 Platform - Dual-core ARM, PIO capabilities, security features enable advanced functionality Organizational Drivers (Priority Order) TDD + C Expertise - Mandatory test-driven development, deep embedded C knowledge in team Arc42 Documentation - Standardized architecture documentation approach Open Source GPL - Complete transparency (minimal architectural influence) Architecture Significant Requirements (ASRs) Non-Negotiable (System Fails Without These) Industrial Reliability - Must not fail during normal operation Static Resource Allocation - Enables reliability through predictability 500kBaud Sustained Rate - Crucial performance baseline Secure OTA with A/B Updates - \"We can fix everything if this works\" Negotiable (Important but Flexible) 4 UARTs (important but not crucial) Protocol agnostic operation (debatable) Compliance auditability (debatable) Solution Approach Overview Fundamental Architecture: Dual-Core Separation + Interrupts/DMA Technology Strategy Core Technology Decisions Technology Area Strategic Decision &amp; Rationale Architecture Pattern Dual-core separation with interrupt/DMA - provides fault isolation while achieving hardware-driven performance Programming Language C with Native Pico SDK - leverages team expertise, provides full platform access, enables deterministic behavior Memory Management Static allocation only - enables industrial reliability through predictable behavior, no dynamic allocation risks Inter-Core Communication Cache-aligned ring buffers with mutexes - optimal performance with deterministic behavior Ethernet Controller ENC28J60 with software TCP/IP - \"dumb\" controller enables full code auditability and control Communication Architecture Ring Buffer Design: // Each entry = 1 cache line (64 bytes base + 1024 payload) typedef struct { // Management Data (16 bytes) uint8_t uart_channel; // 0-3 uint8_t direction; // TX/RX uint8_t status; // FILLING/DRAINING/FULL/EMPTY uint8_t payload_length; // Actual data length uint32_t timestamp; // Fill timestamp uint32_t sequence_id; // For ordering/debugging uint32_t reserved; // Future use/alignment // Payload Data (1024 bytes max) uint8_t payload[1024]; // Fixed max size for worst case } ring_entry_t; Memory Allocation Strategy: Buffer Size: (total_mem - static_vars) / sizeof(ring_entry_t) - 1 entries Cache Aligned: No core contention, optimal performance Overflow Policy: Drop oldest packets (deterministic, simple) Decomposition Strategy System Decomposition Approach Dual-core functional separation - Each core specializes in distinct responsibilities with clean interfaces through shared memory ring buffers. Major Components/Services Component/Service Responsibilities Key Interfaces Core 0 UART Manager All 4 UART interfaces, interrupt/DMA handling, stream-to-packet conversion Hardware UARTs, Ring buffer producer Core 1 Network Manager TCP/IP stack, ENC28J60 control, packet-to-network conversion Ring buffer consumer, SPI to ENC28J60 Ring Buffer System Inter-core communication, cache-aligned data transfer Shared memory + mutex interfaces HTTP Management UI Device configuration, diagnostics, OTA trigger HTTP server on Core 1 OTA Update System Secure firmware updates, A/B partition management Secure boot, flash management Component Interaction Strategy Interaction Principles: Core 0 ‚Üí Ring Buffer: UART streams converted to fixed-size packets, cache-aligned writes Ring Buffer ‚Üí Core 1: Packet consumption for TCP transmission Overflow Policy: Drop oldest packets (deterministic, simple) Priority: UART processing takes priority over HTTP UI Quality Achievement Strategy Quality Goal Implementation Quality Goal Architectural Mechanisms Validation Approach Reliability Core separation, static allocation, deterministic behavior, drop-oldest overflow Extended operation testing, fault injection, environmental testing Compatibility Protocol-agnostic packet handling, configurable UART parameters Testing with diverse industrial protocols, auto-negotiation validation Performance Interrupt/DMA driven I/O, cache-aligned buffers, hardware-optimized data paths Sustained 500kBaud testing, latency measurements, stress testing Cross-Cutting Concerns Strategy Cross-Cutting Concern Implementation Strategy Error Handling Graceful degradation, fault isolation between cores, deterministic error responses Memory Management Static allocation only, pre-calculated buffer sizes, cache-aligned data structures Security Secure OTA updates, A/B partitioning, auditable code paths Testing Host-based testing with abstracted semaphores, hardware-in-the-loop validation Strategic Decisions and Trade-offs Major Architectural Decisions Decision Rationale Trade-offs Dual-Core Separation Fault isolation + performance, leverages RP2350 capabilities Increased complexity vs single-core simplicity Fixed 1024-byte Packets Deterministic behavior, handles worst-case scenarios 96% memory waste (avg 40 bytes vs 1024 max) accepted for simplicity Drop-Oldest Overflow Deterministic, reliable behavior under overload Data loss vs flow control complexity Cache-Aligned Buffers Optimal inter-core performance Memory overhead vs efficiency Key Trade-off: Fixed Packet Size Inefficiency The Challenge: Realistic scenario: Max=1024 bytes, Average=40 bytes ‚Üí 96% memory waste Risk: Significant resource inefficiency in typical use cases Mitigation Rationale: Sub-5ms latency requirement limits buffering depth anyway (~2-3 packets maximum) Total waste limited: 4 UARTs √ó 3 packets √ó 1024 bytes = ~12KB (acceptable in 520KB system) Implementation simplicity enables reliable delivery Future Optimization Path: Protocol-aware multi-pool approach documented for later enhancement: Small Pool: 64-byte entries (for ‚â§40 byte packets) Medium Pool: 256-byte entries (for 41-200 byte packets) Large Pool: 1024-byte entries (for 201-1024 byte packets) Alternative Approaches Considered Alternative Why Not Selected Key Insight Single-Core Design Cannot achieve 4-UART + network performance simultaneously Core separation essential for real-time requirements Dynamic Memory Allocation Conflicts with industrial reliability requirements Static allocation mandatory for predictable behavior W5500 Ethernet Controller Hardware TCP/IP stack not auditable, conflicts with compliance goals \"Dumb\" controller enables full code control Implementation Strategy Development Approach Implementation Aspect Strategy Development Methodology Test-driven development with host-based testing using abstracted semaphores Testing Strategy Host simulation with pthread/threads, then hardware validation Risk Mitigation Single UART + single TCP proof-of-concept first Platform Abstraction Abstract semaphores/mutexes for host testing: platform_mutex_t , platform_semaphore_t Implementation Phases Phase 1: Proof of Concept Single UART + Single TCP socket Mock ring buffer with abstracted semaphores Host-based testing with thread simulation Validate core architecture concepts Phase 2: Full System Implementation All 4 UARTs on Core 0 Complete ring buffer system Full TCP/IP integration on Core 1 HTTP management UI Phase 3: Advanced Features Secure OTA implementation A/B update mechanism Industrial hardening and optimization Validation and Success Metrics Milestone Success Criteria Validation Method Ring Buffer Validation Concurrent producer/consumer without data corruption Host-based stress testing Performance Achievement 500kBaud sustained, &lt;5ms latency Hardware-in-the-loop measurement Reliability Demonstration 24+ hour continuous operation Extended testing under load Risk Assessment and Mitigation Strategic Risks Risk Probability/Impact Mitigation Strategy Fixed Packet Size Inefficiency High/Medium Document multi-pool optimization path, validate memory usage early Inter-Core Communication Complexity Medium/High Prove with host-based testing first, extensive validation Performance Under Load Medium/High Early prototyping, stress testing, hardware validation Architecture Evolution Strategy Future Optimization Path Protocol-Aware Enhancements: Multi-pool buffer management for memory efficiency Protocol-specific packet sizing based on message type analysis Dynamic buffer allocation per UART based on usage patterns Security and Compliance Evolution: Enhanced security features for evolving compliance requirements Extended audit trail capabilities Additional cryptographic features as regulations develop Performance Optimizations: Fine-tuned based on real-world deployment data Protocol filter optimizations Network stack performance improvements Success Factors Critical Dependencies: Early validation of ring buffer architecture with host-based testing Incremental implementation starting with single UART proof-of-concept Comprehensive testing at each phase before proceeding Key Assumptions: RP2350 dual-core performance meets concurrent processing requirements Cache-aligned ring buffers provide sufficient inter-core bandwidth Static memory allocation provides adequate resource management Monitoring and Adaptation: Continuous validation of memory efficiency in real deployments Performance monitoring under various industrial load scenarios Regular assessment of compliance requirement evolution Conclusion This solution strategy establishes UART2ETH as an \"unbreakable foundation with field-updateable capability\" through: Core Architectural Principles: Reliability-first dual-core separation Static allocation for predictable behavior Hardware-driven performance with software control Protocol-agnostic flexibility Strategic Advantages: Fault isolation enables industrial reliability Deterministic behavior supports real-time requirements Full code auditability meets compliance needs Incremental implementation reduces development risk Success Enablers: TDD approach with host-based validation Clear module boundaries for team development Documented optimization paths for future enhancement Strong foundation for scaling and feature evolution The strategy balances immediate reliability requirements with long-term flexibility, ensuring UART2ETH can serve as a robust industrial networking solution while maintaining the ability to evolve with changing requirements and regulations. "
},

{
    "id": 18,
    "uri": "arc42/src/02_architecture_constraints.html",
    "menu": "arc42",
    "title": "Architecture Constraints",
    "text": " Table of Contents Architecture Constraints Technical Constraints Organizational Constraints Economic Constraints Regulatory and Legal Constraints Architecture Constraints Technical Constraints Constraint Description Rationale Hardware Platform Must use RP2350 microcontroller as primary processing unit Provides required security features for OTA updates, sufficient processing power for 4 UART channels, and western supply chain compliance Component Sourcing All components must be sourced from western suppliers only Regulatory compliance requirement for target markets and supply chain security considerations Performance Requirements Minimum 500kBaud sustained throughput with sub-5ms latency per UART channel Industrial application requirements for real-time data transmission Network Interface 100Mbit Ethernet connectivity via SPI-based controller Cost constraints and sufficient bandwidth for target applications while maintaining hardware simplicity UART Channel Limit Maximum 4 independent UART interfaces Hardware resource limitations of chosen microcontroller platform and cost optimization Organizational Constraints Constraint Description Rationale Open Source License Complete system must be released under GPL license Leverage existing open source libraries and reduce implementation effort by reusing proven components Development Process Test-driven development (TDD) approach mandatory for all production code Quality assurance and maintainability requirements for industrial application reliability Documentation Standard Architecture documentation must follow arc42 template structure Standardized documentation approach for future maintainers and contributors Version Control GitHub-based development workflow with mandatory pull request reviews Code quality control and collaborative development coordination Economic Constraints Constraint Description Rationale Hardware Cost Hardware target price per unit must be significantly below commercially available solutions Competitive market positioning requires substantial cost advantage to justify adoption over established commercial products Development Effort Development effort must achieve return on investment within first year of deployment Resource allocation constraint limits project scope and complexity to ensure economic viability and timely market entry Regulatory and Legal Constraints Constraint Description Rationale CE Certification Hardware must achieve CE compliance for European market Legal requirement for commercial deployment in target markets Firmware Security Must implement secure boot and signed firmware update mechanisms Anticipated regulatory requirements for updateable industrial devices EMC Compliance Electromagnetic compatibility requirements for industrial environments Regulatory requirement and operational necessity in electrically noisy industrial settings Export Control No components or technologies subject to export restrictions Unrestricted distribution and deployment capability Patent Avoidance Must not infringe on existing patents in communication protocols or hardware interfaces Legal risk mitigation and freedom to operate requirements "
},

{
    "id": 19,
    "uri": "search.html",
    "menu": "-",
    "title": "search",
    "text": " Search Results "
},

{
    "id": 20,
    "uri": "lunrjsindex.html",
    "menu": "-",
    "title": "null",
    "text": " will be replaced by the index "
},

];
