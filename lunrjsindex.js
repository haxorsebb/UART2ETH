var documents = [

{
    "id": 0,
    "uri": "adrs/ADR-003-programming-language-selection.html",
    "menu": "adrs",
    "title": "ADR-003: Programming Language Selection for UART2ETH",
    "text": " Table of Contents ADR-003: Programming Language Selection for UART2ETH Context Decision Drivers Options Considered PUGH Matrix Analysis Decision Rationale Consequences Implementation Notes Follow-up Actions ADR-003: Programming Language Selection for UART2ETH Status: PROPOSED Date: 2025-07-26 Deciders: Architecture Team Consulted: Senior Developer Informed: Development Team Context The UART2ETH system requires selecting a programming language for firmware development on the RP2350 microcontroller. This decision directly impacts development velocity, system reliability, maintainability, and the ability to meet project delivery timelines. Based on hardware platform decisions (ADR-001: RP2350 selection, ADR-002: ENC28J60 selection), we need a programming language that can: Deliver industrial-grade reliability for 4 concurrent UART-to-TCP bridges Support real-time performance requirements (500 kbps per port, sub-5ms latency) Enable rapid development with existing team expertise Operate efficiently in severely memory-constrained environment (520KB SRAM, static allocation) Provide adequate safety guarantees for industrial deployment Meet aggressive project delivery timeline (\"deliver yesterday\") Must operate reliably in industrial environments (-40¬∞C to +85¬∞C) üòâ The programming language selection fundamentally determines development productivity, code maintainability, and the feasibility of meeting project deadlines with current team capabilities. Decision Drivers Primary Requirements Development Velocity : Critical time-to-market pressure requiring immediate productivity Team Expertise : Leveraging existing microcontroller team&#8217;s deep C experience Industrial Reliability : Proven track record in embedded industrial applications Memory Model Fit : Optimal performance in static memory allocation environment Ecosystem Maturity : Comprehensive tooling, libraries, and vendor support Real-time Determinism : Predictable behavior for latency-critical applications Hardware Integration : Direct access to RP2350 and ENC28J60 peripherals Debugging Capabilities : Mature debugging tools for embedded development Constraints Aggressive delivery timeline with no room for learning curve delays Small project scope where complexity management is achievable Static memory allocation model (no dynamic allocation) Team expertise concentrated in C/C++ embedded development Must operate reliably in industrial environments (-40¬∞C to +85¬∞C) üòâ Options Considered Option A: C Programming Language Ecosystem : Mature ecosystem with comprehensive RP2350 Pico SDK support Team Expertise : Deep existing knowledge in microcontroller team Development Velocity : Immediate productivity, no learning curve Memory Model : Direct, predictable memory management with static allocation Tooling : Mature debugging (GDB, OpenOCD), profiling, and analysis tools Hardware Support : Full vendor support for RP2350 and ENC28J60 Industrial Track Record : Decades of proven deployment in embedded systems Real-time Performance : Deterministic, low-level control over hardware Memory Safety : Achievable through disciplined practices and comprehensive testing Standards Compliance : MISRA-C guidelines for industrial safety Option B: Rust Programming Language Ecosystem : Emerging ecosystem with excellent RP2350 day-one support (rp235x-hal) Team Expertise : No existing knowledge, 6-12 month learning curve to proficiency Development Velocity : Significant initial productivity loss during team transition Memory Model : Memory safety guarantees less relevant in static allocation environment Tooling : Improving but less mature debugging tools (probe-rs vs GDB) Hardware Support : Good RP2350 support, limited ENC28J60 ecosystem Industrial Track Record : Limited embedded deployment history Real-time Performance : Embassy framework provides async capabilities Memory Safety : Compile-time guarantees prevent entire classes of bugs Modern Features : Advanced type system, zero-cost abstractions PUGH Matrix Analysis Scoring: Better than baseline (+1, +2), Same as baseline (0), Worse than baseline (-1, -2) Baseline: C Programming Language (all scores = 0) Criteria Weight C Language Rust Language Development Velocity 3 0 (baseline) -2 (6-12 month learning curve) Team Expertise 3 0 (baseline) -2 (zero existing knowledge) Time to Market 3 0 (baseline) -2 (immediate productivity loss) Ecosystem Maturity 2 0 (baseline) -1 (emerging, less comprehensive) Memory Safety in Static Environment 2 0 (baseline) +1 (compile-time checks, limited benefit) Industrial Track Record 2 0 (baseline) -1 (limited embedded deployment) Hardware Vendor Support 2 0 (baseline) -1 (good RP2350, limited ENC28J60) Debugging Maturity 2 0 (baseline) -1 (improving but less mature) Real-time Determinism 2 0 (baseline) 0 (comparable with Embassy) Code Maintainability 3 0 (baseline) +1 (better type system) Future Proofing 4 0 (baseline) +2 (modern language, industry trend) TOTAL WEIGHTED SCORE 0 -13 Decision Selected: C Programming Language The C programming language provides the optimal balance of development velocity, team productivity, and technical capability for the UART2ETH project, scoring significantly higher in our weighted analysis. Rationale Why C Over Rust Immediate Productivity : Team can begin productive development immediately without learning curve delays Time-Critical Delivery : Project timeline (\"deliver yesterday\") cannot accommodate 6-12 month Rust learning curve Static Memory Context : Rust&#8217;s primary advantages (memory safety) are significantly diminished in our static allocation environment where: No dynamic allocation eliminates use-after-free, double-free, memory leaks Fixed buffer sizes and lifetimes reduce dangling pointer risks Predictable memory layout simplifies debugging and validation Team Expertise Leverage : Deep microcontroller C experience translates to immediate high-quality code Ecosystem Maturity : Comprehensive vendor support, mature tooling, extensive industrial deployment history Manageable Complexity : Small project scope where C complexity is controllable through: Disciplined coding practices (MISRA-C guidelines) Comprehensive unit and integration testing Code reviews focused on memory safety patterns Static analysis tools Memory Safety Strategy in C Static Allocation : All memory allocated at compile time, eliminating dynamic memory risks Defensive Programming : Bounds checking, input validation, error handling Testing Strategy : 100% code coverage, stress testing, hardware-in-the-loop validation Code Standards : MISRA-C compliance for industrial safety Review Process : Mandatory security-focused code reviews Rust Advantages Acknowledged But Outweighed Compile-time Memory Safety : Valuable but less critical in static allocation environment Modern Type System : Benefits outweighed by learning curve and timeline pressure Future-proofing : Theoretical benefit cannot justify immediate delivery risk Consequences Positive ‚úÖ Immediate Development Start : No productivity loss during language transition ‚úÖ Team Expertise Utilized : Deep C knowledge translates to high-quality embedded code ‚úÖ Mature Ecosystem : Full vendor support, comprehensive tooling, extensive libraries ‚úÖ Proven Industrial Reliability : Decades of successful embedded deployments ‚úÖ Debugging Efficiency : Mature GDB/OpenOCD toolchain familiar to team ‚úÖ Timeline Compliance : Meets aggressive delivery requirements Negative ‚ö†Ô∏è Manual Memory Management : Requires disciplined practices and comprehensive testing ‚ö†Ô∏è Potential Security Vulnerabilities : Manual bounds checking, pointer management ‚ö†Ô∏è Future Technology Debt : May require reevaluation for future projects ‚ö†Ô∏è Missing Modern Features : Less expressive type system than Rust Risks and Mitigation Memory Safety Risk : Mitigate through MISRA-C compliance, static analysis, comprehensive testing Code Quality Risk : Mitigate through mandatory code reviews, automated testing, continuous integration Future Maintenance Risk : Document rationale, plan Rust evaluation for future projects Implementation Notes Development Standards MISRA-C Compliance : Follow MISRA-C:2012 guidelines for industrial safety Static Analysis : Integrate PC-lint, Cppcheck, or equivalent in CI pipeline Memory Management : Strictly static allocation, no malloc/free usage Error Handling : Consistent error codes, graceful degradation strategies Testing Strategy Unit Testing : 100% code coverage requirement Integration Testing : Hardware-in-the-loop validation Stress Testing : Extended operation under maximum load conditions Memory Validation : Static analysis tools, runtime bounds checking in debug builds Security Practices Input Validation : All network and UART inputs validated Buffer Management : Fixed-size buffers with explicit bounds checking Secure Coding : Follow SEI CERT C guidelines Code Reviews : Security-focused review process for all code changes Follow-up Actions Development Environment : Configure MISRA-C checking in build system Testing Framework : Establish unit testing framework with coverage reporting Code Standards : Document project-specific C coding guidelines Static Analysis : Integrate static analysis tools in CI/CD pipeline Team Training : Brief refresher on secure C practices for embedded systems Future Evaluation : Plan Rust reassessment for next major project Review Notes: &#10063; Confirm MISRA-C compliance requirements with quality team &#10063; Validate static analysis tool selection &#10063; Review memory safety testing strategy &#10063; Document specific secure coding guidelines &#10063; Plan future Rust evaluation timeline "
},

{
    "id": 1,
    "uri": "adrs/ADR-001-microcontroller-selection.html",
    "menu": "adrs",
    "title": "ADR-001: Microcontroller Platform Selection for UART2ETH",
    "text": " Table of Contents ADR-001: Microcontroller Platform Selection for UART2ETH Context Decision Drivers Options Considered PUGH Matrix Analysis Decision Rationale Consequences Implementation Notes Follow-up Actions ADR-001: Microcontroller Platform Selection for UART2ETH Status: PROPOSED Date: 2025-07-26 Deciders: Architecture Team Consulted: Senior Developer Informed: Development Team Context The UART2ETH system requires a microcontroller platform capable of: Supporting up to 4 concurrent UART interfaces Processing TCP/IP networking with industrial reliability Implementing secure OTA firmware updates with A/B partitioning Operating in industrial environments (-40¬∞C to +85¬∞C) Achieving 500 kbps sustained throughput per UART port with sub-5ms latency Cost-effective solution for volume production The microcontroller selection is a foundational decision that affects all system capabilities, development complexity, and long-term maintainability. Decision Drivers Primary Requirements Multi-UART Support : Hardware support for multiple UARTs or flexible alternatives Network Processing : Sufficient processing power for TCP/IP stack and protocol filtering A/B Update Capability : Sufficient flash memory and architecture for dual firmware partitions Security Capabilities : Hardware support for cryptographic operations and secure boot Industrial Reliability : Temperature range, electrical robustness, proven track record Real-time Performance : Deterministic behavior for latency-critical applications Development Ecosystem : Mature toolchain, documentation, community support Cost Effectiveness : Component cost + external components for volume production Constraints Must operate reliably in industrial environments GPL open source licensing compatibility Maximum system cost target: $10 for volume production Options Considered Option A: Raspberry Pi RP2350 Architecture : Dual-core ARM Cortex-M33 @ 150MHz Memory : 520KB SRAM, external flash required UARTs : 2 hardware UARTs + 12 programmable I/O (PIO) state machines Networking : Requires external Ethernet controller (ENC28J60) Security : Hardware SHA-256, ARM TrustZone, secure boot capabilities A/B Updates : External flash enables dual partitions + secure bootloader Development Ecosystem : Good documentation, smaller community than Arduino Industrial Track Record : None (released August 2024, zero field deployment) Cost : ~$1.00 + ~$1.50 (ENC28J60) = $2.50 total Option B: ATMega328P (Baseline) Architecture : Single-core 8-bit AVR @ 16MHz Memory : 2KB SRAM, 32KB Flash UARTs : 1 hardware UART Networking : Requires external Ethernet controller (ENC28J60) Security : No hardware security features A/B Updates : Insufficient flash space (32KB) for dual firmware images Development Ecosystem : Arduino platform - most accessible ecosystem ever created, millions of tutorials Industrial Track Record : Decades of proven deployment in industrial environments Cost : ~$2.50 + ~$1.50 (ENC28J60) = $4.00 total Option C: ESP32 Architecture : Dual-core Xtensa LX6 @ 240MHz Memory : 520KB SRAM, 4MB Flash UARTs : 3 hardware UARTs Networking : Built-in WiFi/Bluetooth, requires external Ethernet for wired Security : Hardware crypto acceleration, secure boot A/B Updates : 4MB flash supports dual partitions + ESP-IDF OTA framework Development Ecosystem : Good tools (ESP-IDF, Arduino IDE), solid community, smaller than Arduino Industrial Track Record : 8+ years deployment (2016+), moderate industrial adoption, less proven than ATMega328P Cost : ~$2.50 + ~$1.50 (ENC28J60) = $4.00 total PUGH Matrix Analysis Scoring: Better than baseline (+1, +2), Same as baseline (0), Worse than baseline (-1, -2) Baseline: ATMega328P (all scores = 0) Criteria Weight ATMega328P RP2350 ESP32 UART Support 3 0 (baseline) +2 (PIO flexibility) +1 (3 HW UARTs) Processing Power 3 0 (baseline) +2 (dual 32-bit @150MHz) +2 (dual 32-bit @240MHz) Memory Capacity 2 0 (baseline) +2 (260x more SRAM) +2 (260x more SRAM) A/B Update Support 3 0 (baseline) +2 (external flash + secure boot) +2 (4MB flash + OTA framework) Security Features 3 0 (baseline) +2 (HW SHA-256 + TrustZone) +1 (HW crypto only) Real-time Determinism 2 0 (baseline) +2 (PIO + dual-core) +1 (dual-core) Development Ecosystem 2 0 (baseline) -1 (smaller community, newer) 0 (good tools, smaller than Arduino) Industrial Reliability 2 0 (baseline) -1 (new platform, zero field history) 0 (8+ years, less than decades) Cost Effectiveness 1 0 (baseline) +2 (37% cost reduction) 0 (same cost) Network Architecture 2 0 (baseline) 0 (same - external PHY) -1 (WiFi overhead) Weighted Scores RP2350 Total Score: UART: 3√ó(+2) = +6 Processing: 3√ó(+2) = +6 Memory: 2√ó(+2) = +4 A/B Updates: 3√ó(+2) = +6 Security: 3√ó(+2) = +6 Real-time: 2√ó(+2) = +4 Ecosystem: 2√ó(-1) = -2 Reliability: 2√ó(-1) = -2 Cost: 1√ó(+2) = +2 Network: 2√ó(0) = 0 Total: +30 ESP32 Total Score: UART: 3√ó(+1) = +3 Processing: 3√ó(+2) = +6 Memory: 2√ó(+2) = +4 A/B Updates: 3√ó(+2) = +6 Security: 3√ó(+1) = +3 Real-time: 2√ó(+1) = +2 Ecosystem: 2√ó(0) = 0 Reliability: 2√ó(0) = 0 Cost: 1√ó(0) = 0 Network: 2√ó(-1) = -2 Total: +22 Decision Selected: Raspberry Pi RP2350 The RP2350 scores significantly higher (+30 vs +22) in the weighted PUGH analysis, primarily due to: Superior UART Flexibility : PIO state machines provide unmatched capability for implementing custom UART protocols A/B Update Architecture : External flash design enables reliable dual-partition firmware updates Security Architecture : Hardware SHA-256 and TrustZone directly address secure OTA requirements Cost Advantage : 37% lower total system cost while providing better capabilities Real-time Determinism : PIO subsystem + dual-core architecture enables predictable performance Rationale Why RP2350 Over ATMega328P Performance Gap : 328P cannot handle 4 concurrent UARTs + TCP processing Memory Limitation : 2KB SRAM insufficient for networking stack and buffering A/B Update Impossibility : 32KB flash insufficient for dual firmware images (need ~64KB minimum) Security Gap : No hardware security features compromise OTA update integrity Future Flexibility : PIO enables protocol adaptations without hardware changes Why RP2350 Over ESP32 Industrial Focus : No unnecessary WiFi attack surface in industrial environments Cost Efficiency : Lower total system cost for same networking capability Architectural Fit : PIO subsystem specifically designed for custom I/O protocols Security Model : TrustZone provides more comprehensive security architecture UART Flexibility : Superior support for multiple custom UART implementations Industrial Reliability Trade-off : While ESP32 has solid 8+ years of industrial deployment vs RP2350&#8217;s zero field history, neither matches ATMega328P&#8217;s decades of proven reliability. Development Ecosystem Trade-off : ATMega328P&#8217;s Arduino ecosystem is unmatched in accessibility, tutorials, and community support. Both RP2350 and ESP32 have smaller ecosystems despite good documentation. Despite these disadvantages, the RP2350&#8217;s technical advantages outweigh these risks for our specific application requirements. Consequences Positive ‚úÖ Technical Capability : Meets all performance and functionality requirements ‚úÖ Cost Optimization : Lowest total system cost among capable options ‚úÖ Security Compliance : Hardware support for all security requirements ‚úÖ Development Efficiency : Excellent documentation and tooling ecosystem ‚úÖ Future Flexibility : PIO enables protocol extensions without redesign Negative ‚ö†Ô∏è External Dependency : Requires ENC28J60 Ethernet controller ‚ö†Ô∏è Industrial Deployment Risk : Zero field deployment history in industrial environments (released August 2024) ‚ö†Ô∏è Platform Maturity : Less proven than ATMega328P&#8217;s decades of industrial use ‚ö†Ô∏è Development Ecosystem : Smaller community and fewer resources compared to Arduino&#8217;s massive ecosystem ‚ö†Ô∏è Custom Development : PIO programming requires specialized knowledge Risks and Mitigation Supply Chain Risk : Multiple suppliers available, stockpile strategy for critical components ENC28J60 Dependency : Well-established component with multiple sources and alternatives Industrial Reliability Risk : RP2350 has zero industrial field deployment history; mitigate with extensive environmental testing and validation program Development Complexity : Comprehensive documentation and examples available Implementation Notes Required External Components ENC28J60 Ethernet Controller : Hardware TCP/IP stack, SPI interface Crystal/Oscillator : For precise timing if required by application Power Supply : 3.3V regulation and filtering Protection : ESD protection for industrial environments Development Approach Phase 1 : Basic RP2350 + ENC28J60 integration with single UART Phase 2 : PIO-based additional UART implementation Phase 3 : Security features and OTA update system Architecture Implications Dual-Core Utilization : Core 0 for real-time UART processing, Core 1 for networking Memory Management : Static allocation for predictable real-time behavior Security Integration : TrustZone secure boot with hardware-accelerated crypto Follow-up Actions Procurement : Establish supplier relationships for RP2350 and ENC28J60 Industrial Validation : Comprehensive environmental testing program to validate RP2350 reliability in industrial conditions Prototyping : Develop basic hardware platform for validation testing PIO Development : Create UART protocol templates using PIO state machines Security Planning : Design secure boot and OTA update architecture Testing Strategy : Define industrial environment validation procedures including EMI/EMC testing Review Notes: &#10063; Confirm ENC28J60 vs W5500 preference &#10063; Validate cost estimates with current supplier pricing &#10063; Review A/B update architecture requirements vs RP2350 external flash approach &#10063; Confirm industrial temperature requirements vs RP2350 specs &#10063; Validate PUGH matrix criteria weights reflect actual project priorities "
},

{
    "id": 2,
    "uri": "adrs/ADR-004-development-ecosystem.html",
    "menu": "adrs",
    "title": "ADR-004: Development Ecosystem Selection for UART2ETH",
    "text": " Table of Contents ADR-004: Development Ecosystem Selection for UART2ETH Context Decision Drivers Options Considered PUGH Matrix Analysis Decision Rationale Consequences üö® Critical Contradiction Discovery Implementation Notes Interdependency with ADR-002 Follow-up Actions ADR-004: Development Ecosystem Selection for UART2ETH Status: PROPOSED Date: 2025-07-27 Deciders: Architecture Team Consulted: Senior Developer Informed: Development Team Context The UART2ETH system requires selecting a comprehensive development ecosystem including build system, toolchain, IDE integration, and dependency management for RP2350-based firmware development. This decision directly impacts development velocity, code quality, maintainability, and the ability to leverage advanced RP2350 capabilities. Based on platform decisions: ADR-001: RP2350 microcontroller selection ADR-002: ENC28J60 ethernet controller selection ADR-003: C programming language selection We need a development ecosystem that can: Enable rapid, professional C development on RP2350 platform Support industrial-grade reliability and testing practices Provide access to advanced RP2350 features (PIO, dual-core, secure boot, A/B updates) Integrate with selected ethernet controller efficiently Support team collaboration and CI/CD practices Meet aggressive delivery timeline requirements Enable MISRA-C compliance and comprehensive testing Decision Drivers Primary Requirements Development Velocity : Immediate productivity with minimal learning curve RP2350 Feature Access : Full access to PIO, dual-core, security, and OTA capabilities Industrial Tooling : Mature debugging, static analysis, and testing infrastructure Team Expertise Fit : Leverage existing C/embedded development skills Ethernet Integration : Efficient integration with selected ethernet controller Professional Workflow : Support for code reviews, CI/CD, and quality gates Documentation : Comprehensive vendor support and community resources Constraints Aggressive delivery timeline requiring immediate productivity Industrial reliability requirements (MISRA-C, comprehensive testing) Team expertise concentrated in C/embedded development Must support secure OTA updates and A/B partitioning GPL open source licensing compatibility Options Considered Option A: Arduino IDE/Framework Pros : Rapid prototyping, huge community, simple setup Cons : Not professional-grade, poor CI/CD integration, limited industrial features, conflicts with C language choice ( ADR-003 ) Option B: PlatformIO + Arduino Framework Pros : Professional IDE integration, good dependency management, better than Arduino IDE Cons : Still Arduino framework limitations, emerging RP2350 support Option C: PlatformIO + Native Pico SDK Pros : Professional environment with native SDK access Cons : RP2350 support still emerging, complexity with advanced features, abstraction layer overhead Option D: Native Pico SDK + CMake (Traditional Embedded) Pros : Maximum control, full vendor support, mature tooling, industrial-grade capability Cons : More manual setup, steeper learning curve for non-embedded developers PUGH Matrix Analysis Scoring: Better than baseline (+1, +2), Same as baseline (0), Worse than baseline (-1, -2) Baseline: Arduino IDE (all scores = 0) Criteria Weight Arduino IDE PlatformIO+Arduino PlatformIO+SDK Native SDK+CMake Development Velocity 3 0 (baseline) +1 (better IDE, deps mgmt) -1 (setup complexity) -1 (manual setup) RP2350 Feature Access 3 0 (baseline) 0 (Arduino framework limits) +1 (emerging SDK access) +2 (full SDK access) Industrial Tooling 3 0 (baseline) +1 (better IDE, CI integration) +2 (professional environment) +2 (mature debugging, analysis) Team Expertise Fit 2 0 (baseline) 0 (similar Arduino approach) +1 (mixed C/Arduino) +2 (pure C expertise) Professional Workflow 2 0 (baseline) +2 (CI/CD, collaboration tools) +2 (professional environment) +2 (industry standard) Advanced RP2350 Features 3 0 (baseline) -1 (Arduino abstractions hide features) +1 (partial SDK access) +2 (secure boot, A/B updates, PIO) Delivery Timeline 3 0 (baseline) +1 (faster than manual setup) 0 (learning curve offsets speed) -1 (initial setup overhead) Industrial Compliance 3 0 (baseline) 0 (limited MISRA-C support) +1 (better static analysis) +2 (full MISRA-C, testing support) Debugging Maturity 2 0 (baseline) +1 (better than Arduino IDE) +1 (good debugging support) +2 (GDB, OpenOCD, mature tools) Long-term Maintainability 2 0 (baseline) +1 (better project structure) +1 (cleaner architecture) +2 (vendor-supported, stable) Total PUGH Score 0 +14 +22 +34 Decision Selected: Native Pico SDK + CMake Development Ecosystem The Native Pico SDK with CMake provides the optimal foundation for professional, industrial-grade development of the UART2ETH system, scoring significantly higher (+34 vs +22 vs +14 vs 0) in weighted analysis. Rationale Why Native SDK + CMake Over PlatformIO + SDK (+34 vs +22) Superior RP2350 Feature Access : Full vendor-supported access to secure boot, A/B updates, and advanced PIO programming vs emerging support Industrial Compliance Advantage : Native MISRA-C toolchain integration vs adaptation layers Team Expertise Optimal Fit : Direct C expertise application vs mixed C/framework approach Debugging Maturity : Full GDB/OpenOCD integration vs abstracted debugging Long-term Vendor Support : Raspberry Pi official support vs third-party integration Why PlatformIO + SDK Over PlatformIO + Arduino (+22 vs +14) RP2350 Capabilities : Access to microcontroller features vs Arduino framework limitations Industrial Requirements : Better static analysis and compliance support Advanced Features : Required for secure OTA and A/B updates vs basic functionality Why Any Professional Option Over Arduino IDE (Baseline) Industrial Development : Professional tooling, CI/CD, collaboration vs hobbyist-focused Project Complexity : Multi-UART, networking, security features exceed Arduino scope Team Requirements : Professional development practices vs simple prototyping Delivery Timeline Trade-off Justification While Native SDK has initial setup overhead (-3 points), this is offset by: Quality Foundation : Reduces rework and debugging time later Team Expertise : C skills minimize learning curve impact Industrial Requirements : Mandatory for MISRA-C compliance and advanced features Long-term Velocity : Better maintainability and debugging capabilities Consequences Positive ‚úÖ Professional Development Environment : Industry-standard toolchain with mature debugging and analysis tools ‚úÖ Full Platform Capability : Access to all RP2350 advanced features required for product requirements ‚úÖ Industrial Compliance : Native support for MISRA-C, static analysis, and testing frameworks ‚úÖ Team Productivity : Direct application of existing embedded C expertise ‚úÖ Vendor Support : Comprehensive Raspberry Pi documentation and examples ‚úÖ Future-Proof Architecture : Foundation for advanced features and scaling Negative ‚ö†Ô∏è Initial Setup Complexity : More manual configuration compared to PlatformIO ‚ö†Ô∏è Learning Curve : CMake and SDK-specific concepts for team members unfamiliar with Pico development ‚ö†Ô∏è Dependency Management : Manual library management vs automated PlatformIO approach ‚ö†Ô∏è IDE Integration : Requires configuration vs out-of-box PlatformIO experience Risks and Mitigation Development Environment Setup Risk : Mitigate with standardized Docker development containers and comprehensive setup documentation Team Learning Curve Risk : Mitigate with focused training sessions and pair programming during initial implementation Dependency Management Complexity : Mitigate with Git submodules and clear dependency documentation Critical Ethernet Controller Ecosystem Dependency Risk HIGH RISK : The viability of our development ecosystem choice is significantly impacted by ADR-002 (Ethernet Controller Selection) : W5500 Ecosystem Support : ‚úÖ Official WIZnet Libraries : Native Pico SDK integration (WIZnet-PICO-C, WIZnet-PICO-LWIP-C) ‚úÖ Vendor Documentation : Comprehensive examples and industrial deployment guides ‚úÖ Community Support : Multiple professional implementations and maintained libraries ‚úÖ Industrial Examples : Azure IoT, AWS IoT integrations with proven reliability ENC28J60 Ecosystem Support : ‚ö†Ô∏è Individual Open Source Efforts : Limited to individual developers (e.g., Juddling/pi-pico-enc28j60) ‚ö†Ô∏è No Official RP2350 Support : No vendor libraries for RP2350+ENC28J60 combination ‚ö†Ô∏è Arduino-Focused : Most examples conflict with our C language choice ( ADR-003 ) ‚ö†Ô∏è Custom Integration Required : Significant lwIP integration effort needed ‚ö†Ô∏è Maintenance Risk : Dependency on individual maintainer vs corporate support Risk Assessment : ENC28J60 choice significantly increases development effort and long-term maintenance risk for our chosen development ecosystem. Mitigation Options : Accept Risk : Proceed with ENC28J60 and allocate 1-2 weeks for custom integration development Reconsider ADR-002 : Evaluate W5500 based on ecosystem maturity and development efficiency Hybrid Approach : Prototype with both controllers to validate integration effort Recommendation : This ecosystem dependency should be factored into ADR-002 reconsideration. üö® Critical Contradiction Discovery During ecosystem research, significant issues were discovered with ADR-002 (ENC28J60 selection) : ENC28J60 + RP2350 Development Challenges Limited RP2350 Support : No official vendor libraries for RP2350+ENC28J60 Arduino-Only Examples : Most implementations require Arduino framework, conflicting with ADR-003 (C language choice) Complex Integration : Requires custom lwIP integration with significant development effort Performance Limitation : 10Mbps only vs 100Mbps capability needed Industrial Reliability Risk : Less mature integration, more complex software stack Alternative: W5500 + RP2350 Ecosystem Maturity Official RP2350 Support : WIZnet W5500-EVB-Pico2 with comprehensive SDK integration Native Pico SDK Libraries : WIZnet-PICO-C, WIZnet-PICO-LWIP-C, industrial examples Hardware TCP/IP Stack : Reduces microcontroller overhead, improves determinism 100Mbps Performance : Meets bandwidth requirements Industrial Deployments : Proven in Azure IoT, AWS IoT applications Recommendation : ADR-002 should be reconsidered in light of development ecosystem requirements. Implementation Notes Development Environment Components Toolchain : ARM GCC toolchain provided with Pico SDK Build System : CMake with Pico SDK build extensions IDE Integration : VS Code with C/C++ and CMake extensions Debugging : OpenOCD + GDB with Picoprobe or compatible debugger Static Analysis : PC-lint Plus or Cppcheck integration Testing Framework : Unity or CppUTest for unit testing CI/CD : GitHub Actions with standardized build and test pipelines Required Dependencies Pico SDK v2.1+ : Full RP2350 support with security features W5500 Libraries : WIZnet-PICO-C for ethernet integration (if ADR-002 reconsidered) lwIP Stack : For TCP/IP implementation (ENC28J60) or hardware stack interface (W5500) Testing Framework : Unity for embedded unit testing Static Analysis Tools : MISRA-C compliance checking Development Standards MISRA-C Compliance : Enforce via static analysis in CI pipeline Code Coverage : 100% requirement with automated reporting Documentation : Doxygen-style comments for all public interfaces Version Control : Git with semantic versioning and conventional commits Code Reviews : Mandatory reviews for all production code changes Interdependency with ADR-002 This ADR reveals critical issues with ADR-002 (ENC28J60 selection) : Development Ecosystem Mismatch : ENC28J60 lacks mature RP2350 SDK integration Performance vs Requirements : 10Mbps limitation vs 100Mbps capability needed Industrial Reliability Concerns : Complex software stack vs proven hardware solutions Team Productivity Impact : Months of custom development vs immediate integration Recommendation : ADR-002 should be reopened with updated technical analysis considering: Ecosystem maturity and vendor support Development velocity and team productivity impact Industrial deployment requirements and reliability Follow-up Actions Evaluate ADR-002 Impact : Technical reassessment of ethernet controller choice with ecosystem considerations Development Environment Setup : Create standardized Docker containers and setup documentation Toolchain Integration : Configure CMake, static analysis, and testing framework integration Team Training Plan : Develop Pico SDK and CMake training materials Prototype Development : Create proof-of-concept demonstrating ecosystem capabilities CI/CD Pipeline : Implement automated build, test, and quality gates Review Notes: &#10063; CRITICAL : This ADR recommends reconsidering ADR-002 based on technical evidence &#10063; Confirm W5500 ecosystem advantages align with project requirements &#10063; Validate team acceptance of Native SDK approach vs PlatformIO preference &#10063; Review industrial compliance requirements vs ecosystem capabilities &#10063; Assess impact of ADR-002 change on project timeline and budget "
},

{
    "id": 3,
    "uri": "adrs/ADR-002-ethernet-controller-selection.html",
    "menu": "adrs",
    "title": "ADR-002-ethernet-controller-selection.adoc",
    "text": " Table of Contents ADR-002: Ethernet Controller Selection for UART2ETH Context Decision Drivers Primary Requirements Constraints Options Considered Option A: WIZnet W5500 Option B: Microchip ENC28J60 PUGH Matrix Analysis Decision Rationale Why ENC28J60 Over W5500 Trade-offs Accepted Consequences Positive Negative Risks and Mitigation Implementation Notes Performance Optimization Follow-up Actions ADR-002: Ethernet Controller Selection for UART2ETH Status: PROPOSED Date: 2025-07-26 Deciders: Architecture Team Consulted: Senior Developer Informed: Development Team Context The UART2ETH system requires an Ethernet controller that interfaces with the RP2350 microcontroller via SPI to provide reliable TCP/IP connectivity. This component is critical for the core networking functionality of our product. Based on our microcontroller selection (ADR-001), we need to determine the most appropriate Ethernet controller solution that can: Support 100 Mbps Ethernet connectivity Interface with the RP2350 via SPI Handle the networking requirements of up to 4 concurrent UART-to-TCP bridges Operate reliably in industrial environments (-40¬∞C to +85¬∞C) Maintain low latency while supporting our 500 kbps per port requirement Simplify firmware development with minimal microcontroller overhead Meet our cost target for volume production Does not contain firmware on its own Comes from a 'western' supplier The Ethernet controller selection impacts system performance, reliability, development complexity, and overall BOM cost. Decision Drivers Primary Requirements Network Performance : Support for full 100 Mbps Ethernet with sufficient throughput for our use case Memory Buffer Size : Sufficient buffer for packet handling and multiple connections SPI Interface Speed : Fast and efficient communication with the microcontroller Industrial Reliability : Operating temperature range and robustness for industrial use Cost Effectiveness : Component cost for volume production Development Complexity : Readily available OpenSource library for integration Constraints Must use SPI interface to connect with the RP2350 microcontroller Must operate reliably in industrial environments (-40¬∞C to +85¬∞C) Must fit within the overall $10 system cost target for volume production Must use open-source compatible software stacks (GPL license compatible) Options Considered Option A: WIZnet W5500 Interface : SPI (up to 80 MHz) Network Speed : 10/100 Mbps Ethernet TCP/IP Stack : Hardwired TCP/IP stack (integrated) Buffer Memory : 32 KB internal buffer Concurrent Connections : 8 independent hardware sockets Protocols Support : TCP, UDP, IPv4, ICMP, ARP, IGMP, PPPoE Temperature Range : -40¬∞C to +85¬∞C Voltage Supply : 2.97V to 3.63V Power Consumption : 132mA typical Package Options : 48-LQFP (7x7mm) Cost (Volume) : ~$2.00 per unit Development Ecosystem : Extensive documentation, libraries for multiple platforms Manufacturer : WIZnet.io (South Korea) Option B: Microchip ENC28J60 Interface : SPI (up to 20 MHz) Network Speed : 10 Mbps Ethernet only TCP/IP Stack : Software stack required (on microcontroller) Buffer Memory : 8 KB internal buffer Concurrent Connections : Limited by microcontroller implementation Protocols Support : Requires microcontroller implementation (typically lwIP) Temperature Range : 0¬∞C to +70¬∞C (commercial), -40¬∞C to +85¬∞C (industrial version) Voltage Supply : 3.1V to 3.6V Power Consumption : 160mA typical Package Options : 28-pin SPDIP, SOIC, SSOP, QFN Cost (Volume) : ~$2.50 per unit Development Ecosystem : Mature, widely used in Arduino and other platforms Manufacturer : Microchip Technology (USA) PUGH Matrix Analysis Scoring: Better than baseline (+1, +2), Same as baseline (0), Worse than baseline (-1, -2) Baseline: ENC28J60 (all scores = 0) Criteria Weight ENC28J60 W5500 Network Speed 1 0 (baseline) +1 (100 Mbps vs 10 Mbps) TCP/IP Implementation 1 0 (baseline) +1 (hardwired vs software) Microcontroller Overhead 1 0 (baseline) +1 (minimal vs significant) Buffer Size 1 0 (baseline) +1 (32KB vs 8KB) SPI Interface Performance 1 0 (baseline) +1 (80MHz vs 20MHz) Industrial Temperature Range 1 0 (baseline) 0 (standard -40¬∞C to +85¬∞C) Development Ecosystem 1 0 (baseline) 0 (both well-supported) Firmware Complexity 1 0 (baseline) +1 (simple socket programming) Open Internal Firmware 3 0 (baseline) -1 (Complex, Closed Source) Western Manufacturer 3 0 (baseline) -1 (South Korea) Auditable Sourcecode 3 0 (baseline) -2 (Closed Source) Total PUGH Score 1 0 (baseline) -6 Decision Selected: ENC28J60 While the W5500 is technically superior in every aspect and more easy to integrate, the ENC28J60 is a dumb device, which is, given to goal of maximum control, auditable software and upgradeable software, exactly what we want. And additionally it is from a 'western' manufacturer. Rationale Why ENC28J60 Over W5500 Dumb : The ENC28J60 has no complex firmware. Auditable Sourcecode : The main network code is in the microcontrollers firmware, which we have total control over. This allows us to show all relevant code for audits. Western Manufacturer : Because of supply chain considerations we want this project to contain only 'western' manufacturers. While technically South Korea is a western ally, it is still in the east. Trade-offs Accepted Cost Premium : The $0.50 additional cost per unit for the W5500 is justified by the significant performance advantages, reduced development complexity, and system resource savings. Lower Performance : The W5500 is superior in all aspects of performance. But the ENC28J60 is good enough to match the performance criteria. Consequences Positive ‚úÖ Minimal Performance : ENC28J60 provides enough network bandwidth for current needs ‚úÖ Physical Size : 28SSOP package requires slightly less PCB space ‚úÖ Industrial Reliability : Full industrial temperature range support ‚úÖ External Dependency : Reliance on a more generic controller with more alternatives Negative ‚ö†Ô∏è Resource Spending : More microcontroller overhead diminishes resources for other features ‚ö†Ô∏è Slightly Higher Cost : $0.50 cost premium per unit compared to W5500 ‚ö†Ô∏è More Complex Development : Software TCP/IP stack incraeses code complexity and development time Risks and Mitigation Supply Chain Risk : Establish multiple supplier relationships, consider inventory strategy Single-Source Component : Document adaptation path to alternative controllers if necessary Integration Complexity : Thoroughly validate the ENC28J60-RP2350 integration early in development Implementation Notes Performance Optimization Use burst SPI mode for maximum throughput (up to 25 MHz) Optimize buffer management for latency-sensitive applications) Follow-up Actions Procurement : Source ENC28J60 components from multiple suppliers to validate availability Prototyping : Develop initial integration test for RP2350 + ENC28J60 communication Performance Testing : Benchmark SPI communication speeds and TCP throughput Industrial Validation : Test operation across full temperature range Review Notes: &#10063; Validate pricing from multiple suppliers &#10063; Confirm SPI bus configuration with other peripherals &#10063; Verify EMI/EMC considerations with ENC28J60 placement &#10063; Test actual power consumption under various load scenarios "
},

{
    "id": 4,
    "uri": "adrs/ADR-005-buffer-allocation-strategy.html",
    "menu": "adrs",
    "title": "ADR-005: Ring Buffer Memory Allocation Strategy for UART2ETH",
    "text": " Table of Contents ADR-005: Ring Buffer Memory Allocation Strategy for UART2ETH Context Decision Drivers Options Considered PUGH Matrix Analysis Decision Rationale Consequences Implementation Notes Future Optimization Path Alternative Approaches Considered Follow-up Actions ADR-005: Ring Buffer Memory Allocation Strategy for UART2ETH Status: PROPOSED Date: 2025-07-27 Deciders: Architecture Team Consulted: Senior Developer Informed: Development Team Context The UART2ETH system requires a ring buffer allocation strategy for inter-core communication between Core 0 (UART processing) and Core 1 (network processing). Based on our solution strategy (Chapter 4), we use cache-aligned ring buffers with fixed-size entries to enable deterministic, high-performance data transfer. This ADR documents the critical decision between different buffer allocation approaches given our realistic packet size analysis: Maximum payload size : 1024 bytes (worst-case industrial protocol) Minimum payload size : 10 bytes (small sensor readings) Average payload size : 40 bytes (typical industrial data) The buffer allocation strategy directly impacts: Memory efficiency and utilization System determinism and real-time behavior Implementation complexity and maintainability Development timeline and risk This decision is architecturally significant because it affects the fundamental memory model of our dual-core architecture and determines whether we can achieve our non-negotiable requirements within the 520KB SRAM constraints of the RP2350. Decision Drivers Primary Requirements Industrial Reliability : Must enable deterministic, predictable behavior for industrial applications Static Memory Allocation : All memory must be allocated at compile time (no dynamic allocation) Sub-5ms Latency : Latency requirement limits buffering depth, reducing total memory impact Cache-Aligned Performance : Inter-core communication must be optimized for dual-core RP2350 TDD Implementation : Must be testable and maintainable using test-driven development Constraints Limited to 520KB SRAM total on RP2350 platform Static allocation only (no malloc/free) Cache-line alignment required (64-byte boundaries) Maximum 2-3 packets buffered per UART due to latency constraints Must support worst-case 1024-byte payload scenarios Options Considered Option A: Static Worst-Case Allocation (Baseline) Approach : Fixed ring buffer entries sized for maximum payload (1024 bytes + 16 bytes management = 1040 bytes per entry) Memory Usage : Each entry wastes 984 bytes when storing 40-byte average payloads (96% waste) Determinism : Completely predictable, compile-time allocation Implementation Complexity : Minimal - simple fixed-size array Cache Alignment : Straightforward alignment to cache boundaries Testing : Simple to test, no dynamic allocation edge cases Option B: Protocol-Aware Multi-Pool Approach : Three separate buffer pools sized for different payload ranges Small Pool: 64-byte entries (for ‚â§40 byte packets) Medium Pool: 256-byte entries (for 41-200 byte packets) Large Pool: 1024-byte entries (for 201-1024 byte packets) Memory Usage : Significantly more efficient (~20-30% waste vs 96%) Determinism : Still predictable, but requires pool management logic Implementation Complexity : Requires pool allocation logic, protocol size prediction Cache Alignment : More complex alignment across multiple pools Testing : Complex testing scenarios for pool exhaustion, allocation failures Option C: Variable-Length with Fragmentation Approach : Variable-length entries with fragmentation and reassembly Memory Usage : Most efficient possible memory utilization Determinism : Unpredictable due to fragmentation and reassembly timing Implementation Complexity : High - fragmentation logic, reassembly buffers Cache Alignment : Complex alignment with variable sizes Testing : Very complex testing for fragmentation edge cases PUGH Matrix Analysis Scoring: Better than baseline (+1, +2), Same as baseline (0), Worse than baseline (-1, -2) Baseline: Static Worst-Case Allocation (all scores = 0) Criteria Weight Static Worst-Case Multi-Pool Variable-Length Industrial Reliability 3 0 (baseline) -1 (pool management risk) -2 (fragmentation unpredictability) Memory Efficiency 2 0 (baseline) +2 (20-30% waste vs 96%) +2 (optimal utilization) Implementation Simplicity 3 0 (baseline) -1 (pool allocation logic) -2 (fragmentation complexity) Deterministic Behavior 3 0 (baseline) -1 (pool allocation timing) -2 (fragmentation timing) Testing Complexity 2 0 (baseline) -1 (pool edge cases) -2 (fragmentation edge cases) Development Timeline 2 0 (baseline) -1 (additional development) -2 (significant additional work) Cache Optimization 2 0 (baseline) -1 (multi-pool alignment) -2 (variable alignment complexity) Future Maintainability 1 0 (baseline) +1 (documented optimization path) -1 (complex maintenance) Weighted Scores Multi-Pool Total Score: Reliability: 3√ó(-1) = -3 Memory: 2√ó(+2) = +4 Simplicity: 3√ó(-1) = -3 Determinism: 3√ó(-1) = -3 Testing: 2√ó(-1) = -2 Timeline: 2√ó(-1) = -2 Cache: 2√ó(-1) = -2 Maintainability: 1√ó(+1) = +1 Total: -10 Variable-Length Total Score: Reliability: 3√ó(-2) = -6 Memory: 2√ó(+2) = +4 Simplicity: 3√ó(-2) = -6 Determinism: 3√ó(-2) = -6 Testing: 2√ó(-2) = -4 Timeline: 2√ó(-2) = -4 Cache: 2√ó(-2) = -4 Maintainability: 1√ó(-1) = -1 Total: -23 Decision Selected: Static Worst-Case Allocation Despite the significant memory inefficiency (96% waste in typical scenarios), static worst-case allocation scores highest in our weighted analysis due to our reliability-first architecture principles and aggressive sub-5ms latency requirements . Rationale Why Static Allocation Over Multi-Pool (-10 score) Reliability Trumps Efficiency: Industrial reliability is our non-negotiable #1 priority Static allocation provides completely predictable behavior No pool exhaustion scenarios or allocation failures Simpler testing with fewer edge cases Latency Constraint Mitigation: Sub-5ms requirement limits buffer depth to ~2-3 packets maximum Total memory waste: 4 UARTs √ó 3 packets √ó 1024 bytes = ~12KB 12KB waste is acceptable within 520KB total SRAM Implementation Risk Reduction: TDD requirement favors simpler, more testable implementation Aggressive delivery timeline cannot accommodate complex allocation logic Static allocation enables immediate development progress Why Static Allocation Over Variable-Length (-23 score) Variable-length fails completely on reliability and determinism Fragmentation creates unpredictable latency - incompatible with sub-5ms requirement Testing complexity would significantly impact TDD implementation Memory Efficiency Analysis Realistic Memory Impact: Worst-case buffer usage: 4 UARTs √ó 3 packets/UART √ó 1024 bytes/packet = 12KB total Percentage of available SRAM: 12KB / 520KB = 2.3% Total system memory budget impact: Acceptable Latency-Limited Buffering: Sub-5ms latency inherently limits packet accumulation Small buffer depths make absolute memory waste manageable Quality goal (latency) constraints enable architectural simplification Consequences Positive ‚úÖ Industrial Reliability : Completely predictable memory behavior ‚úÖ Development Velocity : Immediate implementation, no complex allocation logic ‚úÖ Testing Simplicity : Straightforward test scenarios, high confidence ‚úÖ Cache Optimization : Simple 64-byte alignment for optimal inter-core performance ‚úÖ Future Flexibility : Clear optimization path documented for later enhancement Negative ‚ùå Memory Inefficiency : 96% waste in typical scenarios (1024B allocated, 40B used) ‚ùå Resource Utilization : Suboptimal use of precious SRAM resource ‚ùå Scalability Limitation : Inefficiency grows with larger maximum packet sizes Risks and Mitigation Primary Risk: Memory Inefficiency Probability : High (96% waste is certain) Impact : Medium (limited by latency constraints to ~12KB total) Mitigation : Document multi-pool optimization path, monitor actual memory usage Secondary Risk: Future Scalability Probability : Low (latency requirements unlikely to change) Impact : Medium (could require architectural changes) Mitigation : Protocol-aware multi-pool approach documented as known optimization Implementation Notes Ring Buffer Entry Structure // Each entry = 1024 bytes payload + 16 bytes management + padding to cache line typedef struct { // Management Data (16 bytes) uint8_t uart_channel; // 0-3 uint8_t direction; // TX/RX uint8_t status; // FILLING/DRAINING/FULL/EMPTY uint8_t payload_length; // Actual data length (‚â§1024) uint32_t timestamp; // Fill timestamp uint32_t sequence_id; // For ordering/debugging uint32_t reserved; // Future use/alignment // Payload Data (1024 bytes fixed) uint8_t payload[1024]; // Fixed maximum size } __attribute__((aligned(64))) ring_entry_t; // Cache-aligned Memory Allocation Strategy Total Buffer Size : (available_memory - static_variables) / sizeof(ring_entry_t) - 1 entries Per-UART Allocation : Dynamic allocation from shared pool based on actual usage Overflow Policy : Drop oldest packets (deterministic behavior) Future Optimization Path When memory efficiency becomes critical (e.g., adding features that require more SRAM), implement Protocol-Aware Multi-Pool allocation: Multi-Pool Implementation Strategy // Future optimization - three separate pools typedef struct { ring_entry_t small_pool[SMALL_POOL_SIZE]; // 64-byte entries ring_entry_t medium_pool[MEDIUM_POOL_SIZE]; // 256-byte entries ring_entry_t large_pool[LARGE_POOL_SIZE]; // 1024-byte entries // Pool allocation logic pool_allocator_t allocator; } multi_pool_ring_buffer_t; Protocol Size Prediction Runtime Analysis : Monitor actual packet sizes during operation Protocol Configuration : Per-UART protocol profiles specifying expected size ranges Adaptive Allocation : Adjust pool usage based on observed patterns Migration Path Phase 1 : Implement size monitoring in current static allocation Phase 2 : Develop pool allocation logic with same interfaces Phase 3 : A/B test multi-pool vs static allocation Phase 4 : Switch to multi-pool if memory pressure requires it Alternative Approaches Considered Per-UART Configurable Sizing Concept : Compile-time configuration of maximum packet size per UART Rejection Reason : Adds complexity without addressing core efficiency problem Example : UART0=64B, UART1=128B, UART2=1024B, UART3=256B Hybrid Static + Overflow Concept : Small static buffers + large overflow buffer for rare large packets Rejection Reason : Violates deterministic behavior requirement Risk : Overflow scenarios create unpredictable timing Follow-up Actions Memory Monitoring : Implement runtime memory usage tracking in debug builds Size Analysis : Log actual packet sizes during development and testing Pool Design : Document detailed multi-pool implementation specifications Performance Validation : Benchmark static allocation performance characteristics Future Review : Schedule memory efficiency review after core implementation Review Notes: &#10063; Validate 12KB memory impact against other system memory requirements &#10063; Confirm cache-line alignment performance benefits on RP2350 &#10063; Review multi-pool optimization trigger conditions &#10063; Document protocol size prediction strategies &#10063; Establish memory usage monitoring in CI/CD pipeline "
},

{
    "id": 5,
    "uri": "arc42/arc42.html",
    "menu": "arc42",
    "title": "image:arc42-logo.png[arc42] Template",
    "text": " Table of Contents Template Architecture Communication Canvas 1. Introduction and Goals 1.1. Requirements Overview 1.2. Quality Goals 1.3. Stakeholders 2. Architecture Constraints 2.1. Technical Constraints 2.2. Organizational Constraints 2.3. Economic Constraints 2.4. Regulatory and Legal Constraints 3. Context and Scope 3.1. System Overview 3.2. System Scope and Boundaries 3.3. Business Context 3.4. Technical Context 3.5. Operating Mode Contexts 3.6. Integration Architecture 3.7. Future State Considerations 4. Solution Strategy 5. Building Block View 5.1. Whitebox Overall System 5.2. Level 2 5.3. Level 3 6. Runtime View 6.1. &lt;Runtime Scenario 1&gt; 6.2. &lt;Runtime Scenario 2&gt; 6.3. &#8230;&#8203; 6.4. &lt;Runtime Scenario n&gt; 7. Deployment View 7.1. Infrastructure Level 1 7.2. Infrastructure Level 2 8. Cross-cutting Concepts 8.1. &lt;Concept 1&gt; 8.2. &lt;Concept 2&gt; 8.3. &lt;Concept n&gt; 9. Architecture Decisions 9.1. Hardware Platform Decisions 9.2. Software Platform Decisions 10. Quality Requirements 10.1. Quality Tree 10.2. Quality Scenarios 11. Risks and Technical Debts 12. Glossary Template .arc42help {font-size:small; width: 14px; height: 16px; overflow: hidden; position: absolute; right: 0; padding: 2px 0 3px 2px;} .arc42help::before {content: \"?\";} .arc42help:hover {width:auto; height: auto; z-index: 100; padding: 10px;} .arc42help:hover::before {content: \"\";} @media print { .arc42help {display:none;} } About arc42 arc42, the template for documentation of software and system architecture. Template Version 8.2 EN. (based upon AsciiDoc version), January 2023 Created, maintained and &#169; by Dr. Peter Hruschka, Dr. Gernot Starke and contributors. See https://arc42.org . :jbake-status: published :jbake-order: 0 :jbake-type: page_toc :jbake-menu: arc42 :jbake-title: Architecture Communication Canvas .canvas ul { margin-left: 0px; padding-left: 1em; list-style: square; } .canvas tr:nth-child(1) td:nth-child(1), .canvas tr:nth-child(1) td:nth-child(2), .canvas tr:nth-child(2) td:nth-child(1), .canvas tr:nth-child(3) td:nth-child(1), .canvas tr:nth-child(4) td:nth-child(1) { background-color: #8fe4b4; border: 1px solid black; } .canvas tr:nth-child(1) td:nth-child(3), .canvas tr:nth-child(1) td:nth-child(4), .canvas tr:nth-child(4) td:nth-child(2) { background-color: #94d7ef; border: 1px solid black; } .canvas tr:nth-child(5) td:nth-child(1), .canvas tr:nth-child(5) td:nth-child(2) { background-color: #ffc7c6; border: 1px solid black; } Architecture Communication Canvas Designed for: UART2ETH Designed by: Development Team Value Proposition Provide a low-cost, open source, western-component based, regulatory-compliant alternative to expensive or black-box UART-to-TCP bridge solutions for adding networking capabilities to legacy equipment. Core Functions Full Bridge mode: Transparent UART over TCP for distant device connections Gateway mode: Add networking capabilities to products without development Up to 4 UARTs exposed as TCP sockets on individual ports Secure OTA firmware updates with A/B update mechanism Custom pluggable serial protocol filters for efficient TCP packaging Package caching with custom transmit timeouts for latency/bulk optimization Core Decisions - Good or Bad Good: RP2350 selection for open ecosystem, long-term support, and secure update capabilities Moving from ATMega328 due to baudrate inflexibility and security limitations Western-only component supply chain for regulatory compliance Bad: No major problematic decisions identified yet Strategic: Anticipating new regulations requiring updateable and auditable firmware Addressing gap left by discontinued commercial solutions Technologies Programming: C/C++ with Arduino framework Development: VSCodium IDE, PlatformIO build system Hardware: RP2350 microcontroller, ENC28J60 SPI Ethernet controller Protocols: Raw TCP sockets, HTTP for WebUI Security: RP2350 Boot ROM provided security mechanisms Infrastructure: GitHub runners for CI/CD Documentation: docToolchain with AsciiDoc Key Stakeholder Industrial engineers dealing with infrastructure challenges (noise, cable length issues) requiring networking solutions for existing equipment System integrators needing regulatory-compliant, ready-to-use networking solutions for their products without custom development Quality Requirements Performance: 500kBaud sustained throughput, &lt;5ms latency Reliability: Critical uptime as long as hardware operates within environmental specifications Security: Prevention of data distortion and lateral network movement attacks Usability: Users need basic understanding of serial communication and TCP/IP Scalability: 1 TCP connection per UART port Compliance: CE certification for hardware Business Context Data Sources: Legacy PLCs, sensors, measurement instruments, and older industrial equipment with serial interfaces but no networking capabilities Data Sinks: SCADA systems, custom data processing software, other UART2ETH devices (in Full Bridge mode) Network Environment: Industrial and household LANs operating at 100Mbit Dependencies: Only requires correctly routed network infrastructure No risky external interfaces or operational costs Components / Modules Hardware Components: * RP2350 microcontroller * Microchip ENC28J60 SPI Ethernet Controller * RJ45 connector with integrated magnetics * Crystal clock source * SPI EEPROM for firmware storage Software Modules: * TCP/IP communication module * UART instance modules (up to 4) * OTA update manager with A/B update support * Protocol filtering/packet splitting engine * Caching module with flexible ring buffer * Configuration management module * Optional WebUI module * PIO-based UART implementation (send/receive tasks on GPIO) Core Risks Primary security risk: Device compromise allowing data distortion or use as attack vector for lateral network movement Hardware component availability and supply chain disruptions Regulatory changes requiring additional compliance measures Performance degradation under high concurrent load scenarios Missing Information Testing framework selection not yet decided Specific cryptographic implementation details for OTA security WebUI design and user experience specifications Detailed protocol filter plugin architecture Performance benchmarking under various network conditions Industrial certification requirements beyond CE marking Software Architecture Canvas by Gernot Starke, Patrick Roos and arc42 Contributors is licensed under Attribution-ShareAlike 4.0 International Note This version of the template contains some help and explanations. It is used for familiarization with arc42 and the understanding of the concepts. For documentation of your own system you use better the plain version. 1. Introduction and Goals Describes the relevant requirements and the driving forces that software architects and development team must consider. These include underlying business goals, essential features, essential functional requirements, quality goals for the architecture and relevant stakeholders and their expectations 1.1. Requirements Overview 1.1.1. Purpose UART2ETH provides a hardware and firmware solution for bridging UART interfaces to TCP sockets, enabling network connectivity for legacy industrial equipment and embedded systems. 1.1.2. Core Functional Requirements Hardware Capabilities: Support up to 4 independent UART interfaces 100Mbit network interface with RJ45 connector Networking Features: Each UART exposed as individual TCP socket on dedicated port Raw TCP socket communication for transparent data transmission Support for concurrent connections (1 TCP connection per UART) Operating Modes: Full Bridge Mode: Transparent UART-over-TCP for remote device connections Gateway Mode: Add networking capabilities to existing products without firmware modifications Firmware Management: Secure Over-The-Air (OTA) firmware updates A/B update mechanism for rollback capability Protocol Optimization: Custom pluggable serial protocol filters for efficient TCP packaging Configurable packet caching with ring buffer implementation Adjustable transmit timeouts for latency or bulk transfer optimization 1.1.3. Target Use Cases Use Case Description Legacy Equipment Integration Connect PLCs, sensors, and measurement instruments to SCADA systems via network Infrastructure Problem Solving Overcome noise and cable length limitations in industrial environments System Integration Add networking to existing products without custom development effort Remote Device Access Enable distant connections to serial devices through Full Bridge mode 1.1.4. Driving Forces Regulatory Compliance: Western-only component supply chain for regulatory compliance Anticipation of new regulations requiring updateable and auditable firmware CE certification requirement for hardware Market Requirements: Address gap left by discontinued commercial UART-to-TCP solutions Provide open source alternative to expensive or black-box commercial products Enable cost-effective networking solutions for system integrators Substantial per-unit cost savings when deploying multiple units in-house compared to commercial alternatives Technical Requirements: 500kBaud sustained throughput capability Sub-5ms latency for real-time applications Critical system uptime within environmental specifications 1.2. Quality Goals The following quality goals are prioritized by importance to our major stakeholders (industrial engineers and system integrators): Priority Quality Goal Concrete Scenario 1 Reliability Critical system uptime for industrial applications A UART2ETH device deployed in a manufacturing line must maintain continuous operation for the duration that the connected hardware operates within environmental specifications. System failure should not occur due to software issues during normal operation. 2 Performance Real-time data transmission capabilities The system must sustain 500kBaud throughput with less than 5ms latency end-to-end. A PLC sending time-critical control data to a SCADA system must not experience delays that could affect industrial process control. 3 Compatibility Seamless integration with diverse industrial systems The system must work reliably with a broad range of custom baud rates and protocol parameters. It should reliably auto-negotiate ethernet connection parameters. 4 Usability Simple deployment without specialized knowledge A system integrator with basic understanding of serial communication and TCP/IP should be able to deploy and configure the device without extensive training. Configuration should be straightforward with clear error messages for common misconfigurations. 5 Maintainability Secure field updates without physical access Firmware updates must be deployable remotely via OTA mechanism with A/B rollback capability. A device installed in a remote location must be updatable without requiring on-site technician visits, while ensuring update integrity and system recovery from failed updates. 1.3. Stakeholders Role/Name Contact Expectations Industrial Engineers End user organizations, manufacturing facilities Clear documentation of network integration capabilities, performance specifications, and compatibility with existing industrial equipment. Need confidence in reliability and uptime guarantees. System Integrators Engineering consultancies, automation solution providers Comprehensive deployment guides, configuration documentation, and troubleshooting procedures. Expect regulatory compliance documentation (CE certification) and clear cost-benefit analysis. Development Team Internal project contributors Detailed architectural decisions, coding standards, build procedures, and testing frameworks. Need clear module interfaces and dependencies for parallel development work. Hardware Engineers PCB designers, component selection specialists Hardware interface specifications, power requirements, environmental constraints, and component selection rationale. Need mechanical and electrical interface documentation. Field Technicians Installation and maintenance personnel Simple installation procedures, diagnostic capabilities, and field troubleshooting guides. Need clear error indicators and recovery procedures for common failure modes. Regulatory Authorities CE certification bodies, industrial standards organizations Compliance documentation, safety analysis, electromagnetic compatibility evidence, and audit trails for component sourcing and manufacturing processes. Open Source Community Contributors, adopters, derivative projects Clear licensing terms (GPL), contribution guidelines, architectural documentation enabling modifications and extensions. Expect maintainable and well-documented code structure. 2. Architecture Constraints Contents Any requirement that constraints software architects in their freedom of design and implementation decisions or decision about the development process. These constraints sometimes go beyond individual systems and are valid for whole organizations and companies. Motivation Architects should know exactly where they are free in their design decisions and where they must adhere to constraints. Constraints must always be dealt with; they may be negotiable, though. Form Simple tables of constraints with explanations. If needed you can subdivide them into technical constraints, organizational and political constraints and conventions (e.g. programming or versioning guidelines, documentation or naming conventions) Further Information See Architecture Constraints in the arc42 documentation. 2.1. Technical Constraints Constraint Description Rationale Hardware Platform Must use RP2350 microcontroller as primary processing unit Provides required security features for OTA updates, sufficient processing power for 4 UART channels, and western supply chain compliance Component Sourcing All components must be sourced from western suppliers only Regulatory compliance requirement for target markets and supply chain security considerations Performance Requirements Minimum 500kBaud sustained throughput with sub-5ms latency per UART channel Industrial application requirements for real-time data transmission Network Interface 100Mbit Ethernet connectivity via SPI-based controller Cost constraints and sufficient bandwidth for target applications while maintaining hardware simplicity UART Channel Limit Maximum 4 independent UART interfaces Hardware resource limitations of chosen microcontroller platform and cost optimization 2.2. Organizational Constraints Constraint Description Rationale Open Source License Complete system must be released under GPL license Leverage existing open source libraries and reduce implementation effort by reusing proven components Development Process Test-driven development (TDD) approach mandatory for all production code Quality assurance and maintainability requirements for industrial application reliability Documentation Standard Architecture documentation must follow arc42 template structure Standardized documentation approach for future maintainers and contributors Version Control GitHub-based development workflow with mandatory pull request reviews Code quality control and collaborative development coordination 2.3. Economic Constraints Constraint Description Rationale Hardware Cost Hardware target price per unit must be significantly below commercially available solutions Competitive market positioning requires substantial cost advantage to justify adoption over established commercial products Development Effort Development effort must achieve return on investment within first year of deployment Resource allocation constraint limits project scope and complexity to ensure economic viability and timely market entry 2.4. Regulatory and Legal Constraints Constraint Description Rationale CE Certification Hardware must achieve CE compliance for European market Legal requirement for commercial deployment in target markets Firmware Security Must implement secure boot and signed firmware update mechanisms Anticipated regulatory requirements for updateable industrial devices EMC Compliance Electromagnetic compatibility requirements for industrial environments Regulatory requirement and operational necessity in electrically noisy industrial settings Export Control No components or technologies subject to export restrictions Unrestricted distribution and deployment capability Patent Avoidance Must not infringe on existing patents in communication protocols or hardware interfaces Legal risk mitigation and freedom to operate requirements 3. Context and Scope Contents Context and scope - as the name suggests - delimits your system (i.e. your scope) from all its communication partners (neighboring systems and users, i.e. the context of your system). It thereby specifies the external interfaces. If necessary, differentiate the business context (domain specific inputs and outputs) from the technical context (channels, protocols, hardware). Motivation The domain interfaces and technical interfaces to communication partners are among your system&#8217;s most critical aspects. Make sure that you completely understand them. Form Various options: Context diagrams Lists of communication partners and their interfaces. Further Information See Context and Scope in the arc42 documentation. 3.1. System Overview UART2ETH operates as a networking bridge that enables legacy industrial equipment with UART interfaces to communicate over TCP/IP networks. The system serves as a critical integration point in industrial automation environments, supporting two distinct operating modes: Gateway Mode : UART2ETH adds networking capabilities to existing Host Systems without requiring firmware modifications. The Host System maintains its original UART-based communication while Client Systems access it via TCP sockets over the network. Full Bridge Mode : UART2ETH provides transparent UART-over-TCP connectivity, allowing two Host Systems with UART interfaces to communicate over network infrastructure as if they were directly connected via serial cable. 3.2. System Scope and Boundaries Inside the System Boundary: RP2350 microcontroller Up to 4 UART interfaces Network interface controller (100Mbit Ethernet) Protocol filtering and optimization engines OTA update mechanism with A/B partitioning Device configuration and management interfaces Outside the System Boundary: Host Systems (PLCs, sensors, measurement instruments) Client Systems (SCADA systems, monitoring applications) Network infrastructure (switches, routers, firewalls) Firmware update servers and management systems 3.3. Business Context 3.3.1. Primary Stakeholders Stakeholder Role Primary Business Interactions Industrial Engineers Solution designers and specifiers Define networking requirements for automation projects, specify UART2ETH configurations for integrating legacy equipment into modern networks System Integrators Implementation specialists Deploy UART2ETH devices in customer facilities, configure networking parameters, integrate with existing SCADA and monitoring systems Field Technicians Installation and maintenance personnel Physical installation of devices, diagnostic troubleshooting, basic configuration changes, routine maintenance procedures Equipment Manufacturers Original equipment makers Embed UART2ETH into products to add networking capabilities, specify custom protocol filters, integrate with product lifecycle management 3.3.2. Business Use Cases Legacy Equipment Integration: Industrial Engineers specify UART2ETH to network aging PLCs, sensors, and measurement instruments that lack modern connectivity. System Integrators deploy these solutions to extend equipment lifecycles and enable remote monitoring without costly equipment replacement. Infrastructure Problem Solving: Field installations requiring long cable runs or operating in electrically noisy environments use UART2ETH to overcome serial communication limitations through network-based transmission. Remote Access Enablement: SCADA systems and monitoring applications access distributed serial devices through UART2ETH bridges, enabling centralized control and data collection across geographically dispersed facilities. 3.4. Technical Context 3.4.1. Technical Interface Specifications Interface Type Technical Details Communication Pattern UART Ports (4x) Host System Interface UART/RS232/RS422, 300-500k baud, configurable parameters Bidirectional serial, protocol-agnostic Ethernet Port Network Interface 100BASE-TX, RJ45 connector, Auto-MDIX TCP/IP networking, DHCP/Static IP TCP Sockets Client Interface Ports configurable, single connection per port TCP client connections, application protocols Management Interface Configuration Interface Web UI (HTTP), configuration interface HTTP, JSON configuration OTA Update Interface Firmware Interface Secure update server, A/B partition management HTTP, signed firmware images 3.4.2. Communication Protocols and Data Formats UART Communication: Raw serial data transmission (protocol-agnostic) Configurable baud rates: 300 bps to 500 kbps Support for custom frame formats and timing requirements Network Communication: TCP socket connections for data transmission JSON for configuration and management data Binary protocol passthrough with optional filtering HTTP for management and OTA updates Network Protocols: IPv4 with DHCP or static configuration NTP for time synchronization DNS for name resolution 3.5. Operating Mode Contexts 3.5.1. Gateway Mode Context Gateway Mode Data Flow: 1. Host System sends serial data using original protocol to UART2ETH 2. UART2ETH receives serial data and applies protocol filtering/optimization 3. Processed data is transmitted to Client Systems via TCP sockets 4. Client Systems send responses back through TCP connections 5. UART2ETH forwards responses to Host System via UART interface 3.5.2. Full Bridge Mode Context Full Bridge Mode Data Flow: 1. Host System A sends serial data to UART2ETH A 2. UART2ETH A encapsulates serial data in TCP packets and transmits over network 3. UART2ETH B receives TCP packets and extracts original serial data 4. UART2ETH B forwards serial data to Host System B via UART 5. Bidirectional communication maintains transparent serial connection 3.6. Integration Architecture 3.6.1. Critical Dependencies Network Infrastructure Dependencies: Reliable Ethernet connectivity for TCP/IP communication Network switches with appropriate bandwidth and latency characteristics DHCP services for automatic IP configuration (or static IP management) Network time synchronization for accurate timestamping Power and Environmental Dependencies: 3.3V-24V power supply within industrial specifications Operating temperature range suitable for industrial environments Protection from electromagnetic interference in industrial settings Security Dependencies: Network firewall configuration to allow necessary TCP ports Firmware signing infrastructure for secure OTA updates Network segmentation appropriate for industrial security requirements 3.6.2. Security and Compliance Boundaries Network Security: Cryptographic signatures for firmware validation and integrity Configurable TCP port ranges to support firewall policies Input validation and sanitization for all network interfaces Industrial Compliance: CE certification for European industrial markets Electromagnetic compatibility (EMC) for industrial environments Component sourcing from Western suppliers for regulatory compliance Audit trail for firmware updates and configuration changes 3.6.3. Performance and Scalability Characteristics Performance Requirements: 500 kbps sustained throughput per UART port Sub-5ms end-to-end latency for real-time applications Concurrent TCP connections (one per UART port) Configurable buffering for latency vs. throughput optimization Scalability Considerations: Up to 4 simultaneous UART-to-TCP bridges per device Network deployment limited by IP address availability and network bandwidth Protocol filtering reduces network traffic for efficient bulk transfers A/B firmware updates enable fleet-wide updates without service interruption 3.7. Future State Considerations 3.7.1. Planned Integrations Enhanced Protocol Support: Additional protocol filters for common industrial protocols (Modbus, DNP3, IEC 61850) HTTPS/TLS on-the-wire encryption Advanced Management Features: Integration with network management systems (SNMP, NETCONF) Enhanced diagnostic and monitoring capabilities 4. Solution Strategy Contents A short summary and explanation of the fundamental decisions and solution strategies, that shape system architecture. It includes technology decisions decisions about the top-level decomposition of the system, e.g. usage of an architectural pattern or design pattern decisions on how to achieve key quality goals relevant organizational decisions, e.g. selecting a development process or delegating certain tasks to third parties. Motivation These decisions form the cornerstones for your architecture. They are the foundation for many other detailed decisions or implementation rules. Form Keep the explanations of such key decisions short. Motivate what was decided and why it was decided that way, based upon problem statement, quality goals and key constraints. Refer to details in the following sections. Further Information See Solution Strategy in the arc42 documentation. 5. Building Block View Content The building block view shows the static decomposition of the system into building blocks (modules, components, subsystems, classes, interfaces, packages, libraries, frameworks, layers, partitions, tiers, functions, macros, operations, data structures, &#8230;&#8203;) as well as their dependencies (relationships, associations, &#8230;&#8203;) This view is mandatory for every architecture documentation. In analogy to a house this is the floor plan . Motivation Maintain an overview of your source code by making its structure understandable through abstraction. This allows you to communicate with your stakeholder on an abstract level without disclosing implementation details. Form The building block view is a hierarchical collection of black boxes and white boxes (see figure below) and their descriptions. Level 1 is the white box description of the overall system together with black box descriptions of all contained building blocks. Level 2 zooms into some building blocks of level 1. Thus it contains the white box description of selected building blocks of level 1, together with black box descriptions of their internal building blocks. Level 3 zooms into selected building blocks of level 2, and so on. Further Information See Building Block View in the arc42 documentation. 5.1. Whitebox Overall System Here you describe the decomposition of the overall system using the following white box template. It contains an overview diagram a motivation for the decomposition black box descriptions of the contained building blocks. For these we offer you alternatives: use one table for a short and pragmatic overview of all contained building blocks and their interfaces use a list of black box descriptions of the building blocks according to the black box template (see below). Depending on your choice of tool this list could be sub-chapters (in text files), sub-pages (in a Wiki) or nested elements (in a modeling tool). (optional:) important interfaces, that are not explained in the black box templates of a building block, but are very important for understanding the white box. Since there are so many ways to specify interfaces why do not provide a specific template for them. In the worst case you have to specify and describe syntax, semantics, protocols, error handling, restrictions, versions, qualities, necessary compatibilities and many things more. In the best case you will get away with examples or simple signatures. &lt;Overview Diagram&gt; Motivation &lt;text explanation&gt; Contained Building Blocks &lt;Description of contained building block (black boxes)&gt; Important Interfaces &lt;Description of important interfaces&gt; Insert your explanations of black boxes from level 1: If you use tabular form you will only describe your black boxes with name and responsibility according to the following schema: Name Responsibility &lt;black box 1&gt; ¬† &lt;Text&gt; &lt;black box 2&gt; ¬† &lt;Text&gt; If you use a list of black box descriptions then you fill in a separate black box template for every important building block . Its headline is the name of the black box. 5.1.1. &lt;Name black box 1&gt; Here you describe &lt;black box 1&gt; according the the following black box template: Purpose/Responsibility Interface(s), when they are not extracted as separate paragraphs. This interfaces may include qualities and performance characteristics. (Optional) Quality-/Performance characteristics of the black box, e.g.availability, run time behavior, &#8230;&#8203;. (Optional) directory/file location (Optional) Fulfilled requirements (if you need traceability to requirements). (Optional) Open issues/problems/risks &lt;Purpose/Responsibility&gt; &lt;Interface(s)&gt; &lt;(Optional) Quality/Performance Characteristics&gt; &lt;(Optional) Directory/File Location&gt; &lt;(Optional) Fulfilled Requirements&gt; &lt;(optional) Open Issues/Problems/Risks&gt; 5.1.2. &lt;Name black box 2&gt; &lt;black box template&gt; 5.1.3. &lt;Name black box n&gt; &lt;black box template&gt; 5.1.4. &lt;Name interface 1&gt; &#8230;&#8203; 5.1.5. &lt;Name interface m&gt; 5.2. Level 2 Here you can specify the inner structure of (some) building blocks from level 1 as white boxes. You have to decide which building blocks of your system are important enough to justify such a detailed description. Please prefer relevance over completeness. Specify important, surprising, risky, complex or volatile building blocks. Leave out normal, simple, boring or standardized parts of your system 5.2.1. White Box &lt;building block 1&gt; &#8230;&#8203;describes the internal structure of building block 1 . &lt;white box template&gt; 5.2.2. White Box &lt;building block 2&gt; &lt;white box template&gt; &#8230;&#8203; 5.2.3. White Box &lt;building block m&gt; &lt;white box template&gt; 5.3. Level 3 Here you can specify the inner structure of (some) building blocks from level 2 as white boxes. When you need more detailed levels of your architecture please copy this part of arc42 for additional levels. 5.3.1. White Box &lt;_building block x.1_&gt; Specifies the internal structure of building block x.1 . &lt;white box template&gt; 5.3.2. White Box &lt;_building block x.2_&gt; &lt;white box template&gt; 5.3.3. White Box &lt;_building block y.1_&gt; &lt;white box template&gt; 6. Runtime View Contents The runtime view describes concrete behavior and interactions of the system‚Äôs building blocks in form of scenarios from the following areas: important use cases or features: how do building blocks execute them? interactions at critical external interfaces: how do building blocks cooperate with users and neighboring systems? operation and administration: launch, start-up, stop error and exception scenarios Remark: The main criterion for the choice of possible scenarios (sequences, workflows) is their architectural relevance . It is not important to describe a large number of scenarios. You should rather document a representative selection. Motivation You should understand how (instances of) building blocks of your system perform their job and communicate at runtime. You will mainly capture scenarios in your documentation to communicate your architecture to stakeholders that are less willing or able to read and understand the static models (building block view, deployment view). Form There are many notations for describing scenarios, e.g. numbered list of steps (in natural language) activity diagrams or flow charts sequence diagrams BPMN or EPCs (event process chains) state machines &#8230;&#8203; Further Information See Runtime View in the arc42 documentation. 6.1. &lt;Runtime Scenario 1&gt; &lt;insert runtime diagram or textual description of the scenario&gt; &lt;insert description of the notable aspects of the interactions between the building block instances depicted in this diagram.&gt; 6.2. &lt;Runtime Scenario 2&gt; 6.3. &#8230;&#8203; 6.4. &lt;Runtime Scenario n&gt; 7. Deployment View Content The deployment view describes: technical infrastructure used to execute your system, with infrastructure elements like geographical locations, environments, computers, processors, channels and net topologies as well as other infrastructure elements and mapping of (software) building blocks to that infrastructure elements. Often systems are executed in different environments, e.g. development environment, test environment, production environment. In such cases you should document all relevant environments. Especially document a deployment view if your software is executed as distributed system with more than one computer, processor, server or container or when you design and construct your own hardware processors and chips. From a software perspective it is sufficient to capture only those elements of an infrastructure that are needed to show a deployment of your building blocks. Hardware architects can go beyond that and describe an infrastructure to any level of detail they need to capture. Motivation Software does not run without hardware. This underlying infrastructure can and will influence a system and/or some cross-cutting concepts. Therefore, there is a need to know the infrastructure. Form Maybe a highest level deployment diagram is already contained in section 3.2. as technical context with your own infrastructure as ONE black box. In this section one can zoom into this black box using additional deployment diagrams: UML offers deployment diagrams to express that view. Use it, probably with nested diagrams, when your infrastructure is more complex. When your (hardware) stakeholders prefer other kinds of diagrams rather than a deployment diagram, let them use any kind that is able to show nodes and channels of the infrastructure. Further Information See Deployment View in the arc42 documentation. 7.1. Infrastructure Level 1 Describe (usually in a combination of diagrams, tables, and text): distribution of a system to multiple locations, environments, computers, processors, .., as well as physical connections between them important justifications or motivations for this deployment structure quality and/or performance features of this infrastructure mapping of software artifacts to elements of this infrastructure For multiple environments or alternative deployments please copy and adapt this section of arc42 for all relevant environments. &lt;Overview Diagram&gt; Motivation &lt;explanation in text form&gt; Quality and/or Performance Features &lt;explanation in text form&gt; Mapping of Building Blocks to Infrastructure &lt;description of the mapping&gt; 7.2. Infrastructure Level 2 Here you can include the internal structure of (some) infrastructure elements from level 1. Please copy the structure from level 1 for each selected element. 7.2.1. &lt;Infrastructure Element 1&gt; &lt;diagram + explanation&gt; 7.2.2. &lt;Infrastructure Element 2&gt; &lt;diagram + explanation&gt; &#8230;&#8203; 7.2.3. &lt;Infrastructure Element n&gt; &lt;diagram + explanation&gt; 8. Cross-cutting Concepts Content This section describes overall, principal regulations and solution ideas that are relevant in multiple parts (= cross-cutting) of your system. Such concepts are often related to multiple building blocks. They can include many different topics, such as models, especially domain models architecture or design patterns rules for using specific technology principal, often technical decisions of an overarching (= cross-cutting) nature implementation rules Motivation Concepts form the basis for conceptual integrity (consistency, homogeneity) of the architecture. Thus, they are an important contribution to achieve inner qualities of your system. Some of these concepts cannot be assigned to individual building blocks, e.g. security or safety. Form The form can be varied: concept papers with any kind of structure cross-cutting model excerpts or scenarios using notations of the architecture views sample implementations, especially for technical concepts reference to typical usage of standard frameworks (e.g. using Hibernate for object/relational mapping) Structure A potential (but not mandatory) structure for this section could be: Domain concepts User Experience concepts (UX) Safety and security concepts Architecture and design patterns \"Under-the-hood\" development concepts operational concepts Note: it might be difficult to assign individual concepts to one specific topic on this list. Further Information See Concepts in the arc42 documentation. 8.1. &lt;Concept 1&gt; &lt;explanation&gt; 8.2. &lt;Concept 2&gt; &lt;explanation&gt; &#8230;&#8203; 8.3. &lt;Concept n&gt; &lt;explanation&gt; 9. Architecture Decisions Contents Important, expensive, large scale or risky architecture decisions including rationales. With \"decisions\" we mean selecting one alternative based on given criteria. Please use your judgement to decide whether an architectural decision should be documented here in this central section or whether you better document it locally (e.g. within the white box template of one building block). Avoid redundancy. Refer to section 4, where you already captured the most important decisions of your architecture. Motivation Stakeholders of your system should be able to comprehend and retrace your decisions. Form Various options: ADR ( Documenting Architecture Decisions ) for every important decision List or table, ordered by importance and consequences or: more detailed in form of separate sections per decision Further Information See Architecture Decisions in the arc42 documentation. There you will find links and examples about ADR. This section references the Architecture Decision Records (ADRs) that document key technical decisions for the UART2ETH project. 9.1. Hardware Platform Decisions ADR-001: Microcontroller Platform Selection - Documents the decision to use the Raspberry Pi RP2350 as the core microcontroller platform. ADR-002: Ethernet Controller Selection - Documents the decision to use the ENC28J60 as the Ethernet controller. 9.2. Software Platform Decisions ADR-003: Programming Language Selection - Documents the decision to use C programming language for firmware development, considering team expertise, delivery timeline, and memory model constraints. These decisions form the foundation of the hardware and software architecture and significantly influence the system&#8217;s capabilities, performance characteristics, and development approach. 10. Quality Requirements Content This section contains all quality requirements as quality tree with scenarios. The most important ones have already been described in section 1.2. (quality goals) Here you can also capture quality requirements with lesser priority, which will not create high risks when they are not fully achieved. Motivation Since quality requirements will have a lot of influence on architectural decisions you should know for every stakeholder what is really important to them, concrete and measurable. Further Information See Quality Requirements in the arc42 documentation. 10.1. Quality Tree Content The quality tree (as defined in ATAM ‚Äì Architecture Tradeoff Analysis Method) with quality/evaluation scenarios as leafs. Motivation The tree structure with priorities provides an overview for a sometimes large number of quality requirements. Form The quality tree is a high-level overview of the quality goals and requirements: tree-like refinement of the term \"quality\". Use \"quality\" or \"usefulness\" as a root a mind map with quality categories as main branches In any case the tree should include links to the scenarios of the following section. 10.2. Quality Scenarios Contents Concretization of (sometimes vague or implicit) quality requirements using (quality) scenarios. These scenarios describe what should happen when a stimulus arrives at the system. For architects, two kinds of scenarios are important: Usage scenarios (also called application scenarios or use case scenarios) describe the system‚Äôs runtime reaction to a certain stimulus. This also includes scenarios that describe the system‚Äôs efficiency or performance. Example: The system reacts to a user‚Äôs request within one second. Change scenarios describe a modification of the system or of its immediate environment. Example: Additional functionality is implemented or requirements for a quality attribute change. Motivation Scenarios make quality requirements concrete and allow to more easily measure or decide whether they are fulfilled. Especially when you want to assess your architecture using methods like ATAM you need to describe your quality goals (from section 1.2) more precisely down to a level of scenarios that can be discussed and evaluated. Form Tabular or free form text. 11. Risks and Technical Debts Contents A list of identified technical risks or technical debts, ordered by priority Motivation ‚ÄúRisk management is project management for grown-ups‚Äù (Tim Lister, Atlantic Systems Guild.) This should be your motto for systematic detection and evaluation of risks and technical debts in the architecture, which will be needed by management stakeholders (e.g. project managers, product owners) as part of the overall risk analysis and measurement planning. Form List of risks and/or technical debts, probably including suggested measures to minimize, mitigate or avoid risks or reduce technical debts. Further Information See Risks and Technical Debt in the arc42 documentation. 12. Glossary Contents The most important domain and technical terms that your stakeholders use when discussing the system. You can also see the glossary as source for translations if you work in multi-language teams. Motivation You should clearly define your terms, so that all stakeholders have an identical understanding of these terms do not use synonyms and homonyms Form A table with columns &lt;Term&gt; and &lt;Definition&gt;. Potentially more columns in case you need translations. Further Information See Glossary in the arc42 documentation. Term Definition A/B Updates Dual partition firmware update strategy that maintains two separate flash memory partitions (A and B) containing different firmware versions. During updates, the new firmware is written to the inactive partition while the system continues running from the active partition. If the new firmware fails or becomes corrupted, the system can automatically rollback to the previous working version, ensuring system reliability and preventing brick situations in remote deployments. Arduino Open-source electronics platform consisting of both hardware boards (microcontroller development boards) and software (integrated development environment). Arduino provides a simplified programming framework with pre-built libraries and functions that abstract complex microcontroller operations, making embedded programming accessible to beginners while remaining powerful enough for professional applications. The Arduino ecosystem includes thousands of community-contributed libraries and shields (expansion boards). CI/CD Continuous Integration/Continuous Deployment - modern software development methodology that automates the building, testing, and deployment pipeline. CI automatically builds and tests code changes when developers commit to version control, catching integration issues early. CD extends this by automatically deploying tested code to production environments, reducing manual errors and enabling rapid, reliable software releases. Client System In Gateway Mode, the networked device or application that connects to UART2ETH via TCP sockets to communicate with legacy serial equipment. Client systems can be computers, servers, mobile devices, or other networked equipment that need to access serial devices remotely over Ethernet networks. Examples include monitoring software, configuration tools, or remote control applications. CMake Cross-platform, open-source build system generator that creates native build files (Makefiles, Visual Studio projects, Xcode projects) from platform-independent configuration files. CMake manages complex build dependencies, compiler flags, and linking requirements across different operating systems and compilers, simplifying the build process for C/C++ projects and enabling consistent builds across development teams. ENC28J60 Low-cost Ethernet controller chip from Microchip Technology that provides 10Base-T Ethernet connectivity via SPI interface. This single-chip solution includes MAC (Media Access Control) and PHY (Physical Layer) functions, making it popular for adding basic Ethernet capabilities to microcontroller projects. It requires external TCP/IP stack implementation and offers a cost-effective alternative to more integrated solutions. Full Bridge Mode UART2ETH operating mode that creates a transparent network bridge between two serial devices located at different physical locations. Both devices communicate through their UART interfaces as if they were directly connected with a serial cable, but the connection is actually routed through TCP/IP networks. This mode enables legacy serial equipment to communicate across long distances, through existing network infrastructure, without requiring protocol modifications. Gateway Mode UART2ETH operating mode that adds network connectivity to existing serial-only equipment without modifying the original device. The UART2ETH device acts as a protocol gateway, translating between the legacy device&#8217;s serial communication and modern TCP/IP networking. This allows multiple network clients to simultaneously access serial equipment, enabling remote monitoring, configuration, and control of industrial equipment, embedded systems, or test instruments. Host System The serial equipment or device connected to UART2ETH&#8217;s physical UART interface. In Gateway Mode, this is typically legacy industrial equipment, embedded systems, or test instruments that only support serial communication. In Full Bridge Mode, both endpoints are considered Host Systems. Host Systems are unaware of the network translation and continue using their native serial protocols. HW UART Hardware Universal Asynchronous Receiver-Transmitter - dedicated silicon circuitry within microcontrollers that handles serial communication at the hardware level. HW UARTs provide precise timing, automatic start/stop bit handling, parity checking, and interrupt generation without CPU intervention. This contrasts with software-based UART implementations that consume CPU cycles and may have timing limitations, especially at higher baud rates. Misra-c Motor Industry Software Reliability Association C - comprehensive coding standard that defines strict guidelines for writing safety-critical C code. MISRA-C rules cover language subset restrictions, coding practices, and documentation requirements designed to eliminate common programming errors, undefined behaviors, and implementation-defined constructs. Originally developed for automotive software, it&#8217;s now widely used in aerospace, medical devices, and industrial control systems. OTA (Over-The-Air) Remote firmware update mechanism that allows devices to receive and install new firmware through their existing communication channels (WiFi, Ethernet, cellular) without requiring physical access. OTA updates enable field devices to receive bug fixes, security patches, and feature updates remotely, reducing maintenance costs and enabling rapid deployment of improvements across device fleets. Critical for IoT devices in remote or inaccessible locations. PIO Programmable Input/Output - specialized hardware feature of the Raspberry Pi RP2350 microcontroller that provides highly flexible, real-time I/O processing independent of the main CPU cores. PIO consists of state machines that can execute custom assembly-like programs to handle precise timing requirements for protocols like WS2812 LEDs, custom serial formats, or parallel interfaces. Each PIO block can run multiple state machines simultaneously, enabling complex I/O operations without CPU intervention. PLC (Programmable Logic Controller) Industrial computer designed for automation of manufacturing processes, machinery control, and industrial monitoring systems. PLCs are ruggedized for harsh industrial environments and provide real-time control with deterministic response times. They typically use ladder logic programming and offer extensive I/O capabilities for sensors, actuators, and communication networks. Common in factory automation, process control, and building management systems. platformio Modern, open-source ecosystem for embedded and IoT development that provides unified tooling across multiple microcontroller platforms, frameworks, and boards. PlatformIO includes cross-platform IDE, library manager, unit testing framework, remote debugging capabilities, and continuous integration support. It abstracts away toolchain complexity while supporting hundreds of development boards and frameworks including Arduino, ESP-IDF, STM32, and many others. Protocol Filter Pluggable software component within UART2ETH that intelligently processes and optimizes serial data streams before TCP transmission. Protocol filters can implement packet framing, data compression, error correction, or protocol-specific optimizations to reduce network bandwidth, improve latency, or enhance reliability. Examples include buffering strategies for bulk data transfers, real-time filtering for control systems, or custom packet structures for specific industrial protocols. RPI RP2350 Second-generation microcontroller chip from Raspberry Pi Foundation featuring dual ARM Cortex-M33 cores running up to 150MHz, 520KB SRAM, advanced security features, and flexible I/O capabilities including PIO state machines. The RP2350 provides enhanced performance and security compared to the original RP2040, making it suitable for industrial applications requiring real-time processing, secure communications, and complex I/O handling. SCADA (Supervisory Control and Data Acquisition) Industrial control system architecture used for monitoring and controlling large-scale processes across multiple locations. SCADA systems collect data from remote sensors and equipment, provide centralized monitoring through human-machine interfaces (HMIs), and enable operators to control distributed processes. Common in utilities (power grids, water treatment), manufacturing, and transportation systems where real-time monitoring and control of geographically dispersed equipment is essential. SPI Ethernet Controller Ethernet controller chip that communicates with microcontrollers through the Serial Peripheral Interface (SPI) protocol rather than parallel buses. These controllers handle the complex Ethernet physical layer operations (signal encoding, collision detection, carrier sensing) while presenting a simple SPI interface to the host microcontroller. This approach reduces pin count requirements and simplifies PCB design while providing reliable network connectivity for embedded systems. SPI TCP/IP Controller Integrated circuit that implements the complete TCP/IP protocol stack in hardware and communicates with host microcontrollers via SPI interface. These chips handle all network protocol processing (IP, TCP, UDP, ARP, DHCP) independently, presenting socket-based APIs through SPI commands. This offloads complex network processing from the main microcontroller, simplifying firmware development and improving real-time performance for applications requiring both networking and real-time control. TCP Socket Network communication endpoint that provides reliable, ordered, and error-checked delivery of data streams between applications over IP networks. TCP sockets establish connections, handle flow control, retransmission of lost packets, and ensure data integrity through checksums and acknowledgments. Unlike UDP, TCP guarantees that data arrives in the correct order and without errors, making it essential for applications requiring reliable data transmission such as file transfers, web browsing, and industrial control protocols. UART (Universal Asynchronous Receiver-Transmitter) Serial communication protocol and hardware interface that transmits data character by character without requiring a shared clock signal between communicating devices. UART uses start and stop bits to frame each character, with configurable data bits (5-9), parity (none, even, odd), and stop bits (1, 1.5, 2). This asynchronous approach makes UART simple to implement and widely compatible, leading to its extensive use in embedded systems, industrial equipment, and debugging interfaces. UART2ETH Complete hardware and firmware solution that bridges between UART serial interfaces and TCP/IP Ethernet networks, supporting up to 4 simultaneous UART connections. The system provides bidirectional data translation, protocol filtering, secure OTA updates, and flexible operating modes (Gateway and Full Bridge) to enable legacy serial equipment integration with modern networks. Built on the RPI RP2350 platform with support for various Ethernet controller options. W5500 Fully integrated Ethernet controller from WIZnet that combines 10/100 Ethernet MAC, PHY, and a complete TCP/IP protocol stack in a single chip. The W5500 communicates with host microcontrollers via SPI and provides hardware-accelerated socket operations, automatic packet processing, and wake-on-LAN capabilities. Its integrated approach simplifies network integration for embedded systems by handling all low-level networking operations transparently, allowing developers to focus on application logic rather than network protocols. "
},

{
    "id": 6,
    "uri": "arc42/src/08_concepts.html",
    "menu": "arc42",
    "title": "Cross-cutting Concepts",
    "text": " Table of Contents Cross-cutting Concepts &lt;Concept 1&gt; &lt;Concept 2&gt; &lt;Concept n&gt; Cross-cutting Concepts &lt;Concept 1&gt; &lt;explanation&gt; &lt;Concept 2&gt; &lt;explanation&gt; &#8230;&#8203; &lt;Concept n&gt; &lt;explanation&gt; "
},

{
    "id": 7,
    "uri": "arc42/src/03_context_and_scope.html",
    "menu": "arc42",
    "title": "Context and Scope",
    "text": " Table of Contents Context and Scope System Overview System Scope and Boundaries Business Context Technical Context Operating Mode Contexts Integration Architecture Future State Considerations Context and Scope System Overview UART2ETH operates as a networking bridge that enables legacy industrial equipment with UART interfaces to communicate over TCP/IP networks. The system serves as a critical integration point in industrial automation environments, supporting two distinct operating modes: Gateway Mode : UART2ETH adds networking capabilities to existing Host Systems without requiring firmware modifications. The Host System maintains its original UART-based communication while Client Systems access it via TCP sockets over the network. Full Bridge Mode : UART2ETH provides transparent UART-over-TCP connectivity, allowing two Host Systems with UART interfaces to communicate over network infrastructure as if they were directly connected via serial cable. System Scope and Boundaries Inside the System Boundary: RP2350 microcontroller Up to 4 UART interfaces Network interface controller (100Mbit Ethernet) Protocol filtering and optimization engines OTA update mechanism with A/B partitioning Device configuration and management interfaces Outside the System Boundary: Host Systems (PLCs, sensors, measurement instruments) Client Systems (SCADA systems, monitoring applications) Network infrastructure (switches, routers, firewalls) Firmware update servers and management systems Business Context Primary Stakeholders Stakeholder Role Primary Business Interactions Industrial Engineers Solution designers and specifiers Define networking requirements for automation projects, specify UART2ETH configurations for integrating legacy equipment into modern networks System Integrators Implementation specialists Deploy UART2ETH devices in customer facilities, configure networking parameters, integrate with existing SCADA and monitoring systems Field Technicians Installation and maintenance personnel Physical installation of devices, diagnostic troubleshooting, basic configuration changes, routine maintenance procedures Equipment Manufacturers Original equipment makers Embed UART2ETH into products to add networking capabilities, specify custom protocol filters, integrate with product lifecycle management Business Use Cases Legacy Equipment Integration: Industrial Engineers specify UART2ETH to network aging PLCs, sensors, and measurement instruments that lack modern connectivity. System Integrators deploy these solutions to extend equipment lifecycles and enable remote monitoring without costly equipment replacement. Infrastructure Problem Solving: Field installations requiring long cable runs or operating in electrically noisy environments use UART2ETH to overcome serial communication limitations through network-based transmission. Remote Access Enablement: SCADA systems and monitoring applications access distributed serial devices through UART2ETH bridges, enabling centralized control and data collection across geographically dispersed facilities. Technical Context Technical Interface Specifications Interface Type Technical Details Communication Pattern UART Ports (4x) Host System Interface UART/RS232/RS422, 300-500k baud, configurable parameters Bidirectional serial, protocol-agnostic Ethernet Port Network Interface 100BASE-TX, RJ45 connector, Auto-MDIX TCP/IP networking, DHCP/Static IP TCP Sockets Client Interface Ports configurable, single connection per port TCP client connections, application protocols Management Interface Configuration Interface Web UI (HTTP), configuration interface HTTP, JSON configuration OTA Update Interface Firmware Interface Secure update server, A/B partition management HTTP, signed firmware images Communication Protocols and Data Formats UART Communication: Raw serial data transmission (protocol-agnostic) Configurable baud rates: 300 bps to 500 kbps Support for custom frame formats and timing requirements Network Communication: TCP socket connections for data transmission JSON for configuration and management data Binary protocol passthrough with optional filtering HTTP for management and OTA updates Network Protocols: IPv4 with DHCP or static configuration NTP for time synchronization DNS for name resolution Operating Mode Contexts Gateway Mode Context Gateway Mode Data Flow: 1. Host System sends serial data using original protocol to UART2ETH 2. UART2ETH receives serial data and applies protocol filtering/optimization 3. Processed data is transmitted to Client Systems via TCP sockets 4. Client Systems send responses back through TCP connections 5. UART2ETH forwards responses to Host System via UART interface Full Bridge Mode Context Full Bridge Mode Data Flow: 1. Host System A sends serial data to UART2ETH A 2. UART2ETH A encapsulates serial data in TCP packets and transmits over network 3. UART2ETH B receives TCP packets and extracts original serial data 4. UART2ETH B forwards serial data to Host System B via UART 5. Bidirectional communication maintains transparent serial connection Integration Architecture Critical Dependencies Network Infrastructure Dependencies: Reliable Ethernet connectivity for TCP/IP communication Network switches with appropriate bandwidth and latency characteristics DHCP services for automatic IP configuration (or static IP management) Network time synchronization for accurate timestamping Power and Environmental Dependencies: 3.3V-24V power supply within industrial specifications Operating temperature range suitable for industrial environments Protection from electromagnetic interference in industrial settings Security Dependencies: Network firewall configuration to allow necessary TCP ports Firmware signing infrastructure for secure OTA updates Network segmentation appropriate for industrial security requirements Security and Compliance Boundaries Network Security: Cryptographic signatures for firmware validation and integrity Configurable TCP port ranges to support firewall policies Input validation and sanitization for all network interfaces Industrial Compliance: CE certification for European industrial markets Electromagnetic compatibility (EMC) for industrial environments Component sourcing from Western suppliers for regulatory compliance Audit trail for firmware updates and configuration changes Performance and Scalability Characteristics Performance Requirements: 500 kbps sustained throughput per UART port Sub-5ms end-to-end latency for real-time applications Concurrent TCP connections (one per UART port) Configurable buffering for latency vs. throughput optimization Scalability Considerations: Up to 4 simultaneous UART-to-TCP bridges per device Network deployment limited by IP address availability and network bandwidth Protocol filtering reduces network traffic for efficient bulk transfers A/B firmware updates enable fleet-wide updates without service interruption Future State Considerations Planned Integrations Enhanced Protocol Support: Additional protocol filters for common industrial protocols (Modbus, DNP3, IEC 61850) HTTPS/TLS on-the-wire encryption Advanced Management Features: Integration with network management systems (SNMP, NETCONF) Enhanced diagnostic and monitoring capabilities "
},

{
    "id": 8,
    "uri": "arc42/src/09_architecture_decisions.html",
    "menu": "arc42",
    "title": "Architecture Decisions",
    "text": " Table of Contents Architecture Decisions Hardware Platform Decisions Software Platform Decisions Architecture Decisions This section references the Architecture Decision Records (ADRs) that document key technical decisions for the UART2ETH project. Hardware Platform Decisions ADR-001: Microcontroller Platform Selection - Documents the decision to use the Raspberry Pi RP2350 as the core microcontroller platform. ADR-002: Ethernet Controller Selection - Documents the decision to use the ENC28J60 as the Ethernet controller. Software Platform Decisions ADR-003: Programming Language Selection - Documents the decision to use C programming language for firmware development, considering team expertise, delivery timeline, and memory model constraints. These decisions form the foundation of the hardware and software architecture and significantly influence the system&#8217;s capabilities, performance characteristics, and development approach. "
},

{
    "id": 9,
    "uri": "arc42/src/06_runtime_view.html",
    "menu": "arc42",
    "title": "Runtime View",
    "text": " Table of Contents Runtime View &lt;Runtime Scenario 1&gt; &lt;Runtime Scenario 2&gt; &#8230;&#8203; &lt;Runtime Scenario n&gt; Runtime View &lt;Runtime Scenario 1&gt; &lt;insert runtime diagram or textual description of the scenario&gt; &lt;insert description of the notable aspects of the interactions between the building block instances depicted in this diagram.&gt; &lt;Runtime Scenario 2&gt; &#8230;&#8203; &lt;Runtime Scenario n&gt; "
},

{
    "id": 10,
    "uri": "arc42/src/01_introduction_and_goals.html",
    "menu": "arc42",
    "title": "Introduction and Goals",
    "text": " Table of Contents Introduction and Goals Requirements Overview Quality Goals Stakeholders Introduction and Goals Requirements Overview Purpose UART2ETH provides a hardware and firmware solution for bridging UART interfaces to TCP sockets, enabling network connectivity for legacy industrial equipment and embedded systems. Core Functional Requirements Hardware Capabilities: Support up to 4 independent UART interfaces 100Mbit network interface with RJ45 connector Networking Features: Each UART exposed as individual TCP socket on dedicated port Raw TCP socket communication for transparent data transmission Support for concurrent connections (1 TCP connection per UART) Operating Modes: Full Bridge Mode: Transparent UART-over-TCP for remote device connections Gateway Mode: Add networking capabilities to existing products without firmware modifications Firmware Management: Secure Over-The-Air (OTA) firmware updates A/B update mechanism for rollback capability Protocol Optimization: Custom pluggable serial protocol filters for efficient TCP packaging Configurable packet caching with ring buffer implementation Adjustable transmit timeouts for latency or bulk transfer optimization Target Use Cases Use Case Description Legacy Equipment Integration Connect PLCs, sensors, and measurement instruments to SCADA systems via network Infrastructure Problem Solving Overcome noise and cable length limitations in industrial environments System Integration Add networking to existing products without custom development effort Remote Device Access Enable distant connections to serial devices through Full Bridge mode Driving Forces Regulatory Compliance: Western-only component supply chain for regulatory compliance Anticipation of new regulations requiring updateable and auditable firmware CE certification requirement for hardware Market Requirements: Address gap left by discontinued commercial UART-to-TCP solutions Provide open source alternative to expensive or black-box commercial products Enable cost-effective networking solutions for system integrators Substantial per-unit cost savings when deploying multiple units in-house compared to commercial alternatives Technical Requirements: 500kBaud sustained throughput capability Sub-5ms latency for real-time applications Critical system uptime within environmental specifications Quality Goals The following quality goals are prioritized by importance to our major stakeholders (industrial engineers and system integrators): Priority Quality Goal Concrete Scenario 1 Reliability Critical system uptime for industrial applications A UART2ETH device deployed in a manufacturing line must maintain continuous operation for the duration that the connected hardware operates within environmental specifications. System failure should not occur due to software issues during normal operation. 2 Performance Real-time data transmission capabilities The system must sustain 500kBaud throughput with less than 5ms latency end-to-end. A PLC sending time-critical control data to a SCADA system must not experience delays that could affect industrial process control. 3 Compatibility Seamless integration with diverse industrial systems The system must work reliably with a broad range of custom baud rates and protocol parameters. It should reliably auto-negotiate ethernet connection parameters. 4 Usability Simple deployment without specialized knowledge A system integrator with basic understanding of serial communication and TCP/IP should be able to deploy and configure the device without extensive training. Configuration should be straightforward with clear error messages for common misconfigurations. 5 Maintainability Secure field updates without physical access Firmware updates must be deployable remotely via OTA mechanism with A/B rollback capability. A device installed in a remote location must be updatable without requiring on-site technician visits, while ensuring update integrity and system recovery from failed updates. Stakeholders Role/Name Contact Expectations Industrial Engineers End user organizations, manufacturing facilities Clear documentation of network integration capabilities, performance specifications, and compatibility with existing industrial equipment. Need confidence in reliability and uptime guarantees. System Integrators Engineering consultancies, automation solution providers Comprehensive deployment guides, configuration documentation, and troubleshooting procedures. Expect regulatory compliance documentation (CE certification) and clear cost-benefit analysis. Development Team Internal project contributors Detailed architectural decisions, coding standards, build procedures, and testing frameworks. Need clear module interfaces and dependencies for parallel development work. Hardware Engineers PCB designers, component selection specialists Hardware interface specifications, power requirements, environmental constraints, and component selection rationale. Need mechanical and electrical interface documentation. Field Technicians Installation and maintenance personnel Simple installation procedures, diagnostic capabilities, and field troubleshooting guides. Need clear error indicators and recovery procedures for common failure modes. Regulatory Authorities CE certification bodies, industrial standards organizations Compliance documentation, safety analysis, electromagnetic compatibility evidence, and audit trails for component sourcing and manufacturing processes. Open Source Community Contributors, adopters, derivative projects Clear licensing terms (GPL), contribution guidelines, architectural documentation enabling modifications and extensions. Expect maintainable and well-documented code structure. "
},

{
    "id": 11,
    "uri": "arc42/src/11_technical_risks.html",
    "menu": "arc42",
    "title": "Risks and Technical Debts",
    "text": " Table of Contents Risks and Technical Debts Risks and Technical Debts "
},

{
    "id": 12,
    "uri": "arc42/src/12_glossary.html",
    "menu": "arc42",
    "title": "Glossary",
    "text": " Table of Contents Glossary Glossary Term Definition A/B Updates Dual partition firmware update strategy that maintains two separate flash memory partitions (A and B) containing different firmware versions. During updates, the new firmware is written to the inactive partition while the system continues running from the active partition. If the new firmware fails or becomes corrupted, the system can automatically rollback to the previous working version, ensuring system reliability and preventing brick situations in remote deployments. Arduino Open-source electronics platform consisting of both hardware boards (microcontroller development boards) and software (integrated development environment). Arduino provides a simplified programming framework with pre-built libraries and functions that abstract complex microcontroller operations, making embedded programming accessible to beginners while remaining powerful enough for professional applications. The Arduino ecosystem includes thousands of community-contributed libraries and shields (expansion boards). CI/CD Continuous Integration/Continuous Deployment - modern software development methodology that automates the building, testing, and deployment pipeline. CI automatically builds and tests code changes when developers commit to version control, catching integration issues early. CD extends this by automatically deploying tested code to production environments, reducing manual errors and enabling rapid, reliable software releases. Client System In Gateway Mode, the networked device or application that connects to UART2ETH via TCP sockets to communicate with legacy serial equipment. Client systems can be computers, servers, mobile devices, or other networked equipment that need to access serial devices remotely over Ethernet networks. Examples include monitoring software, configuration tools, or remote control applications. CMake Cross-platform, open-source build system generator that creates native build files (Makefiles, Visual Studio projects, Xcode projects) from platform-independent configuration files. CMake manages complex build dependencies, compiler flags, and linking requirements across different operating systems and compilers, simplifying the build process for C/C++ projects and enabling consistent builds across development teams. ENC28J60 Low-cost Ethernet controller chip from Microchip Technology that provides 10Base-T Ethernet connectivity via SPI interface. This single-chip solution includes MAC (Media Access Control) and PHY (Physical Layer) functions, making it popular for adding basic Ethernet capabilities to microcontroller projects. It requires external TCP/IP stack implementation and offers a cost-effective alternative to more integrated solutions. Full Bridge Mode UART2ETH operating mode that creates a transparent network bridge between two serial devices located at different physical locations. Both devices communicate through their UART interfaces as if they were directly connected with a serial cable, but the connection is actually routed through TCP/IP networks. This mode enables legacy serial equipment to communicate across long distances, through existing network infrastructure, without requiring protocol modifications. Gateway Mode UART2ETH operating mode that adds network connectivity to existing serial-only equipment without modifying the original device. The UART2ETH device acts as a protocol gateway, translating between the legacy device&#8217;s serial communication and modern TCP/IP networking. This allows multiple network clients to simultaneously access serial equipment, enabling remote monitoring, configuration, and control of industrial equipment, embedded systems, or test instruments. Host System The serial equipment or device connected to UART2ETH&#8217;s physical UART interface. In Gateway Mode, this is typically legacy industrial equipment, embedded systems, or test instruments that only support serial communication. In Full Bridge Mode, both endpoints are considered Host Systems. Host Systems are unaware of the network translation and continue using their native serial protocols. HW UART Hardware Universal Asynchronous Receiver-Transmitter - dedicated silicon circuitry within microcontrollers that handles serial communication at the hardware level. HW UARTs provide precise timing, automatic start/stop bit handling, parity checking, and interrupt generation without CPU intervention. This contrasts with software-based UART implementations that consume CPU cycles and may have timing limitations, especially at higher baud rates. Misra-c Motor Industry Software Reliability Association C - comprehensive coding standard that defines strict guidelines for writing safety-critical C code. MISRA-C rules cover language subset restrictions, coding practices, and documentation requirements designed to eliminate common programming errors, undefined behaviors, and implementation-defined constructs. Originally developed for automotive software, it&#8217;s now widely used in aerospace, medical devices, and industrial control systems. OTA (Over-The-Air) Remote firmware update mechanism that allows devices to receive and install new firmware through their existing communication channels (WiFi, Ethernet, cellular) without requiring physical access. OTA updates enable field devices to receive bug fixes, security patches, and feature updates remotely, reducing maintenance costs and enabling rapid deployment of improvements across device fleets. Critical for IoT devices in remote or inaccessible locations. PIO Programmable Input/Output - specialized hardware feature of the Raspberry Pi RP2350 microcontroller that provides highly flexible, real-time I/O processing independent of the main CPU cores. PIO consists of state machines that can execute custom assembly-like programs to handle precise timing requirements for protocols like WS2812 LEDs, custom serial formats, or parallel interfaces. Each PIO block can run multiple state machines simultaneously, enabling complex I/O operations without CPU intervention. PLC (Programmable Logic Controller) Industrial computer designed for automation of manufacturing processes, machinery control, and industrial monitoring systems. PLCs are ruggedized for harsh industrial environments and provide real-time control with deterministic response times. They typically use ladder logic programming and offer extensive I/O capabilities for sensors, actuators, and communication networks. Common in factory automation, process control, and building management systems. platformio Modern, open-source ecosystem for embedded and IoT development that provides unified tooling across multiple microcontroller platforms, frameworks, and boards. PlatformIO includes cross-platform IDE, library manager, unit testing framework, remote debugging capabilities, and continuous integration support. It abstracts away toolchain complexity while supporting hundreds of development boards and frameworks including Arduino, ESP-IDF, STM32, and many others. Protocol Filter Pluggable software component within UART2ETH that intelligently processes and optimizes serial data streams before TCP transmission. Protocol filters can implement packet framing, data compression, error correction, or protocol-specific optimizations to reduce network bandwidth, improve latency, or enhance reliability. Examples include buffering strategies for bulk data transfers, real-time filtering for control systems, or custom packet structures for specific industrial protocols. RPI RP2350 Second-generation microcontroller chip from Raspberry Pi Foundation featuring dual ARM Cortex-M33 cores running up to 150MHz, 520KB SRAM, advanced security features, and flexible I/O capabilities including PIO state machines. The RP2350 provides enhanced performance and security compared to the original RP2040, making it suitable for industrial applications requiring real-time processing, secure communications, and complex I/O handling. SCADA (Supervisory Control and Data Acquisition) Industrial control system architecture used for monitoring and controlling large-scale processes across multiple locations. SCADA systems collect data from remote sensors and equipment, provide centralized monitoring through human-machine interfaces (HMIs), and enable operators to control distributed processes. Common in utilities (power grids, water treatment), manufacturing, and transportation systems where real-time monitoring and control of geographically dispersed equipment is essential. SPI Ethernet Controller Ethernet controller chip that communicates with microcontrollers through the Serial Peripheral Interface (SPI) protocol rather than parallel buses. These controllers handle the complex Ethernet physical layer operations (signal encoding, collision detection, carrier sensing) while presenting a simple SPI interface to the host microcontroller. This approach reduces pin count requirements and simplifies PCB design while providing reliable network connectivity for embedded systems. SPI TCP/IP Controller Integrated circuit that implements the complete TCP/IP protocol stack in hardware and communicates with host microcontrollers via SPI interface. These chips handle all network protocol processing (IP, TCP, UDP, ARP, DHCP) independently, presenting socket-based APIs through SPI commands. This offloads complex network processing from the main microcontroller, simplifying firmware development and improving real-time performance for applications requiring both networking and real-time control. TCP Socket Network communication endpoint that provides reliable, ordered, and error-checked delivery of data streams between applications over IP networks. TCP sockets establish connections, handle flow control, retransmission of lost packets, and ensure data integrity through checksums and acknowledgments. Unlike UDP, TCP guarantees that data arrives in the correct order and without errors, making it essential for applications requiring reliable data transmission such as file transfers, web browsing, and industrial control protocols. UART (Universal Asynchronous Receiver-Transmitter) Serial communication protocol and hardware interface that transmits data character by character without requiring a shared clock signal between communicating devices. UART uses start and stop bits to frame each character, with configurable data bits (5-9), parity (none, even, odd), and stop bits (1, 1.5, 2). This asynchronous approach makes UART simple to implement and widely compatible, leading to its extensive use in embedded systems, industrial equipment, and debugging interfaces. UART2ETH Complete hardware and firmware solution that bridges between UART serial interfaces and TCP/IP Ethernet networks, supporting up to 4 simultaneous UART connections. The system provides bidirectional data translation, protocol filtering, secure OTA updates, and flexible operating modes (Gateway and Full Bridge) to enable legacy serial equipment integration with modern networks. Built on the RPI RP2350 platform with support for various Ethernet controller options. W5500 Fully integrated Ethernet controller from WIZnet that combines 10/100 Ethernet MAC, PHY, and a complete TCP/IP protocol stack in a single chip. The W5500 communicates with host microcontrollers via SPI and provides hardware-accelerated socket operations, automatic packet processing, and wake-on-LAN capabilities. Its integrated approach simplifies network integration for embedded systems by handling all low-level networking operations transparently, allowing developers to focus on application logic rather than network protocols. "
},

{
    "id": 13,
    "uri": "arc42/src/05_building_block_view.html",
    "menu": "arc42",
    "title": "Building Block View",
    "text": " Table of Contents Building Block View Whitebox Overall System Level 2 Level 3 Building Block View Whitebox Overall System &lt;Overview Diagram&gt; Motivation &lt;text explanation&gt; Contained Building Blocks &lt;Description of contained building block (black boxes)&gt; Important Interfaces &lt;Description of important interfaces&gt; &lt;Name black box 1&gt; &lt;Purpose/Responsibility&gt; &lt;Interface(s)&gt; &lt;(Optional) Quality/Performance Characteristics&gt; &lt;(Optional) Directory/File Location&gt; &lt;(Optional) Fulfilled Requirements&gt; &lt;(optional) Open Issues/Problems/Risks&gt; &lt;Name black box 2&gt; &lt;black box template&gt; &lt;Name black box n&gt; &lt;black box template&gt; &lt;Name interface 1&gt; &#8230;&#8203; &lt;Name interface m&gt; Level 2 White Box &lt;building block 1&gt; &lt;white box template&gt; White Box &lt;building block 2&gt; &lt;white box template&gt; &#8230;&#8203; White Box &lt;building block m&gt; &lt;white box template&gt; Level 3 White Box &lt;_building block x.1_&gt; &lt;white box template&gt; White Box &lt;_building block x.2_&gt; &lt;white box template&gt; White Box &lt;_building block y.1_&gt; &lt;white box template&gt; "
},

{
    "id": 14,
    "uri": "arc42/src/00_architecture_communication_canvas.html",
    "menu": "arc42",
    "title": "Architecture Communication Canvas",
    "text": " Table of Contents Architecture Communication Canvas .canvas ul { margin-left: 0px; padding-left: 1em; list-style: square; } .canvas tr:nth-child(1) td:nth-child(1), .canvas tr:nth-child(1) td:nth-child(2), .canvas tr:nth-child(2) td:nth-child(1), .canvas tr:nth-child(3) td:nth-child(1), .canvas tr:nth-child(4) td:nth-child(1) { background-color: #8fe4b4; border: 1px solid black; } .canvas tr:nth-child(1) td:nth-child(3), .canvas tr:nth-child(1) td:nth-child(4), .canvas tr:nth-child(4) td:nth-child(2) { background-color: #94d7ef; border: 1px solid black; } .canvas tr:nth-child(5) td:nth-child(1), .canvas tr:nth-child(5) td:nth-child(2) { background-color: #ffc7c6; border: 1px solid black; } Architecture Communication Canvas Designed for: UART2ETH Designed by: Development Team Value Proposition Provide a low-cost, open source, western-component based, regulatory-compliant alternative to expensive or black-box UART-to-TCP bridge solutions for adding networking capabilities to legacy equipment. Core Functions Full Bridge mode: Transparent UART over TCP for distant device connections Gateway mode: Add networking capabilities to products without development Up to 4 UARTs exposed as TCP sockets on individual ports Secure OTA firmware updates with A/B update mechanism Custom pluggable serial protocol filters for efficient TCP packaging Package caching with custom transmit timeouts for latency/bulk optimization Core Decisions - Good or Bad Good: RP2350 selection for open ecosystem, long-term support, and secure update capabilities Moving from ATMega328 due to baudrate inflexibility and security limitations Western-only component supply chain for regulatory compliance Bad: No major problematic decisions identified yet Strategic: Anticipating new regulations requiring updateable and auditable firmware Addressing gap left by discontinued commercial solutions Technologies Programming: C/C++ with Arduino framework Development: VSCodium IDE, PlatformIO build system Hardware: RP2350 microcontroller, ENC28J60 SPI Ethernet controller Protocols: Raw TCP sockets, HTTP for WebUI Security: RP2350 Boot ROM provided security mechanisms Infrastructure: GitHub runners for CI/CD Documentation: docToolchain with AsciiDoc Key Stakeholder Industrial engineers dealing with infrastructure challenges (noise, cable length issues) requiring networking solutions for existing equipment System integrators needing regulatory-compliant, ready-to-use networking solutions for their products without custom development Quality Requirements Performance: 500kBaud sustained throughput, &lt;5ms latency Reliability: Critical uptime as long as hardware operates within environmental specifications Security: Prevention of data distortion and lateral network movement attacks Usability: Users need basic understanding of serial communication and TCP/IP Scalability: 1 TCP connection per UART port Compliance: CE certification for hardware Business Context Data Sources: Legacy PLCs, sensors, measurement instruments, and older industrial equipment with serial interfaces but no networking capabilities Data Sinks: SCADA systems, custom data processing software, other UART2ETH devices (in Full Bridge mode) Network Environment: Industrial and household LANs operating at 100Mbit Dependencies: Only requires correctly routed network infrastructure No risky external interfaces or operational costs Components / Modules Hardware Components: * RP2350 microcontroller * Microchip ENC28J60 SPI Ethernet Controller * RJ45 connector with integrated magnetics * Crystal clock source * SPI EEPROM for firmware storage Software Modules: * TCP/IP communication module * UART instance modules (up to 4) * OTA update manager with A/B update support * Protocol filtering/packet splitting engine * Caching module with flexible ring buffer * Configuration management module * Optional WebUI module * PIO-based UART implementation (send/receive tasks on GPIO) Core Risks Primary security risk: Device compromise allowing data distortion or use as attack vector for lateral network movement Hardware component availability and supply chain disruptions Regulatory changes requiring additional compliance measures Performance degradation under high concurrent load scenarios Missing Information Testing framework selection not yet decided Specific cryptographic implementation details for OTA security WebUI design and user experience specifications Detailed protocol filter plugin architecture Performance benchmarking under various network conditions Industrial certification requirements beyond CE marking Software Architecture Canvas by Gernot Starke, Patrick Roos and arc42 Contributors is licensed under Attribution-ShareAlike 4.0 International "
},

{
    "id": 15,
    "uri": "arc42/src/10_quality_requirements.html",
    "menu": "arc42",
    "title": "Quality Requirements",
    "text": " Table of Contents Quality Requirements Quality Tree Quality Scenarios Quality Requirements Quality Tree Quality Scenarios "
},

{
    "id": 16,
    "uri": "arc42/src/07_deployment_view.html",
    "menu": "arc42",
    "title": "Deployment View",
    "text": " Table of Contents Deployment View Infrastructure Level 1 Infrastructure Level 2 Deployment View Infrastructure Level 1 &lt;Overview Diagram&gt; Motivation &lt;explanation in text form&gt; Quality and/or Performance Features &lt;explanation in text form&gt; Mapping of Building Blocks to Infrastructure &lt;description of the mapping&gt; Infrastructure Level 2 &lt;Infrastructure Element 1&gt; &lt;diagram + explanation&gt; &lt;Infrastructure Element 2&gt; &lt;diagram + explanation&gt; &#8230;&#8203; &lt;Infrastructure Element n&gt; &lt;diagram + explanation&gt; "
},

{
    "id": 17,
    "uri": "arc42/src/04_solution_strategy.html",
    "menu": "arc42",
    "title": "Solution Strategy",
    "text": " Table of Contents Solution Strategy Solution Strategy "
},

{
    "id": 18,
    "uri": "arc42/src/02_architecture_constraints.html",
    "menu": "arc42",
    "title": "Architecture Constraints",
    "text": " Table of Contents Architecture Constraints Technical Constraints Organizational Constraints Economic Constraints Regulatory and Legal Constraints Architecture Constraints Technical Constraints Constraint Description Rationale Hardware Platform Must use RP2350 microcontroller as primary processing unit Provides required security features for OTA updates, sufficient processing power for 4 UART channels, and western supply chain compliance Component Sourcing All components must be sourced from western suppliers only Regulatory compliance requirement for target markets and supply chain security considerations Performance Requirements Minimum 500kBaud sustained throughput with sub-5ms latency per UART channel Industrial application requirements for real-time data transmission Network Interface 100Mbit Ethernet connectivity via SPI-based controller Cost constraints and sufficient bandwidth for target applications while maintaining hardware simplicity UART Channel Limit Maximum 4 independent UART interfaces Hardware resource limitations of chosen microcontroller platform and cost optimization Organizational Constraints Constraint Description Rationale Open Source License Complete system must be released under GPL license Leverage existing open source libraries and reduce implementation effort by reusing proven components Development Process Test-driven development (TDD) approach mandatory for all production code Quality assurance and maintainability requirements for industrial application reliability Documentation Standard Architecture documentation must follow arc42 template structure Standardized documentation approach for future maintainers and contributors Version Control GitHub-based development workflow with mandatory pull request reviews Code quality control and collaborative development coordination Economic Constraints Constraint Description Rationale Hardware Cost Hardware target price per unit must be significantly below commercially available solutions Competitive market positioning requires substantial cost advantage to justify adoption over established commercial products Development Effort Development effort must achieve return on investment within first year of deployment Resource allocation constraint limits project scope and complexity to ensure economic viability and timely market entry Regulatory and Legal Constraints Constraint Description Rationale CE Certification Hardware must achieve CE compliance for European market Legal requirement for commercial deployment in target markets Firmware Security Must implement secure boot and signed firmware update mechanisms Anticipated regulatory requirements for updateable industrial devices EMC Compliance Electromagnetic compatibility requirements for industrial environments Regulatory requirement and operational necessity in electrically noisy industrial settings Export Control No components or technologies subject to export restrictions Unrestricted distribution and deployment capability Patent Avoidance Must not infringe on existing patents in communication protocols or hardware interfaces Legal risk mitigation and freedom to operate requirements "
},

{
    "id": 19,
    "uri": "search.html",
    "menu": "-",
    "title": "search",
    "text": " Search Results "
},

{
    "id": 20,
    "uri": "lunrjsindex.html",
    "menu": "-",
    "title": "null",
    "text": " will be replaced by the index "
},

];
