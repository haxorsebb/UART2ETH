var documents = [

{
    "id": 0,
    "uri": "arc42/adrs/ADR-003-programming-language-selection.html",
    "menu": "adrs",
    "title": "ADR-003: Programming Language Selection for UART2ETH",
    "text": " Table of Contents ADR-003: Programming Language Selection for UART2ETH Context Decision Drivers Primary Requirements Constraints Options Considered Option A: C Programming Language Option B: Rust Programming Language PUGH Matrix Analysis Decision Rationale Why C Over Rust Memory Safety Strategy in C Rust Advantages Acknowledged But Outweighed Consequences Positive Negative Risks and Mitigation Implementation Notes Development Standards Testing Strategy Security Practices Follow-up Actions ADR-003: Programming Language Selection for UART2ETH Status: ACCEPTED Date: 2025-07-26 Deciders: Architecture Team Consulted: Senior Developer Informed: Development Team Context The UART2ETH system requires selecting a programming language for firmware development on the RP2350 microcontroller. This decision directly impacts development velocity, system reliability, maintainability, and the ability to meet project delivery timelines. Based on hardware platform decisions (ADR-001: RP2350 selection, ADR-002: ENC28J60 selection), we need a programming language that can: Deliver industrial-grade reliability for 4 concurrent UART-to-TCP bridges Support real-time performance requirements (500 kbps per port, sub-5ms latency) Enable rapid development with existing team expertise Operate efficiently in severely memory-constrained environment (520KB SRAM, static allocation) Provide adequate safety guarantees for industrial deployment Meet aggressive project delivery timeline (\"deliver yesterday\") Must operate reliably in industrial environments (-40¬∞C to +85¬∞C) üòâ The programming language selection fundamentally determines development productivity, code maintainability, and the feasibility of meeting project deadlines with current team capabilities. Decision Drivers Primary Requirements Development Velocity : Critical time-to-market pressure requiring immediate productivity Team Expertise : Leveraging existing microcontroller team&#8217;s deep C experience Industrial Reliability : Proven track record in embedded industrial applications Memory Model Fit : Optimal performance in static memory allocation environment Ecosystem Maturity : Comprehensive tooling, libraries, and vendor support Real-time Determinism : Predictable behavior for latency-critical applications Hardware Integration : Direct access to RP2350 and ENC28J60 peripherals Debugging Capabilities : Mature debugging tools for embedded development Constraints Aggressive delivery timeline with no room for learning curve delays Small project scope where complexity management is achievable Static memory allocation model (no dynamic allocation) Team expertise concentrated in C/C++ embedded development Must operate reliably in industrial environments (-40¬∞C to +85¬∞C) üòâ Options Considered Option A: C Programming Language Ecosystem : Mature ecosystem with comprehensive RP2350 Pico SDK support Team Expertise : Deep existing knowledge in microcontroller team Development Velocity : Immediate productivity, no learning curve Memory Model : Direct, predictable memory management with static allocation Tooling : Mature debugging (GDB, OpenOCD), profiling, and analysis tools Hardware Support : Full vendor support for RP2350 and ENC28J60 Industrial Track Record : Decades of proven deployment in embedded systems Real-time Performance : Deterministic, low-level control over hardware Memory Safety : Achievable through disciplined practices and comprehensive testing Standards Compliance : MISRA-C guidelines for industrial safety Option B: Rust Programming Language Ecosystem : Emerging ecosystem with excellent RP2350 day-one support (rp235x-hal) Team Expertise : No existing knowledge, 6-12 month learning curve to proficiency Development Velocity : Significant initial productivity loss during team transition Memory Model : Memory safety guarantees less relevant in static allocation environment Tooling : Improving but less mature debugging tools (probe-rs vs GDB) Hardware Support : Good RP2350 support, limited ENC28J60 ecosystem Industrial Track Record : Limited embedded deployment history Real-time Performance : Embassy framework provides async capabilities Memory Safety : Compile-time guarantees prevent entire classes of bugs Modern Features : Advanced type system, zero-cost abstractions PUGH Matrix Analysis Scoring: Better than baseline (+1, +2), Same as baseline (0), Worse than baseline (-1, -2) Baseline: C Programming Language (all scores = 0) Criteria Weight C Language Rust Language Development Velocity 3 0 (baseline) -2 (6-12 month learning curve) Team Expertise 3 0 (baseline) -2 (zero existing knowledge) Time to Market 3 0 (baseline) -2 (immediate productivity loss) Ecosystem Maturity 2 0 (baseline) -1 (emerging, less comprehensive) Memory Safety in Static Environment 2 0 (baseline) +1 (compile-time checks, limited benefit) Industrial Track Record 2 0 (baseline) -1 (limited embedded deployment) Hardware Vendor Support 2 0 (baseline) -1 (good RP2350, limited ENC28J60) Debugging Maturity 2 0 (baseline) -1 (improving but less mature) Real-time Determinism 2 0 (baseline) 0 (comparable with Embassy) Code Maintainability 3 0 (baseline) +1 (better type system) Future Proofing 4 0 (baseline) +2 (modern language, industry trend) TOTAL WEIGHTED SCORE 0 -13 Decision Selected: C Programming Language The C programming language provides the optimal balance of development velocity, team productivity, and technical capability for the UART2ETH project, scoring significantly higher in our weighted analysis. Rationale Why C Over Rust Immediate Productivity : Team can begin productive development immediately without learning curve delays Time-Critical Delivery : Project timeline (\"deliver yesterday\") cannot accommodate 6-12 month Rust learning curve Static Memory Context : Rust&#8217;s primary advantages (memory safety) are significantly diminished in our static allocation environment where: No dynamic allocation eliminates use-after-free, double-free, memory leaks Fixed buffer sizes and lifetimes reduce dangling pointer risks Predictable memory layout simplifies debugging and validation Team Expertise Leverage : Deep microcontroller C experience translates to immediate high-quality code Ecosystem Maturity : Comprehensive vendor support, mature tooling, extensive industrial deployment history Manageable Complexity : Small project scope where C complexity is controllable through: Disciplined coding practices (MISRA-C guidelines) Comprehensive unit and integration testing Code reviews focused on memory safety patterns Static analysis tools Memory Safety Strategy in C Static Allocation : All memory allocated at compile time, eliminating dynamic memory risks Defensive Programming : Bounds checking, input validation, error handling Testing Strategy : 100% code coverage, stress testing, hardware-in-the-loop validation Code Standards : MISRA-C compliance for industrial safety Review Process : Mandatory security-focused code reviews Rust Advantages Acknowledged But Outweighed Compile-time Memory Safety : Valuable but less critical in static allocation environment Modern Type System : Benefits outweighed by learning curve and timeline pressure Future-proofing : Theoretical benefit cannot justify immediate delivery risk Consequences Positive ‚úÖ Immediate Development Start : No productivity loss during language transition ‚úÖ Team Expertise Utilized : Deep C knowledge translates to high-quality embedded code ‚úÖ Mature Ecosystem : Full vendor support, comprehensive tooling, extensive libraries ‚úÖ Proven Industrial Reliability : Decades of successful embedded deployments ‚úÖ Debugging Efficiency : Mature GDB/OpenOCD toolchain familiar to team ‚úÖ Timeline Compliance : Meets aggressive delivery requirements Negative ‚ö†Ô∏è Manual Memory Management : Requires disciplined practices and comprehensive testing ‚ö†Ô∏è Potential Security Vulnerabilities : Manual bounds checking, pointer management ‚ö†Ô∏è Future Technology Debt : May require reevaluation for future projects ‚ö†Ô∏è Missing Modern Features : Less expressive type system than Rust Risks and Mitigation Memory Safety Risk : Mitigate through MISRA-C compliance, static analysis, comprehensive testing Code Quality Risk : Mitigate through mandatory code reviews, automated testing, continuous integration Future Maintenance Risk : Document rationale, plan Rust evaluation for future projects Implementation Notes Development Standards MISRA-C Compliance : Follow MISRA-C:2012 guidelines for industrial safety Static Analysis : Integrate PC-lint, Cppcheck, or equivalent in CI pipeline Memory Management : Strictly static allocation, no malloc/free usage Error Handling : Consistent error codes, graceful degradation strategies Testing Strategy Unit Testing : 100% code coverage requirement Integration Testing : Hardware-in-the-loop validation Stress Testing : Extended operation under maximum load conditions Memory Validation : Static analysis tools, runtime bounds checking in debug builds Security Practices Input Validation : All network and UART inputs validated Buffer Management : Fixed-size buffers with explicit bounds checking Secure Coding : Follow SEI CERT C guidelines Code Reviews : Security-focused review process for all code changes Follow-up Actions Development Environment : Configure MISRA-C checking in build system Testing Framework : Establish unit testing framework with coverage reporting Code Standards : Document project-specific C coding guidelines Static Analysis : Integrate static analysis tools in CI/CD pipeline Team Training : Brief refresher on secure C practices for embedded systems Future Evaluation : Plan Rust reassessment for next major project Review Notes: &#10063; Confirm MISRA-C compliance requirements with quality team &#10063; Validate static analysis tool selection &#10063; Review memory safety testing strategy &#10063; Document specific secure coding guidelines &#10063; Plan future Rust evaluation timeline "
},

{
    "id": 1,
    "uri": "arc42/adrs/ADR-001-microcontroller-selection.html",
    "menu": "adrs",
    "title": "ADR-001: Microcontroller Platform Selection for UART2ETH",
    "text": " Table of Contents ADR-001: Microcontroller Platform Selection for UART2ETH Context Decision Drivers Primary Requirements Constraints Options Considered Option A: Raspberry Pi RP2350 Option B: ATMega328P (Baseline) Option C: ESP32 PUGH Matrix Analysis Weighted Scores Decision Rationale Why RP2350 Over ATMega328P Why RP2350 Over ESP32 Consequences Positive Negative Risks and Mitigation Implementation Notes Required External Components Development Approach Architecture Implications Follow-up Actions ADR-001: Microcontroller Platform Selection for UART2ETH Status: ACCEPTED Date: 2025-07-26 Deciders: Architecture Team Consulted: Senior Developer Informed: Development Team Context The UART2ETH system requires a microcontroller platform capable of: Supporting up to 4 concurrent UART interfaces Processing TCP/IP networking with industrial reliability Implementing secure OTA firmware updates with A/B partitioning Operating in industrial environments (-40¬∞C to +85¬∞C) Achieving 500 kbps sustained throughput per UART port with sub-5ms latency Cost-effective solution for volume production The microcontroller selection is a foundational decision that affects all system capabilities, development complexity, and long-term maintainability. Decision Drivers Primary Requirements Multi-UART Support : Hardware support for multiple UARTs or flexible alternatives Network Processing : Sufficient processing power for TCP/IP stack and protocol filtering A/B Update Capability : Sufficient flash memory and architecture for dual firmware partitions Security Capabilities : Hardware support for cryptographic operations and secure boot Industrial Reliability : Temperature range, electrical robustness, proven track record Real-time Performance : Deterministic behavior for latency-critical applications Development Ecosystem : Mature toolchain, documentation, community support Cost Effectiveness : Component cost + external components for volume production Constraints Must operate reliably in industrial environments GPL open source licensing compatibility Maximum system cost target: $10 for volume production Options Considered Option A: Raspberry Pi RP2350 Architecture : Dual-core ARM Cortex-M33 @ 150MHz Memory : 520KB SRAM, external flash required UARTs : 2 hardware UARTs + 12 programmable I/O (PIO) state machines Networking : Requires external Ethernet controller (ENC28J60) Security : Hardware SHA-256, ARM TrustZone, secure boot capabilities A/B Updates : External flash enables dual partitions + secure bootloader Development Ecosystem : Good documentation, smaller community than Arduino Industrial Track Record : None (released August 2024, zero field deployment) Cost : ~$1.00 + ~$1.50 (ENC28J60) = $2.50 total Option B: ATMega328P (Baseline) Architecture : Single-core 8-bit AVR @ 16MHz Memory : 2KB SRAM, 32KB Flash UARTs : 1 hardware UART Networking : Requires external Ethernet controller (ENC28J60) Security : No hardware security features A/B Updates : Insufficient flash space (32KB) for dual firmware images Development Ecosystem : Arduino platform - most accessible ecosystem ever created, millions of tutorials Industrial Track Record : Decades of proven deployment in industrial environments Cost : ~$2.50 + ~$1.50 (ENC28J60) = $4.00 total Option C: ESP32 Architecture : Dual-core Xtensa LX6 @ 240MHz Memory : 520KB SRAM, 4MB Flash UARTs : 3 hardware UARTs Networking : Built-in WiFi/Bluetooth, requires external Ethernet for wired Security : Hardware crypto acceleration, secure boot A/B Updates : 4MB flash supports dual partitions + ESP-IDF OTA framework Development Ecosystem : Good tools (ESP-IDF, Arduino IDE), solid community, smaller than Arduino Industrial Track Record : 8+ years deployment (2016+), moderate industrial adoption, less proven than ATMega328P Cost : ~$2.50 + ~$1.50 (ENC28J60) = $4.00 total PUGH Matrix Analysis Scoring: Better than baseline (+1, +2), Same as baseline (0), Worse than baseline (-1, -2) Baseline: ATMega328P (all scores = 0) Criteria Weight ATMega328P RP2350 ESP32 UART Support 3 0 (baseline) +2 (PIO flexibility) +1 (3 HW UARTs) Processing Power 3 0 (baseline) +2 (dual 32-bit @150MHz) +2 (dual 32-bit @240MHz) Memory Capacity 2 0 (baseline) +2 (260x more SRAM) +2 (260x more SRAM) A/B Update Support 3 0 (baseline) +2 (external flash + secure boot) +2 (4MB flash + OTA framework) Security Features 3 0 (baseline) +2 (HW SHA-256 + TrustZone) +1 (HW crypto only) Real-time Determinism 2 0 (baseline) +2 (PIO + dual-core) +1 (dual-core) Development Ecosystem 2 0 (baseline) -1 (smaller community, newer) 0 (good tools, smaller than Arduino) Industrial Reliability 2 0 (baseline) -1 (new platform, zero field history) 0 (8+ years, less than decades) Cost Effectiveness 1 0 (baseline) +2 (37% cost reduction) 0 (same cost) Network Architecture 2 0 (baseline) 0 (same - external PHY) -1 (WiFi overhead) Weighted Scores RP2350 Total Score: UART: 3√ó(+2) = +6 Processing: 3√ó(+2) = +6 Memory: 2√ó(+2) = +4 A/B Updates: 3√ó(+2) = +6 Security: 3√ó(+2) = +6 Real-time: 2√ó(+2) = +4 Ecosystem: 2√ó(-1) = -2 Reliability: 2√ó(-1) = -2 Cost: 1√ó(+2) = +2 Network: 2√ó(0) = 0 Total: +30 ESP32 Total Score: UART: 3√ó(+1) = +3 Processing: 3√ó(+2) = +6 Memory: 2√ó(+2) = +4 A/B Updates: 3√ó(+2) = +6 Security: 3√ó(+1) = +3 Real-time: 2√ó(+1) = +2 Ecosystem: 2√ó(0) = 0 Reliability: 2√ó(0) = 0 Cost: 1√ó(0) = 0 Network: 2√ó(-1) = -2 Total: +22 Decision Selected: Raspberry Pi RP2350 The RP2350 scores significantly higher (+30 vs +22) in the weighted PUGH analysis, primarily due to: Superior UART Flexibility : PIO state machines provide unmatched capability for implementing custom UART protocols A/B Update Architecture : External flash design enables reliable dual-partition firmware updates Security Architecture : Hardware SHA-256 and TrustZone directly address secure OTA requirements Cost Advantage : 37% lower total system cost while providing better capabilities Real-time Determinism : PIO subsystem + dual-core architecture enables predictable performance Rationale Why RP2350 Over ATMega328P Performance Gap : 328P cannot handle 4 concurrent UARTs + TCP processing Memory Limitation : 2KB SRAM insufficient for networking stack and buffering A/B Update Impossibility : 32KB flash insufficient for dual firmware images (need ~64KB minimum) Security Gap : No hardware security features compromise OTA update integrity Future Flexibility : PIO enables protocol adaptations without hardware changes Why RP2350 Over ESP32 Industrial Focus : No unnecessary WiFi attack surface in industrial environments Cost Efficiency : Lower total system cost for same networking capability Architectural Fit : PIO subsystem specifically designed for custom I/O protocols Security Model : TrustZone provides more comprehensive security architecture UART Flexibility : Superior support for multiple custom UART implementations Industrial Reliability Trade-off : While ESP32 has solid 8+ years of industrial deployment vs RP2350&#8217;s zero field history, neither matches ATMega328P&#8217;s decades of proven reliability. Development Ecosystem Trade-off : ATMega328P&#8217;s Arduino ecosystem is unmatched in accessibility, tutorials, and community support. Both RP2350 and ESP32 have smaller ecosystems despite good documentation. Despite these disadvantages, the RP2350&#8217;s technical advantages outweigh these risks for our specific application requirements. Consequences Positive ‚úÖ Technical Capability : Meets all performance and functionality requirements ‚úÖ Cost Optimization : Lowest total system cost among capable options ‚úÖ Security Compliance : Hardware support for all security requirements ‚úÖ Development Efficiency : Excellent documentation and tooling ecosystem ‚úÖ Future Flexibility : PIO enables protocol extensions without redesign Negative ‚ö†Ô∏è External Dependency : Requires ENC28J60 Ethernet controller ‚ö†Ô∏è Industrial Deployment Risk : Zero field deployment history in industrial environments (released August 2024) ‚ö†Ô∏è Platform Maturity : Less proven than ATMega328P&#8217;s decades of industrial use ‚ö†Ô∏è Development Ecosystem : Smaller community and fewer resources compared to Arduino&#8217;s massive ecosystem ‚ö†Ô∏è Custom Development : PIO programming requires specialized knowledge Risks and Mitigation Supply Chain Risk : Multiple suppliers available, stockpile strategy for critical components ENC28J60 Dependency : Well-established component with multiple sources and alternatives Industrial Reliability Risk : RP2350 has zero industrial field deployment history; mitigate with extensive environmental testing and validation program Development Complexity : Comprehensive documentation and examples available Implementation Notes Required External Components ENC28J60 Ethernet Controller : Hardware TCP/IP stack, SPI interface Crystal/Oscillator : For precise timing if required by application Power Supply : 3.3V regulation and filtering Protection : ESD protection for industrial environments Development Approach Phase 1 : Basic RP2350 + ENC28J60 integration with single UART Phase 2 : PIO-based additional UART implementation Phase 3 : Security features and OTA update system Architecture Implications Dual-Core Utilization : Core 0 for real-time UART processing, Core 1 for networking Memory Management : Static allocation for predictable real-time behavior Security Integration : TrustZone secure boot with hardware-accelerated crypto Follow-up Actions Procurement : Establish supplier relationships for RP2350 and ENC28J60 Industrial Validation : Comprehensive environmental testing program to validate RP2350 reliability in industrial conditions Prototyping : Develop basic hardware platform for validation testing PIO Development : Create UART protocol templates using PIO state machines Security Planning : Design secure boot and OTA update architecture Testing Strategy : Define industrial environment validation procedures including EMI/EMC testing Review Notes: &#10063; Confirm ENC28J60 vs W5500 preference &#10063; Validate cost estimates with current supplier pricing &#10063; Review A/B update architecture requirements vs RP2350 external flash approach &#10063; Confirm industrial temperature requirements vs RP2350 specs &#10063; Validate PUGH matrix criteria weights reflect actual project priorities "
},

{
    "id": 2,
    "uri": "arc42/adrs/ADR-004-development-ecosystem.html",
    "menu": "adrs",
    "title": "ADR-004: Development Ecosystem Selection for UART2ETH",
    "text": " Table of Contents ADR-004: Development Ecosystem Selection for UART2ETH Context Decision Drivers Primary Requirements Constraints Options Considered Option A: Arduino IDE/Framework Option B: PlatformIO + Arduino Framework Option C: PlatformIO + Native Pico SDK Option D: Native Pico SDK + CMake (Traditional Embedded) PUGH Matrix Analysis Decision Rationale Why Native SDK + CMake Over PlatformIO + SDK (+34 vs +22) Why PlatformIO + SDK Over PlatformIO + Arduino (+22 vs +14) Why Any Professional Option Over Arduino IDE (Baseline) Delivery Timeline Trade-off Justification Consequences Positive Negative Risks and Mitigation üö® Critical Contradiction Discovery ENC28J60 + RP2350 Development Challenges Alternative: W5500 + RP2350 Ecosystem Maturity Implementation Notes Development Environment Components Required Dependencies Development Standards Interdependency with ADR-002 Follow-up Actions ADR-004: Development Ecosystem Selection for UART2ETH Status: ACCEPTED Date: 2025-07-27 Deciders: Architecture Team Consulted: Senior Developer Informed: Development Team Context The UART2ETH system requires selecting a comprehensive development ecosystem including build system, toolchain, IDE integration, and dependency management for RP2350-based firmware development. This decision directly impacts development velocity, code quality, maintainability, and the ability to leverage advanced RP2350 capabilities. Based on platform decisions: ADR-001: RP2350 microcontroller selection ADR-002: ENC28J60 ethernet controller selection ADR-003: C programming language selection We need a development ecosystem that can: Enable rapid, professional C development on RP2350 platform Support industrial-grade reliability and testing practices Provide access to advanced RP2350 features (PIO, dual-core, secure boot, A/B updates) Integrate with selected ethernet controller efficiently Support team collaboration and CI/CD practices Meet aggressive delivery timeline requirements Enable MISRA-C compliance and comprehensive testing Decision Drivers Primary Requirements Development Velocity : Immediate productivity with minimal learning curve RP2350 Feature Access : Full access to PIO, dual-core, security, and OTA capabilities Industrial Tooling : Mature debugging, static analysis, and testing infrastructure Team Expertise Fit : Leverage existing C/embedded development skills Ethernet Integration : Efficient integration with selected ethernet controller Professional Workflow : Support for code reviews, CI/CD, and quality gates Documentation : Comprehensive vendor support and community resources Constraints Aggressive delivery timeline requiring immediate productivity Industrial reliability requirements (MISRA-C, comprehensive testing) Team expertise concentrated in C/embedded development Must support secure OTA updates and A/B partitioning GPL open source licensing compatibility Options Considered Option A: Arduino IDE/Framework Pros : Rapid prototyping, huge community, simple setup Cons : Not professional-grade, poor CI/CD integration, limited industrial features, conflicts with C language choice ( ADR-003 ) Option B: PlatformIO + Arduino Framework Pros : Professional IDE integration, good dependency management, better than Arduino IDE Cons : Still Arduino framework limitations, emerging RP2350 support Option C: PlatformIO + Native Pico SDK Pros : Professional environment with native SDK access Cons : RP2350 support still emerging, complexity with advanced features, abstraction layer overhead Option D: Native Pico SDK + CMake (Traditional Embedded) Pros : Maximum control, full vendor support, mature tooling, industrial-grade capability Cons : More manual setup, steeper learning curve for non-embedded developers PUGH Matrix Analysis Scoring: Better than baseline (+1, +2), Same as baseline (0), Worse than baseline (-1, -2) Baseline: Arduino IDE (all scores = 0) Criteria Weight Arduino IDE PlatformIO+Arduino PlatformIO+SDK Native SDK+CMake Development Velocity 3 0 (baseline) +1 (better IDE, deps mgmt) -1 (setup complexity) -1 (manual setup) RP2350 Feature Access 3 0 (baseline) 0 (Arduino framework limits) +1 (emerging SDK access) +2 (full SDK access) Industrial Tooling 3 0 (baseline) +1 (better IDE, CI integration) +2 (professional environment) +2 (mature debugging, analysis) Team Expertise Fit 2 0 (baseline) 0 (similar Arduino approach) +1 (mixed C/Arduino) +2 (pure C expertise) Professional Workflow 2 0 (baseline) +2 (CI/CD, collaboration tools) +2 (professional environment) +2 (industry standard) Advanced RP2350 Features 3 0 (baseline) -1 (Arduino abstractions hide features) +1 (partial SDK access) +2 (secure boot, A/B updates, PIO) Delivery Timeline 3 0 (baseline) +1 (faster than manual setup) 0 (learning curve offsets speed) -1 (initial setup overhead) Industrial Compliance 3 0 (baseline) 0 (limited MISRA-C support) +1 (better static analysis) +2 (full MISRA-C, testing support) Debugging Maturity 2 0 (baseline) +1 (better than Arduino IDE) +1 (good debugging support) +2 (GDB, OpenOCD, mature tools) Long-term Maintainability 2 0 (baseline) +1 (better project structure) +1 (cleaner architecture) +2 (vendor-supported, stable) Total PUGH Score 0 +14 +22 +34 Decision Selected: Native Pico SDK + CMake Development Ecosystem The Native Pico SDK with CMake provides the optimal foundation for professional, industrial-grade development of the UART2ETH system, scoring significantly higher (+34 vs +22 vs +14 vs 0) in weighted analysis. Rationale Why Native SDK + CMake Over PlatformIO + SDK (+34 vs +22) Superior RP2350 Feature Access : Full vendor-supported access to secure boot, A/B updates, and advanced PIO programming vs emerging support Industrial Compliance Advantage : Native MISRA-C toolchain integration vs adaptation layers Team Expertise Optimal Fit : Direct C expertise application vs mixed C/framework approach Debugging Maturity : Full GDB/OpenOCD integration vs abstracted debugging Long-term Vendor Support : Raspberry Pi official support vs third-party integration Why PlatformIO + SDK Over PlatformIO + Arduino (+22 vs +14) RP2350 Capabilities : Access to microcontroller features vs Arduino framework limitations Industrial Requirements : Better static analysis and compliance support Advanced Features : Required for secure OTA and A/B updates vs basic functionality Why Any Professional Option Over Arduino IDE (Baseline) Industrial Development : Professional tooling, CI/CD, collaboration vs hobbyist-focused Project Complexity : Multi-UART, networking, security features exceed Arduino scope Team Requirements : Professional development practices vs simple prototyping Delivery Timeline Trade-off Justification While Native SDK has initial setup overhead (-3 points), this is offset by: Quality Foundation : Reduces rework and debugging time later Team Expertise : C skills minimize learning curve impact Industrial Requirements : Mandatory for MISRA-C compliance and advanced features Long-term Velocity : Better maintainability and debugging capabilities Consequences Positive ‚úÖ Professional Development Environment : Industry-standard toolchain with mature debugging and analysis tools ‚úÖ Full Platform Capability : Access to all RP2350 advanced features required for product requirements ‚úÖ Industrial Compliance : Native support for MISRA-C, static analysis, and testing frameworks ‚úÖ Team Productivity : Direct application of existing embedded C expertise ‚úÖ Vendor Support : Comprehensive Raspberry Pi documentation and examples ‚úÖ Future-Proof Architecture : Foundation for advanced features and scaling Negative ‚ö†Ô∏è Initial Setup Complexity : More manual configuration compared to PlatformIO ‚ö†Ô∏è Learning Curve : CMake and SDK-specific concepts for team members unfamiliar with Pico development ‚ö†Ô∏è Dependency Management : Manual library management vs automated PlatformIO approach ‚ö†Ô∏è IDE Integration : Requires configuration vs out-of-box PlatformIO experience Risks and Mitigation Development Environment Setup Risk : Mitigate with standardized Docker development containers and comprehensive setup documentation Team Learning Curve Risk : Mitigate with focused training sessions and pair programming during initial implementation Dependency Management Complexity : Mitigate with Git submodules and clear dependency documentation Critical Ethernet Controller Ecosystem Dependency Risk HIGH RISK : The viability of our development ecosystem choice is significantly impacted by ADR-002 (Ethernet Controller Selection) : W5500 Ecosystem Support : ‚úÖ Official WIZnet Libraries : Native Pico SDK integration (WIZnet-PICO-C, WIZnet-PICO-LWIP-C) ‚úÖ Vendor Documentation : Comprehensive examples and industrial deployment guides ‚úÖ Community Support : Multiple professional implementations and maintained libraries ‚úÖ Industrial Examples : Azure IoT, AWS IoT integrations with proven reliability ENC28J60 Ecosystem Support : ‚ö†Ô∏è Individual Open Source Efforts : Limited to individual developers (e.g., Juddling/pi-pico-enc28j60) ‚ö†Ô∏è No Official RP2350 Support : No vendor libraries for RP2350+ENC28J60 combination ‚ö†Ô∏è Arduino-Focused : Most examples conflict with our C language choice ( ADR-003 ) ‚ö†Ô∏è Custom Integration Required : Significant lwIP integration effort needed ‚ö†Ô∏è Maintenance Risk : Dependency on individual maintainer vs corporate support Risk Assessment : ENC28J60 choice significantly increases development effort and long-term maintenance risk for our chosen development ecosystem. Mitigation Options : Accept Risk : Proceed with ENC28J60 and allocate 1-2 weeks for custom integration development Reconsider ADR-002 : Evaluate W5500 based on ecosystem maturity and development efficiency Hybrid Approach : Prototype with both controllers to validate integration effort Recommendation : This ecosystem dependency should be factored into ADR-002 reconsideration. üö® Critical Contradiction Discovery During ecosystem research, significant issues were discovered with ADR-002 (ENC28J60 selection) : ENC28J60 + RP2350 Development Challenges Limited RP2350 Support : No official vendor libraries for RP2350+ENC28J60 Arduino-Only Examples : Most implementations require Arduino framework, conflicting with ADR-003 (C language choice) Complex Integration : Requires custom lwIP integration with significant development effort Performance Limitation : 10Mbps only vs 100Mbps capability needed Industrial Reliability Risk : Less mature integration, more complex software stack Alternative: W5500 + RP2350 Ecosystem Maturity Official RP2350 Support : WIZnet W5500-EVB-Pico2 with comprehensive SDK integration Native Pico SDK Libraries : WIZnet-PICO-C, WIZnet-PICO-LWIP-C, industrial examples Hardware TCP/IP Stack : Reduces microcontroller overhead, improves determinism 100Mbps Performance : Meets bandwidth requirements Industrial Deployments : Proven in Azure IoT, AWS IoT applications Recommendation : ADR-002 should be reconsidered in light of development ecosystem requirements. Implementation Notes Development Environment Components Toolchain : ARM GCC toolchain provided with Pico SDK Build System : CMake with Pico SDK build extensions IDE Integration : VS Code with C/C++ and CMake extensions Debugging : OpenOCD + GDB with Picoprobe or compatible debugger Static Analysis : PC-lint Plus or Cppcheck integration Testing Framework : Unity or CppUTest for unit testing CI/CD : GitHub Actions with standardized build and test pipelines Required Dependencies Pico SDK v2.1+ : Full RP2350 support with security features W5500 Libraries : WIZnet-PICO-C for ethernet integration (if ADR-002 reconsidered) lwIP Stack : For TCP/IP implementation (ENC28J60) or hardware stack interface (W5500) Testing Framework : Unity for embedded unit testing Static Analysis Tools : MISRA-C compliance checking Development Standards MISRA-C Compliance : Enforce via static analysis in CI pipeline Code Coverage : 100% requirement with automated reporting Documentation : Doxygen-style comments for all public interfaces Version Control : Git with semantic versioning and conventional commits Code Reviews : Mandatory reviews for all production code changes Interdependency with ADR-002 This ADR reveals critical issues with ADR-002 (ENC28J60 selection) : Development Ecosystem Mismatch : ENC28J60 lacks mature RP2350 SDK integration Performance vs Requirements : 10Mbps limitation vs 100Mbps capability needed Industrial Reliability Concerns : Complex software stack vs proven hardware solutions Team Productivity Impact : Months of custom development vs immediate integration Recommendation : ADR-002 should be reopened with updated technical analysis considering: Ecosystem maturity and vendor support Development velocity and team productivity impact Industrial deployment requirements and reliability Follow-up Actions Evaluate ADR-002 Impact : Technical reassessment of ethernet controller choice with ecosystem considerations Development Environment Setup : Create standardized Docker containers and setup documentation Toolchain Integration : Configure CMake, static analysis, and testing framework integration Team Training Plan : Develop Pico SDK and CMake training materials Prototype Development : Create proof-of-concept demonstrating ecosystem capabilities CI/CD Pipeline : Implement automated build, test, and quality gates Review Notes: &#10063; CRITICAL : This ADR recommends reconsidering ADR-002 based on technical evidence &#10063; Confirm W5500 ecosystem advantages align with project requirements &#10063; Validate team acceptance of Native SDK approach vs PlatformIO preference &#10063; Review industrial compliance requirements vs ecosystem capabilities &#10063; Assess impact of ADR-002 change on project timeline and budget "
},

{
    "id": 3,
    "uri": "arc42/adrs/ADR-002-ethernet-controller-selection.html",
    "menu": "adrs",
    "title": "ADR-002: Ethernet Controller Selection for UART2ETH",
    "text": " Table of Contents ADR-002: Ethernet Controller Selection for UART2ETH Context Decision Drivers Primary Requirements Constraints Options Considered Option A: WIZnet W5500 Option B: Microchip ENC28J60 PUGH Matrix Analysis Decision Rationale Why ENC28J60 Over W5500 Trade-offs Accepted Consequences Positive Negative Risks and Mitigation Implementation Notes Performance Optimization Follow-up Actions ADR-002: Ethernet Controller Selection for UART2ETH Status: ACCEPTED Date: 2025-07-26 Deciders: Architecture Team Consulted: Senior Developer Informed: Development Team Context The UART2ETH system requires an Ethernet controller that interfaces with the RP2350 microcontroller via SPI to provide reliable TCP/IP connectivity. This component is critical for the core networking functionality of our product. Based on our microcontroller selection (ADR-001), we need to determine the most appropriate Ethernet controller solution that can: Support at least 10 Mbps Ethernet connectivity Interface with the RP2350 via SPI Handle the networking requirements of up to 4 concurrent UART-to-TCP bridges Operate reliably in industrial environments (-40¬∞C to +85¬∞C) Maintain low latency while supporting our 500 kbps per port requirement Simplify firmware development with minimal microcontroller overhead Meet our cost target for volume production Does not contain firmware on its own Comes from a 'western' supplier The Ethernet controller selection impacts system performance, reliability, development complexity, and overall BOM cost. Decision Drivers Primary Requirements Network Performance : Support for full 100 Mbps Ethernet with sufficient throughput for our use case Memory Buffer Size : Sufficient buffer for packet handling and multiple connections SPI Interface Speed : Fast and efficient communication with the microcontroller Industrial Reliability : Operating temperature range and robustness for industrial use Cost Effectiveness : Component cost for volume production Development Complexity : Readily available OpenSource library for integration Constraints Must use SPI interface to connect with the RP2350 microcontroller Must operate reliably in industrial environments (-40¬∞C to +85¬∞C) Must fit within the overall $10 system cost target for volume production Must use open-source compatible software stacks (GPL license compatible) Options Considered Option A: WIZnet W5500 Interface : SPI (up to 80 MHz) Network Speed : 10/100 Mbps Ethernet TCP/IP Stack : Hardwired TCP/IP stack (integrated) Buffer Memory : 32 KB internal buffer Concurrent Connections : 8 independent hardware sockets Protocols Support : TCP, UDP, IPv4, ICMP, ARP, IGMP, PPPoE Temperature Range : -40¬∞C to +85¬∞C Voltage Supply : 2.97V to 3.63V Power Consumption : 132mA typical Package Options : 48-LQFP (7x7mm) Cost (Volume) : ~$2.00 per unit Development Ecosystem : Extensive documentation, libraries for multiple platforms Manufacturer : WIZnet.io (South Korea) Option B: Microchip ENC28J60 Interface : SPI (up to 20 MHz) Network Speed : 10 Mbps Ethernet only TCP/IP Stack : Software stack required (on microcontroller) Buffer Memory : 8 KB internal buffer Concurrent Connections : Limited by microcontroller implementation Protocols Support : Requires microcontroller implementation (typically lwIP) Temperature Range : 0¬∞C to +70¬∞C (commercial), -40¬∞C to +85¬∞C (industrial version) Voltage Supply : 3.1V to 3.6V Power Consumption : 160mA typical Package Options : 28-pin SPDIP, SOIC, SSOP, QFN Cost (Volume) : ~$2.50 per unit Development Ecosystem : Mature, widely used in Arduino and other platforms Manufacturer : Microchip Technology (USA) PUGH Matrix Analysis Scoring: Better than baseline (+1, +2), Same as baseline (0), Worse than baseline (-1, -2) Baseline: ENC28J60 (all scores = 0) Criteria Weight ENC28J60 W5500 Network Speed 1 0 (baseline) +1 (100 Mbps vs 10 Mbps) TCP/IP Implementation 1 0 (baseline) +1 (hardwired vs software) Microcontroller Overhead 1 0 (baseline) +1 (minimal vs significant) Buffer Size 1 0 (baseline) +1 (32KB vs 8KB) SPI Interface Performance 1 0 (baseline) +1 (80MHz vs 20MHz) Industrial Temperature Range 1 0 (baseline) 0 (standard -40¬∞C to +85¬∞C) Development Ecosystem 1 0 (baseline) 0 (both well-supported) Firmware Complexity 1 0 (baseline) +1 (simple socket programming) Open Internal Firmware 3 0 (baseline) -1 (Complex, Closed Source) Western Manufacturer 3 0 (baseline) -1 (South Korea) Auditable Sourcecode 3 0 (baseline) -2 (Closed Source) Total PUGH Score 1 0 (baseline) -6 Decision Selected: ENC28J60 While the W5500 is technically superior in every aspect and more easy to integrate, the ENC28J60 is a dumb device, which is, given to goal of maximum control, auditable software and upgradeable software, exactly what we want. And additionally it is from a 'western' manufacturer. Rationale Why ENC28J60 Over W5500 Dumb : The ENC28J60 has no complex firmware. Auditable Sourcecode : The main network code is in the microcontrollers firmware, which we have total control over. This allows us to show all relevant code for audits. Western Manufacturer : Because of supply chain considerations we want this project to contain only 'western' manufacturers. While technically South Korea is a western ally, it is still in the east. Trade-offs Accepted Cost Premium : The $0.50 additional cost per unit for the W5500 is justified by the significant performance advantages, reduced development complexity, and system resource savings. Lower Performance : The W5500 is superior in all aspects of performance. But the ENC28J60 is good enough to match the performance criteria. Consequences Positive ‚úÖ Minimal Performance : ENC28J60 provides enough network bandwidth for current needs ‚úÖ Physical Size : 28SSOP package requires slightly less PCB space ‚úÖ Industrial Reliability : Full industrial temperature range support ‚úÖ External Dependency : Reliance on a more generic controller with more alternatives Negative ‚ö†Ô∏è Resource Spending : More microcontroller overhead diminishes resources for other features ‚ö†Ô∏è Slightly Higher Cost : $0.50 cost premium per unit compared to W5500 ‚ö†Ô∏è More Complex Development : Software TCP/IP stack incraeses code complexity and development time Risks and Mitigation Supply Chain Risk : Establish multiple supplier relationships, consider inventory strategy Single-Source Component : Document adaptation path to alternative controllers if necessary Integration Complexity : Thoroughly validate the ENC28J60-RP2350 integration early in development Implementation Notes Performance Optimization Use burst SPI mode for maximum throughput (up to 25 MHz) Optimize buffer management for latency-sensitive applications) Follow-up Actions Procurement : Source ENC28J60 components from multiple suppliers to validate availability Prototyping : Develop initial integration test for RP2350 + ENC28J60 communication Performance Testing : Benchmark SPI communication speeds and TCP throughput Industrial Validation : Test operation across full temperature range Review Notes: &#10063; Validate pricing from multiple suppliers &#10063; Confirm SPI bus configuration with other peripherals &#10063; Verify EMI/EMC considerations with ENC28J60 placement &#10063; Test actual power consumption under various load scenarios "
},

{
    "id": 4,
    "uri": "arc42/adrs/ADR-005-buffer-allocation-strategy.html",
    "menu": "adrs",
    "title": "ADR-005: Ring Buffer Memory Allocation Strategy for UART2ETH",
    "text": " Table of Contents ADR-005: Ring Buffer Memory Allocation Strategy for UART2ETH Context Decision Drivers Primary Requirements Constraints Options Considered Option A: Static Worst-Case Allocation (Baseline) Option B: Protocol-Aware Multi-Pool Option C: Variable-Length with Fragmentation PUGH Matrix Analysis Weighted Scores Decision Rationale Why Static Allocation Over Multi-Pool (-10 score) Why Static Allocation Over Variable-Length (-23 score) Memory Efficiency Analysis Consequences Positive Negative Risks and Mitigation Implementation Notes Ring Buffer Entry Structure Memory Allocation Strategy Future Optimization Path Multi-Pool Implementation Strategy Protocol Size Prediction Migration Path Alternative Approaches Considered Per-UART Configurable Sizing Hybrid Static + Overflow Follow-up Actions ADR-005: Ring Buffer Memory Allocation Strategy for UART2ETH Status: ACCEPTED Date: 2025-07-27 Deciders: Architecture Team Consulted: Senior Developer Informed: Development Team Context The UART2ETH system requires a ring buffer allocation strategy for inter-core communication between Core 0 (UART processing) and Core 1 (network processing). Based on our solution strategy (Chapter 4), we use cache-aligned ring buffers with fixed-size entries to enable deterministic, high-performance data transfer. This ADR documents the critical decision between different buffer allocation approaches given our realistic packet size analysis: Maximum payload size : 1024 bytes (worst-case industrial protocol) Minimum payload size : 10 bytes (small sensor readings) Average payload size : 40 bytes (typical industrial data) The buffer allocation strategy directly impacts: Memory efficiency and utilization System determinism and real-time behavior Implementation complexity and maintainability Development timeline and risk This decision is architecturally significant because it affects the fundamental memory model of our dual-core architecture and determines whether we can achieve our non-negotiable requirements within the 520KB SRAM constraints of the RP2350. Decision Drivers Primary Requirements Industrial Reliability : Must enable deterministic, predictable behavior for industrial applications Static Memory Allocation : All memory must be allocated at compile time (no dynamic allocation) Sub-5ms Latency : Latency requirement limits buffering depth, reducing total memory impact Cache-Aligned Performance : Inter-core communication must be optimized for dual-core RP2350 TDD Implementation : Must be testable and maintainable using test-driven development Constraints Limited to 520KB SRAM total on RP2350 platform Static allocation only (no malloc/free) Cache-line alignment required (64-byte boundaries) Maximum 2-3 packets buffered per UART due to latency constraints Must support worst-case 1024-byte payload scenarios Options Considered Option A: Static Worst-Case Allocation (Baseline) Approach : Fixed ring buffer entries sized for maximum payload (1024 bytes + 16 bytes management = 1040 bytes per entry) Memory Usage : Each entry wastes 984 bytes when storing 40-byte average payloads (96% waste) Determinism : Completely predictable, compile-time allocation Implementation Complexity : Minimal - simple fixed-size array Cache Alignment : Straightforward alignment to cache boundaries Testing : Simple to test, no dynamic allocation edge cases Option B: Protocol-Aware Multi-Pool Approach : Three separate buffer pools sized for different payload ranges Small Pool: 64-byte entries (for ‚â§40 byte packets) Medium Pool: 256-byte entries (for 41-200 byte packets) Large Pool: 1024-byte entries (for 201-1024 byte packets) Memory Usage : Significantly more efficient (~20-30% waste vs 96%) Determinism : Still predictable, but requires pool management logic Implementation Complexity : Requires pool allocation logic, protocol size prediction Cache Alignment : More complex alignment across multiple pools Testing : Complex testing scenarios for pool exhaustion, allocation failures Option C: Variable-Length with Fragmentation Approach : Variable-length entries with fragmentation and reassembly Memory Usage : Most efficient possible memory utilization Determinism : Unpredictable due to fragmentation and reassembly timing Implementation Complexity : High - fragmentation logic, reassembly buffers Cache Alignment : Complex alignment with variable sizes Testing : Very complex testing for fragmentation edge cases PUGH Matrix Analysis Scoring: Better than baseline (+1, +2), Same as baseline (0), Worse than baseline (-1, -2) Baseline: Static Worst-Case Allocation (all scores = 0) Criteria Weight Static Worst-Case Multi-Pool Variable-Length Industrial Reliability 3 0 (baseline) -1 (pool management risk) -2 (fragmentation unpredictability) Memory Efficiency 2 0 (baseline) +2 (20-30% waste vs 96%) +2 (optimal utilization) Implementation Simplicity 3 0 (baseline) -1 (pool allocation logic) -2 (fragmentation complexity) Deterministic Behavior 3 0 (baseline) -1 (pool allocation timing) -2 (fragmentation timing) Testing Complexity 2 0 (baseline) -1 (pool edge cases) -2 (fragmentation edge cases) Development Timeline 2 0 (baseline) -1 (additional development) -2 (significant additional work) Cache Optimization 2 0 (baseline) -1 (multi-pool alignment) -2 (variable alignment complexity) Future Maintainability 1 0 (baseline) +1 (documented optimization path) -1 (complex maintenance) Weighted Scores Multi-Pool Total Score: Reliability: 3√ó(-1) = -3 Memory: 2√ó(+2) = +4 Simplicity: 3√ó(-1) = -3 Determinism: 3√ó(-1) = -3 Testing: 2√ó(-1) = -2 Timeline: 2√ó(-1) = -2 Cache: 2√ó(-1) = -2 Maintainability: 1√ó(+1) = +1 Total: -10 Variable-Length Total Score: Reliability: 3√ó(-2) = -6 Memory: 2√ó(+2) = +4 Simplicity: 3√ó(-2) = -6 Determinism: 3√ó(-2) = -6 Testing: 2√ó(-2) = -4 Timeline: 2√ó(-2) = -4 Cache: 2√ó(-2) = -4 Maintainability: 1√ó(-1) = -1 Total: -23 Decision Selected: Static Worst-Case Allocation Despite the significant memory inefficiency (96% waste in typical scenarios), static worst-case allocation scores highest in our weighted analysis due to our reliability-first architecture principles and aggressive sub-5ms latency requirements . Rationale Why Static Allocation Over Multi-Pool (-10 score) Reliability Trumps Efficiency: Industrial reliability is our non-negotiable #1 priority Static allocation provides completely predictable behavior No pool exhaustion scenarios or allocation failures Simpler testing with fewer edge cases Latency Constraint Mitigation: Sub-5ms requirement limits buffer depth to ~2-3 packets maximum Total memory waste: 4 UARTs √ó 3 packets √ó 1024 bytes = ~12KB 12KB waste is acceptable within 520KB total SRAM Implementation Risk Reduction: TDD requirement favors simpler, more testable implementation Aggressive delivery timeline cannot accommodate complex allocation logic Static allocation enables immediate development progress Why Static Allocation Over Variable-Length (-23 score) Variable-length fails completely on reliability and determinism Fragmentation creates unpredictable latency - incompatible with sub-5ms requirement Testing complexity would significantly impact TDD implementation Memory Efficiency Analysis Realistic Memory Impact: Worst-case buffer usage: 4 UARTs √ó 3 packets/UART √ó 1024 bytes/packet = 12KB total Percentage of available SRAM: 12KB / 520KB = 2.3% Total system memory budget impact: Acceptable Latency-Limited Buffering: Sub-5ms latency inherently limits packet accumulation Small buffer depths make absolute memory waste manageable Quality goal (latency) constraints enable architectural simplification Consequences Positive ‚úÖ Industrial Reliability : Completely predictable memory behavior ‚úÖ Development Velocity : Immediate implementation, no complex allocation logic ‚úÖ Testing Simplicity : Straightforward test scenarios, high confidence ‚úÖ Cache Optimization : Simple 64-byte alignment for optimal inter-core performance ‚úÖ Future Flexibility : Clear optimization path documented for later enhancement Negative ‚ùå Memory Inefficiency : 96% waste in typical scenarios (1024B allocated, 40B used) ‚ùå Resource Utilization : Suboptimal use of precious SRAM resource ‚ùå Scalability Limitation : Inefficiency grows with larger maximum packet sizes Risks and Mitigation Primary Risk: Memory Inefficiency Probability : High (96% waste is certain) Impact : Medium (limited by latency constraints to ~12KB total) Mitigation : Document multi-pool optimization path, monitor actual memory usage Secondary Risk: Future Scalability Probability : Low (latency requirements unlikely to change) Impact : Medium (could require architectural changes) Mitigation : Protocol-aware multi-pool approach documented as known optimization Implementation Notes Ring Buffer Entry Structure // Each entry = 1024 bytes payload + 16 bytes management + padding to cache line typedef struct { // Management Data (16 bytes) uint8_t uart_channel; // 0-3 uint8_t direction; // TX/RX uint8_t status; // FILLING/DRAINING/FULL/EMPTY uint8_t payload_length; // Actual data length (‚â§1024) uint32_t timestamp; // Fill timestamp uint32_t sequence_id; // For ordering/debugging uint32_t reserved; // Future use/alignment // Payload Data (1024 bytes fixed) uint8_t payload[1024]; // Fixed maximum size } __attribute__((aligned(64))) ring_entry_t; // Cache-aligned Memory Allocation Strategy Total Buffer Size : (available_memory - static_variables) / sizeof(ring_entry_t) - 1 entries Per-UART Allocation : Dynamic allocation from shared pool based on actual usage Overflow Policy : Drop oldest packets (deterministic behavior) Future Optimization Path When memory efficiency becomes critical (e.g., adding features that require more SRAM), implement Protocol-Aware Multi-Pool allocation: Multi-Pool Implementation Strategy // Future optimization - three separate pools typedef struct { ring_entry_t small_pool[SMALL_POOL_SIZE]; // 64-byte entries ring_entry_t medium_pool[MEDIUM_POOL_SIZE]; // 256-byte entries ring_entry_t large_pool[LARGE_POOL_SIZE]; // 1024-byte entries // Pool allocation logic pool_allocator_t allocator; } multi_pool_ring_buffer_t; Protocol Size Prediction Runtime Analysis : Monitor actual packet sizes during operation Protocol Configuration : Per-UART protocol profiles specifying expected size ranges Adaptive Allocation : Adjust pool usage based on observed patterns Migration Path Phase 1 : Implement size monitoring in current static allocation Phase 2 : Develop pool allocation logic with same interfaces Phase 3 : A/B test multi-pool vs static allocation Phase 4 : Switch to multi-pool if memory pressure requires it Alternative Approaches Considered Per-UART Configurable Sizing Concept : Compile-time configuration of maximum packet size per UART Rejection Reason : Adds complexity without addressing core efficiency problem Example : UART0=64B, UART1=128B, UART2=1024B, UART3=256B Hybrid Static + Overflow Concept : Small static buffers + large overflow buffer for rare large packets Rejection Reason : Violates deterministic behavior requirement Risk : Overflow scenarios create unpredictable timing Follow-up Actions Memory Monitoring : Implement runtime memory usage tracking in debug builds Size Analysis : Log actual packet sizes during development and testing Pool Design : Document detailed multi-pool implementation specifications Performance Validation : Benchmark static allocation performance characteristics Future Review : Schedule memory efficiency review after core implementation Review Notes: &#10063; Validate 12KB memory impact against other system memory requirements &#10063; Confirm cache-line alignment performance benefits on RP2350 &#10063; Review multi-pool optimization trigger conditions &#10063; Document protocol size prediction strategies &#10063; Establish memory usage monitoring in CI/CD pipeline "
},

{
    "id": 5,
    "uri": "arc42/chapters/08_concepts.html",
    "menu": "arc42",
    "title": "Cross-cutting Concepts",
    "text": " Table of Contents Cross-cutting Concepts Protocol Filtering Web Management Interface Error Handling Strategy Security Architecture Configuration Management Performance Optimization Cross-cutting Concepts Protocol Filtering Protocol filtering provides a configurable mechanism to determine packet boundaries in UART data streams. The system implements pluggable filters that analyze incoming byte streams to identify complete data units for efficient TCP transmission. Packet Determination Algorithm The protocol filter operates on incoming UART data to identify discrete packets using configurable delimiters and patterns: Basic Line-Based Filter Example Input stream: \"sensor1=23.5\\r\\ntemperature=18.2\\r\\nhumidity=65\\r\\n\" Delimiter: \"\\r\\n\" Output packets: - \"sensor1=23.5\" - \"temperature=18.2\" - \"humidity=65\" Filter Types The system supports multiple filter implementations: Line-based filters : Use configurable line terminators (\\r\\n, \\n, \\r) Fixed-length filters : Extract packets of predetermined byte count Delimiter-based filters : Use custom byte sequences as packet boundaries Timeout-based filters : Form packets after configurable idle periods Configuration Parameters Each UART channel supports independent filter configuration: Filter type selection Delimiter specification (for delimiter-based filters) Packet length (for fixed-length filters) Timeout values (for timeout-based filters) Maximum packet size limits Web Management Interface The web management interface provides system configuration and monitoring through a responsive web UI. Main Interface Mockup Network Configuration Panel Protocol Filter Configuration System Monitoring Dashboard OTA Update Interface Error Handling Strategy Hierarchical Error Management The system implements a three-tier error handling approach: Application Layer Errors * Protocol parsing failures * Configuration validation errors * User authentication failures Communication Layer Errors * UART framing/parity errors * TCP connection failures * Network timeout conditions System Layer Errors * Memory allocation failures * Hardware malfunction detection * Critical system resource exhaustion Error Recovery Mechanisms Each error category implements specific recovery procedures: Graceful degradation : Non-critical failures maintain partial functionality Automatic retry : Transient errors trigger configurable retry attempts Failover switching : Critical component failures activate backup systems User notification : All error conditions generate appropriate user feedback Security Architecture Authentication and Authorization Multi-level Access Control * Administrator: Full system configuration access * Operator: Monitoring and basic configuration changes * Guest: Read-only monitoring access Session Management * Token-based authentication with configurable expiry * Automatic session timeout after inactivity * Concurrent session limits per user role Data Protection Network Security * Configurable firewall rules per UART channel * Rate limiting for TCP connections * Intrusion detection for unusual traffic patterns Configuration Management Persistent Storage Configuration data persistence uses JSON format with schema validation: System settings (network, users, security) UART channel configurations (baud rate, protocol filters) Performance tuning parameters Historical statistics and logs Backup and Restore Automatic Backups * Daily configuration snapshots * Pre-update system state capture * Critical setting change tracking Manual Operations * Configuration export/import via web interface * Factory reset with selective data preservation * Remote backup to external storage systems Performance Optimization Buffer Management Dynamic Buffer Allocation * Adaptive buffer sizes based on data flow patterns * Memory pool management for high-frequency allocations * Garbage collection for unused buffer segments Flow Control * Back-pressure mechanisms for overloaded channels * Priority queuing for different data types * Load balancing across multiple TCP connections Monitoring and Metrics Real-time Performance Tracking * Throughput measurements per UART channel * Latency monitoring for end-to-end data flow * Resource utilization (CPU, memory, network) Historical Analysis * Trend analysis for capacity planning * Performance regression detection * Automated alerting for threshold violations "
},

{
    "id": 6,
    "uri": "arc42/chapters/03_context_and_scope.html",
    "menu": "arc42",
    "title": "Context and Scope",
    "text": " Table of Contents Context and Scope Business Context Technical Context Operating Mode Contexts Integration Architecture Future State Considerations Context and Scope Business Context Primary Stakeholders Stakeholder Role Primary Business Interactions Industrial Engineers Solution designers and specifiers Define networking requirements for automation projects, specify UART2ETH configurations for integrating legacy equipment into modern networks System Integrators Implementation specialists Deploy UART2ETH devices in customer facilities, configure networking parameters, integrate with existing SCADA and monitoring systems Field Technicians Installation and maintenance personnel Physical installation of devices, diagnostic troubleshooting, basic configuration changes, routine maintenance procedures Equipment Manufacturers Original equipment makers Embed UART2ETH into products to add networking capabilities, specify custom protocol filters, integrate with product lifecycle management Business Use Cases Legacy Equipment Integration: Industrial Engineers specify UART2ETH to network aging PLCs, sensors, and measurement instruments that lack modern connectivity. System Integrators deploy these solutions to extend equipment lifecycles and enable remote monitoring without costly equipment replacement. Infrastructure Problem Solving: Field installations requiring long cable runs or operating in electrically noisy environments use UART2ETH to overcome serial communication limitations through network-based transmission. Remote Access Enablement: SCADA systems and monitoring applications access distributed serial devices through UART2ETH bridges, enabling centralized control and data collection across geographically dispersed facilities. Technical Context Technical Interface Specifications Interface Type Technical Details Communication Pattern UART Ports (4x) Host System Interface UART/RS232/RS422, 300-500k baud, configurable parameters Bidirectional serial, protocol-agnostic Ethernet Port Network Interface 10BASE-TX, RJ45 connector, Auto-MDIX TCP/IP networking, DHCP/Static IP TCP Sockets Client Interface Ports configurable, single connection per port TCP client connections, application protocols Management Interface Configuration Interface Web UI (HTTP), configuration interface HTTP, JSON configuration OTA Update Interface Firmware Interface Secure update server, A/B partition management HTTP, signed firmware images Communication Protocols and Data Formats UART Communication: Raw serial data transmission (protocol-agnostic) Configurable baud rates: 300 bps to 500 kbps Support for custom frame formats and timing requirements Network Communication: TCP socket connections for data transmission JSON for configuration and management data Binary protocol passthrough with optional filtering HTTP for management and OTA updates Network Protocols: IPv4 with DHCP or static configuration NTP for time synchronization DNS for name resolution Operating Mode Contexts Gateway Mode Context Gateway Mode Data Flow: 1. Host System sends serial data using original protocol to UART2ETH 2. UART2ETH receives serial data and applies protocol filtering/optimization 3. Processed data is transmitted to Client Systems via TCP sockets 4. Client Systems send responses back through TCP connections 5. UART2ETH forwards responses to Host System via UART interface Full Bridge Mode Context Full Bridge Mode Data Flow: 1. Host System A sends serial data to UART2ETH A 2. UART2ETH A encapsulates serial data in TCP packets and transmits over network 3. UART2ETH B receives TCP packets and extracts original serial data 4. UART2ETH B forwards serial data to Host System B via UART 5. Bidirectional communication maintains transparent serial connection Integration Architecture Critical Dependencies Network Infrastructure Dependencies: Reliable Ethernet connectivity for TCP/IP communication Network switches with appropriate bandwidth and latency characteristics DHCP services for automatic IP configuration (or static IP management) Network time synchronization for accurate timestamping Power and Environmental Dependencies: 3.3V-24V power supply within industrial specifications Operating temperature range suitable for industrial environments Protection from electromagnetic interference in industrial settings Security Dependencies: Network firewall configuration to allow necessary TCP ports Firmware signing infrastructure for secure OTA updates Network segmentation appropriate for industrial security requirements Security and Compliance Boundaries Network Security: Cryptographic signatures for firmware validation and integrity Configurable TCP port ranges to support firewall policies Input validation and sanitization for all network interfaces Industrial Compliance: CE certification for European industrial markets Electromagnetic compatibility (EMC) for industrial environments Component sourcing from Western suppliers for regulatory compliance Audit trail for firmware updates and configuration changes Performance and Scalability Characteristics Performance Requirements: 500 kbps sustained throughput per UART port Sub-5ms end-to-end latency for real-time applications Concurrent TCP connections (one per UART port) Configurable buffering for latency vs. throughput optimization Scalability Considerations: Up to 4 simultaneous UART-to-TCP bridges per device Network deployment limited by IP address availability and network bandwidth Protocol filtering reduces network traffic for efficient bulk transfers A/B firmware updates enable fleet-wide updates without service interruption Future State Considerations Planned Integrations Enhanced Protocol Support: Additional protocol filters for common industrial protocols (Modbus, DNP3, IEC 61850) HTTPS/TLS on-the-wire encryption Advanced Management Features: Integration with network management systems (SNMP, NETCONF) Enhanced diagnostic and monitoring capabilities "
},

{
    "id": 7,
    "uri": "arc42/chapters/09_architecture_decisions.html",
    "menu": "arc42",
    "title": "Architecture Decisions",
    "text": " Table of Contents Architecture Decisions Hardware Platform Decisions Software Platform Decisions Implementation Strategy Decisions Decision Interdependencies Architecture Decisions This section references the Architecture Decision Records (ADRs) that document key technical decisions for the UART2ETH project. These decisions form the foundation of the system architecture and significantly influence capabilities, performance characteristics, and development approach. Hardware Platform Decisions ADR-001: Microcontroller Platform Selection - Documents the decision to use the Raspberry Pi RP2350 as the core microcontroller platform. ADR-002: Ethernet Controller Selection - Documents the decision to use the ENC28J60 as the Ethernet controller. Software Platform Decisions ADR-003: Programming Language Selection - Documents the decision to use C programming language for firmware development, considering team expertise, delivery timeline, and memory model constraints. ADR-004: Development Ecosystem Selection - Documents the decision to use Native Pico SDK + CMake development ecosystem for professional, industrial-grade development. Implementation Strategy Decisions ADR-005: Ring Buffer Memory Allocation Strategy - Documents the decision to use static worst-case allocation for inter-core communication buffers, prioritizing reliability and determinism over memory efficiency. Decision Interdependencies The ADRs reveal important interdependencies that influence architectural coherence: ADR-004 (Development Ecosystem) challenges ADR-002 (Ethernet Controller) : The ecosystem analysis revealed that ENC28J60 lacks mature RP2350 SDK integration, potentially requiring significant custom development effort and impacting industrial reliability goals. ADR-003 (C Language) reinforces ADR-004 (Native SDK) : The choice of C programming language aligns optimally with the Native Pico SDK approach, enabling direct application of team expertise. ADR-005 (Buffer Strategy) supports ADR-003 (C Language) : Static allocation strategy leverages C&#8217;s deterministic memory model and supports industrial reliability requirements. "
},

{
    "id": 8,
    "uri": "arc42/chapters/06_runtime_view.html",
    "menu": "arc42",
    "title": "Runtime View",
    "text": " Table of Contents Runtime View System Startup Sequence UART-to-TCP Data Flow TCP-to-UART Data Flow Ring Buffer Cache-Coherent Access Pattern Ring Buffer Overflow Handling Watchdog Health Monitoring Network Connection Handling Hardware-in-the-Loop Testing Scenario Performance and Timing Requirements Runtime View System Startup Sequence The system follows a carefully orchestrated startup sequence ensuring proper initialization of shared resources before concurrent operation begins. Startup Sequence Details: Basic System Init (Core 0 only): Clock configuration to operational frequency GPIO pin configuration for UART and SPI interfaces Memory controller initialization for cache-coherent operation Shared Infrastructure Init (Core 0 only): Ring buffer allocation across 4 memory banks (128 entries total) Log manager initialization with flash storage and debug UART output Watchdog timer configuration with 200ms timeout per core Core 1 Startup : Core 0 releases Core 1 from reset state If Core 1 fails to respond within timeout, system reset is triggered Concurrent Core-Specific Init : Core 0: UART hardware initialization, interrupt/DMA configuration Core 1: Network stack initialization, ENC28J60 setup, TCP socket creation Both cores register with watchdog system Critical Startup Requirements: - Shared infrastructure must be fully initialized before Core 1 startup - Core-specific initialization can proceed concurrently once both cores are active - Any startup failure triggers immediate system reset for fail-safe operation UART-to-TCP Data Flow This scenario demonstrates the complete data path from UART reception to TCP transmission, highlighting the cache-coherent ring buffer operation and inter-core coordination. Data Flow Key Points: Interrupt-Driven Reception : UART RX interrupt triggers immediate DMA setup for bulk transfer Cache-Coherent Allocation : Ring buffer entries use bank-striped allocation to avoid cache contention Metadata Management : Each entry includes channel, direction, timing, and sequence information Consumer Notification : Ring buffer signals Core 1 when data is ready for transmission Automatic Cleanup : Consumed entries are immediately marked for reuse Memory Bank Allocation Strategy: Entry 0: Bank 0 (0x20000000) - 1664 bytes (padded from 1088 bytes) Entry 1: Bank 1 (0x2000D000) - 1664 bytes (52KB stride) Entry 2: Bank 2 (0x2001A000) - 1664 bytes (52KB stride) Entry 3: Bank 3 (0x20027000) - 1664 bytes (52KB stride) Entry 4: Bank 0 (0x20001680) - 1664 bytes (next slot in Bank 0) ... 32 entries per bank √ó 4 banks = 128 total entries Total ring buffer memory: 4 √ó 52KB = 208KB TCP-to-UART Data Flow This scenario shows the reverse data path from TCP reception to UART transmission, demonstrating the bidirectional nature of the ring buffer system. Reverse Data Flow Characteristics: TCP Reception : lwIP stack triggers callback on Core 1 with received data Producer Allocation : Core 1 acts as producer, allocating ring buffer entries Channel Routing : TCP port number maps to specific UART channel for data routing Consumer Processing : Core 0 consumes entries and triggers UART transmission DMA Efficiency : Bulk transfers minimize CPU overhead for high-throughput operation Ring Buffer Cache-Coherent Access Pattern The ring buffer implementation uses bank-striped memory allocation to ensure cache coherency between cores without explicit synchronization overhead. Cache-Coherent Access Implementation: // Ring buffer entry calculation for cache coherency #define RING_BUFFER_BASE 0x20000000 #define BANK_SIZE (52 * 1024) // 52KB per bank #define ENTRIES_PER_BANK 32 #define ENTRY_SIZE 1664 // Padded from 1088 to align at bank boundaries #define TOTAL_ENTRIES 128 // 32 √ó 4 banks #define TOTAL_RING_MEMORY (4 * BANK_SIZE) // 208KB total typedef struct { uint32_t bank_id; // 0-3 uint32_t bank_offset; // Offset within bank void* entry_ptr; // Cache-aligned pointer } ring_entry_location_t; // Calculate cache-coherent entry address with bank striping ring_entry_location_t calculate_entry_location(uint32_t entry_index) { ring_entry_location_t loc; loc.bank_id = entry_index % 4; // Rotate through banks 0-3 loc.bank_offset = (entry_index / 4) * ENTRY_SIZE; loc.entry_ptr = (void*)(RING_BUFFER_BASE + (loc.bank_id * BANK_SIZE) + loc.bank_offset); return loc; } Cache Coherency Benefits: - No Explicit Synchronization : Bank striping eliminates cache line conflicts - Concurrent Access : Both cores can access ring buffer simultaneously - Predictable Performance : No cache coherency protocol overhead - Scalable Design : Adding more entries maintains cache efficiency Ring Buffer Overflow Handling When the ring buffer reaches capacity during data bursts, the drop-oldest policy ensures deterministic behavior without blocking either core. Overflow Handling Characteristics: Deterministic Behavior : Drop-oldest policy provides predictable response to overload Non-Blocking Operation : Neither producer nor consumer cores are ever blocked Comprehensive Logging : All overflow events are logged with detailed context Transparent Recovery : System continues normal operation after overflow Performance Preservation : Overflow handling adds minimal latency to normal operation Overflow Prevention Strategies: - Monitor ring buffer utilization via management interface - Adjust TCP connection parameters to reduce data bursts - Configure UART baud rates to match expected data flow - Use performance counters to identify problematic traffic patterns Watchdog Health Monitoring The dual-core watchdog system ensures system reliability by monitoring both cores independently and triggering recovery when failures are detected. Watchdog Implementation Details: Independent Monitoring : Each core has separate watchdog channel with 200ms timeout Background Task Integration : Keepalive signals sent during regular 100ms background tasks Failure Logging : All watchdog timeouts logged to log ring buffer (stored to flash) and debug UART (if enabled) Immediate Recovery : Hardware reset triggered immediately upon timeout detection Post-Reset Analysis : Failure logs available after system restart for diagnostics Watchdog Configuration: #define WATCHDOG_TIMEOUT_MS 200 #define BACKGROUND_TASK_MS 100 // Provides safety margin #define CORE0_WATCHDOG_CHANNEL 0 #define CORE1_WATCHDOG_CHANNEL 1 // Keepalive function called from background tasks void watchdog_keepalive(uint8_t core_id) { hw_watchdog_update(core_id); last_keepalive_timestamp[core_id] = get_system_time_ms(); } Network Connection Handling Network connections are managed dynamically with automatic recovery mechanisms to handle real-world network conditions. Connection Management Features: Dynamic Port Mapping : TCP ports 4001-4004 map to UART channels 0-3 respectively Connection Validation : Client connections validated against configured limits and permissions Automatic Buffering : Temporary data buffering during connection interruptions (30-second window) Graceful Recovery : Both graceful and ungraceful disconnection handling Comprehensive Logging : All connection events logged for diagnostics and monitoring Network Configuration Parameters: #define TCP_PORT_UART0 4001 #define TCP_PORT_UART1 4002 #define TCP_PORT_UART2 4003 #define TCP_PORT_UART3 4004 #define MAX_CONNECTIONS 4 // One per UART channel #define BUFFER_TIMEOUT_MS 30000 // 30 seconds Hardware-in-the-Loop Testing Scenario The hardware-in-the-loop (HiL) testing framework enables automated validation of system behavior using real RP2350 hardware with comprehensive data collection from multiple sources. HiL Testing Configuration: Development Machine Setup: # Network configuration ip addr add 10.10.10.11/24 dev eth0 # UART device mapping /dev/ttyUSB0 ‚Üí Debug UART (115200 8N1) - Debug output and flashing /dev/ttyUSB1 ‚Üí System UART 0 (230400 8N1) - Test channel 0 /dev/ttyUSB2 ‚Üí System UART 1 (230400 8N1) - Test channel 1 /dev/ttyUSB3 ‚Üí System UART 2 (230400 8N1) - Test channel 2 # UART 3 uses internal loopback for testing Device Network Configuration: #define DEVICE_IP_ADDR \"10.10.10.10\" #define DEVICE_SUBNET \"255.255.255.0\" #define DEVICE_GATEWAY \"10.10.10.1\" #define DEV_MACHINE_IP \"10.10.10.11\" // Test-specific ports #define TEST_LOG_PORT 8080 // Event log retrieval #define MGMT_PORT 80 // Management interface // UART Test Configuration #define DEBUG_UART_BAUD 115200 // /dev/ttyUSB0 - 8N1 #define SYSTEM_UART_BAUD 230400 // /dev/ttyUSB1-3 - 8N1 Test Data Collection Sources: Debug UART Output ( /dev/ttyUSB0 ): System startup messages Real-time performance counters Error and warning messages Watchdog timeout notifications TCP Event Log (Port 8080): Structured JSON event records Timing measurements with microsecond precision Ring buffer utilization statistics Network connection state changes System UART Responses ( /dev/ttyUSB1-3 ): Actual serial data transmitted by device Response timing verification Data integrity validation Protocol compliance testing TCP Socket Data (Ports 4001-4004): Network data transmission verification Connection establishment timing Error recovery behavior Multi-channel coordination Automated Test Scenarios: Throughput Testing : Sustained 500kBaud operation across all channels Latency Measurement : End-to-end timing from UART RX to TCP TX Stress Testing : Ring buffer overflow conditions and recovery Error Injection : Network disconnection, UART errors, power fluctuations Regression Testing : Automated validation of all critical scenarios The HiL testing framework ensures comprehensive validation of the UART2ETH system behavior under real-world conditions while maintaining the benefits of automated testing for continuous integration. Performance and Timing Requirements Critical Timing Specifications: Performance Metric Target Value Measurement Method Validation Criteria End-to-End Latency &lt; 5ms HiL timestamp correlation 99% of messages under 5ms Sustained Throughput 500kBaud per channel Long-duration data streaming No data loss over 1 hour Ring Buffer Access Time &lt; 100Œºs Hardware performance counters Cache-coherent bank access Watchdog Response Time &lt; 200ms Failure injection testing System reset within timeout Network Recovery Time &lt; 30 seconds Connection interruption tests Automatic reconnection success System Boot Time &lt; 5 seconds Power-on to operational state Ready for data processing "
},

{
    "id": 9,
    "uri": "arc42/chapters/01_introduction_and_goals.html",
    "menu": "arc42",
    "title": "Introduction and Goals",
    "text": " Table of Contents Introduction and Goals Requirements Overview Quality Goals Stakeholders Introduction and Goals Requirements Overview Purpose UART2ETH provides a hardware and firmware solution for bridging UART interfaces to TCP sockets, enabling network connectivity for legacy industrial equipment and embedded systems. Core Functional Requirements Hardware Capabilities: Support up to 4 independent UART interfaces 10Mbit network interface with RJ45 connector Networking Features: Each UART exposed as individual TCP socket on dedicated port Raw TCP socket communication for transparent data transmission Support for concurrent connections (1 TCP connection per UART) Operating Modes: Full Bridge Mode: Transparent UART-over-TCP for remote device connections Gateway Mode: Add networking capabilities to existing products without firmware modifications Firmware Management: Secure Over-The-Air (OTA) firmware updates A/B update mechanism for rollback capability Protocol Optimization: Custom pluggable serial protocol filters for efficient TCP packaging Configurable packet caching with ring buffer implementation Adjustable transmit timeouts for latency or bulk transfer optimization Target Use Cases Use Case Description Legacy Equipment Integration Connect PLCs, sensors, and measurement instruments to SCADA systems via network Infrastructure Problem Solving Overcome noise and cable length limitations in industrial environments System Integration Add networking to existing products without custom development effort Remote Device Access Enable distant connections to serial devices through Full Bridge mode Driving Forces Regulatory Compliance: Western-only component supply chain for regulatory compliance Anticipation of new regulations requiring updateable and auditable firmware CE certification requirement for hardware Market Requirements: Address gap left by discontinued commercial UART-to-TCP solutions Provide open source alternative to expensive or black-box commercial products Enable cost-effective networking solutions for system integrators Substantial per-unit cost savings when deploying multiple units in-house compared to commercial alternatives Technical Requirements: 500kBaud sustained throughput capability Sub-5ms latency for real-time applications Critical system uptime within environmental specifications Quality Goals The following quality goals are prioritized by importance to our major stakeholders (industrial engineers and system integrators): Priority Quality Goal Concrete Scenario 1 Reliability Critical system uptime for industrial applications A UART2ETH device deployed in a manufacturing line must maintain continuous operation for the duration that the connected hardware operates within environmental specifications. System failure should not occur due to software issues during normal operation. 2 Performance Real-time data transmission capabilities The system must sustain 500kBaud throughput with less than 5ms latency end-to-end. A PLC sending time-critical control data to a SCADA system must not experience delays that could affect industrial process control. 3 Compatibility Seamless integration with diverse industrial systems The system must work reliably with a broad range of custom baud rates and protocol parameters. It should reliably auto-negotiate ethernet connection parameters. 4 Usability Simple deployment without specialized knowledge A system integrator with basic understanding of serial communication and TCP/IP should be able to deploy and configure the device without extensive training. Configuration should be straightforward with clear error messages for common misconfigurations. 5 Maintainability Secure field updates without physical access Firmware updates must be deployable remotely via OTA mechanism with A/B rollback capability. A device installed in a remote location must be updatable without requiring on-site technician visits, while ensuring update integrity and system recovery from failed updates. Stakeholders Role/Name Contact Expectations Industrial Engineers End user organizations, manufacturing facilities Clear documentation of network integration capabilities, performance specifications, and compatibility with existing industrial equipment. Need confidence in reliability and uptime guarantees. System Integrators Engineering consultancies, automation solution providers Comprehensive deployment guides, configuration documentation, and troubleshooting procedures. Expect regulatory compliance documentation (CE certification) and clear cost-benefit analysis. Development Team Internal project contributors Detailed architectural decisions, coding standards, build procedures, and testing frameworks. Need clear module interfaces and dependencies for parallel development work. Hardware Engineers PCB designers, component selection specialists Hardware interface specifications, power requirements, environmental constraints, and component selection rationale. Need mechanical and electrical interface documentation. Field Technicians Installation and maintenance personnel Simple installation procedures, diagnostic capabilities, and field troubleshooting guides. Need clear error indicators and recovery procedures for common failure modes. Regulatory Authorities CE certification bodies, industrial standards organizations Compliance documentation, safety analysis, electromagnetic compatibility evidence, and audit trails for component sourcing and manufacturing processes. Open Source Community Contributors, adopters, derivative projects Clear licensing terms (GPL), contribution guidelines, architectural documentation enabling modifications and extensions. Expect maintainable and well-documented code structure. "
},

{
    "id": 10,
    "uri": "arc42/chapters/11_technical_risks.html",
    "menu": "arc42",
    "title": "Risks and Technical Debts",
    "text": " Table of Contents Risks and Technical Debts Risk Overview Detailed Risk Analysis Technical Debt Register Risk Mitigation Plan Risk Monitoring Risk Escalation Triggers Risks and Technical Debts Risk Overview Risk ID Risk Title Category Probability Impact Risk Level R-001 ENC28J60 Ecosystem Maturity Technical High High CRITICAL R-002 UART Hardware Resource Conflicts Technical High Medium HIGH R-003 No TLS/HTTPS Security Implementation Technical Medium High HIGH R-004 No UART Flow Control Implementation Technical High Medium HIGH R-005 Single Developer Knowledge Dependencies Organizational Medium High HIGH R-006 RP2350 Platform Learning Curve Organizational Medium Medium MEDIUM R-007 Component Supply Chain Availability External Low High MEDIUM R-008 Industrial Performance Requirements Business Medium High HIGH Detailed Risk Analysis R-001: ENC28J60 Ecosystem Maturity Risk Category Technical Description ENC28J60 ethernet controller lacks mature RP2350 SDK integration, requiring significant custom development effort and potentially impacting industrial reliability goals Probability High - No official RP2350 support exists, only individual open-source efforts Impact High - Could require months of custom lwIP integration development and create maintenance risks Risk Level CRITICAL Current Controls - Decision made to accept risk and proceed with ENC28J60 - Basic research completed on integration approaches - Alternative W5500 option identified Additional Mitigation - Allocate 2-4 weeks for custom integration development - Create fallback plan for W5500 migration if integration proves too complex - Establish contact with existing ENC28J60+RP2350 community projects Owner Senior Developer Timeline Early implementation phase (next 3 months) Early Warning Signs - Integration taking longer than 4 weeks - Stability issues with ethernet stack - Performance not meeting requirements Review Date Monthly during development R-002: UART Hardware Resource Conflicts Category Technical Description RP2350 has limited UART resources: only 3 PIO UARTs available, 1 hardware UART conflicts with debug UART, other hardware UART used for SPI Probability High - Hardware limitations are fixed constraints Impact Medium - Limits system to 3 UARTs instead of advertised 4, affects product specification Risk Level HIGH Current Controls - Issue documented in technical debt register - PIO UART implementation planned Additional Mitigation - Redesign system for 3 UARTs maximum - Investigate debug UART alternatives (SWD-only debugging) - Consider external UART expansion via I2C Owner Hardware Lead Timeline Hardware design phase Early Warning Signs - Debug UART conflicts discovered during testing - PIO UART performance insufficient Review Date During hardware design finalization R-003: No TLS/HTTPS Security Implementation Category Technical Description Current architecture does not include TLS/HTTPS support, creating security vulnerability for industrial applications Probability Medium - Not all deployments require TLS, but many industrial environments do Impact High - Could prevent deployment in security-conscious environments, data interception risk Risk Level HIGH Current Controls - Issue documented in technical debt register - TLS requirement identified for future implementation Additional Mitigation - Research mbedTLS integration with RP2350 - Plan TLS implementation for firmware v2.0 - Document security limitations clearly for v1.0 - Consider VPN-based security as interim solution Owner Security Lead Timeline Post-v1.0 release Early Warning Signs - Customer inquiries about TLS support - Security audit requirements emerge Review Date Quarterly R-004: No UART Flow Control Implementation Category Technical Description UART implementation lacks hardware flow control (RTS/CTS), risking data loss under high throughput conditions Probability High - High-speed UART communication commonly requires flow control Impact Medium - Data loss possible, but software buffering may mitigate for many use cases Risk Level HIGH Current Controls - Issue documented in technical debt register - Software buffering strategy implemented Additional Mitigation - Implement XON/XOFF software flow control - Add hardware flow control pins to hardware design - Document flow control limitations clearly - Test thoroughly with high-speed protocols Owner Firmware Lead Timeline During UART implementation Early Warning Signs - Data loss observed during testing - Customer requirements include flow control Review Date During UART testing phase R-005: Single Developer Knowledge Dependencies Category Organizational Description Critical project knowledge concentrated in individual team members, creating project continuity risk Probability Medium - Team changes can occur during project lifecycle Impact High - Could halt development if key person unavailable Risk Level HIGH Current Controls - Comprehensive arc42 documentation being created - ADR records document technical decisions Additional Mitigation - Implement pair programming for critical components - Create detailed technical documentation for all modules - Cross-train team members on RP2350 platform - Record design decision rationale thoroughly Owner Project Manager Timeline Throughout project Early Warning Signs - Key team member availability concerns - Knowledge gaps identified during reviews Review Date Monthly R-006: RP2350 Platform Learning Curve Category Organizational Description Team unfamiliarity with RP2350-specific features (PIO, dual-core, security) may slow development Probability Medium - Team has embedded experience but not RP2350-specific Impact Medium - Could extend development timeline, suboptimal implementations Risk Level MEDIUM Current Controls - ADR-004 selected Native Pico SDK for best platform access - Team has strong C and embedded background Additional Mitigation - Allocate time for RP2350 training sessions - Create proof-of-concept implementations for key features - Engage with Raspberry Pi developer community - Study official examples and documentation Owner Technical Lead Timeline Early development phase Early Warning Signs - Development taking longer than estimated - Suboptimal use of platform features Review Date Bi-weekly during development R-007: Component Supply Chain Availability Category External Description RP2350 and ENC28J60 component availability could be affected by supply chain disruptions Probability Low - Both components currently available from multiple suppliers Impact High - Could halt production if components unavailable Risk Level MEDIUM Current Controls - Multiple supplier sources identified - Components currently in stock at major distributors Additional Mitigation - Monitor component availability regularly - Establish relationships with multiple suppliers - Consider alternative component specifications (W5500 backup) - Plan component inventory for production runs Owner Supply Chain Manager Timeline Pre-production and production phases Early Warning Signs - Lead times extending beyond normal - Price increases indicating supply constraints Review Date Quarterly R-008: Industrial Performance Requirements Category Business Description System may not meet industrial performance requirements (latency, throughput, reliability) under real-world conditions Probability Medium - Performance requirements are aggressive for embedded system Impact High - Could prevent adoption in target industrial applications Risk Level HIGH Current Controls - Quality requirements documented in Chapter 10 - Performance testing planned - Static allocation strategy chosen for predictability Additional Mitigation - Implement comprehensive performance testing framework - Test with realistic industrial data patterns - Monitor performance metrics continuously - Plan performance optimization iterations Owner Performance Engineer Timeline Testing and validation phases Early Warning Signs - Performance tests failing targets - Latency spikes under load Review Date Weekly during testing Technical Debt Register The following technical debts have been identified and require future resolution: TD-001: UART Flow Control Description: No hardware flow control implementation for UART interfaces Impact: Potential data loss under high throughput conditions Priority: High Effort: Medium (2-3 weeks) Resolution Plan: Implement XON/XOFF software flow control and add hardware pins in next revision TD-002: TLS/HTTPS Security Description: No TLS/HTTPS security implementation for network communications Impact: Security vulnerability in industrial environments Priority: High Effort: High (4-6 weeks) Resolution Plan: Integrate mbedTLS library in firmware v2.0 TD-003: UART Resource Limitations Description: Only 3 UARTs available due to debug and SPI conflicts, not 4 as originally planned Impact: Product specification limitation Priority: Medium Effort: High (hardware redesign) Resolution Plan: Document limitation clearly, investigate external UART expansion options Risk Mitigation Plan Immediate Actions (Next 30 Days) &#10063; Allocate ENC28J60 integration development time (R-001) &#10063; Finalize UART hardware configuration to avoid conflicts (R-002) &#10063; Begin RP2350 platform training sessions (R-006) &#10063; Create detailed technical documentation templates (R-005) Short-term Actions (Next 90 Days) &#10063; Complete ENC28J60 integration prototype (R-001) &#10063; Implement comprehensive performance testing (R-008) &#10063; Document security limitations and alternatives (R-003) &#10063; Establish component supplier relationships (R-007) Long-term Actions (Next 6 Months) &#10063; Plan TLS implementation for v2.0 (R-003) &#10063; Evaluate hardware flow control addition (R-004) &#10063; Quarterly risk assessment reviews &#10063; Post-implementation risk validation Risk Monitoring Weekly Reviews Monitor ENC28J60 integration progress Review performance testing results Track component availability Monthly Reviews Assess risk mitigation progress Identify new risks from development discoveries Update risk levels based on current status Quarterly Reviews Complete comprehensive risk register review Validate mitigation effectiveness Update risk management process Review technical debt resolution progress Risk Escalation Triggers Critical : ENC28J60 integration proves unfeasible High : Performance targets consistently missed Medium : Key team member unavailability Any : New risks emerge that threaten project success "
},

{
    "id": 11,
    "uri": "arc42/chapters/12_glossary.html",
    "menu": "arc42",
    "title": "Glossary",
    "text": " Table of Contents Glossary Glossary Term Definition A/B Updates Dual partition firmware update strategy that maintains two separate flash memory partitions (A and B) containing different firmware versions. During updates, the new firmware is written to the inactive partition while the system continues running from the active partition. If the new firmware fails or becomes corrupted, the system can automatically rollback to the previous working version, ensuring system reliability and preventing brick situations in remote deployments. Arduino Open-source electronics platform consisting of both hardware boards (microcontroller development boards) and software (integrated development environment). Arduino provides a simplified programming framework with pre-built libraries and functions that abstract complex microcontroller operations, making embedded programming accessible to beginners while remaining powerful enough for professional applications. The Arduino ecosystem includes thousands of community-contributed libraries and shields (expansion boards). CI/CD Continuous Integration/Continuous Deployment - modern software development methodology that automates the building, testing, and deployment pipeline. CI automatically builds and tests code changes when developers commit to version control, catching integration issues early. CD extends this by automatically deploying tested code to production environments, reducing manual errors and enabling rapid, reliable software releases. Client System In Gateway Mode, the networked device or application that connects to UART2ETH via TCP sockets to communicate with legacy serial equipment. Client systems can be computers, servers, mobile devices, or other networked equipment that need to access serial devices remotely over Ethernet networks. Examples include monitoring software, configuration tools, or remote control applications. CMake Cross-platform, open-source build system generator that creates native build files (Makefiles, Visual Studio projects, Xcode projects) from platform-independent configuration files. CMake manages complex build dependencies, compiler flags, and linking requirements across different operating systems and compilers, simplifying the build process for C/C++ projects and enabling consistent builds across development teams. ENC28J60 Low-cost Ethernet controller chip from Microchip Technology that provides 10Base-T Ethernet connectivity via SPI interface. This single-chip solution includes MAC (Media Access Control) and PHY (Physical Layer) functions, making it popular for adding basic Ethernet capabilities to microcontroller projects. It requires external TCP/IP stack implementation and offers a cost-effective alternative to more integrated solutions. Full Bridge Mode UART2ETH operating mode that creates a transparent network bridge between two serial devices located at different physical locations. Both devices communicate through their UART interfaces as if they were directly connected with a serial cable, but the connection is actually routed through TCP/IP networks. This mode enables legacy serial equipment to communicate across long distances, through existing network infrastructure, without requiring protocol modifications. Gateway Mode UART2ETH operating mode that adds network connectivity to existing serial-only equipment without modifying the original device. The UART2ETH device acts as a protocol gateway, translating between the legacy device&#8217;s serial communication and modern TCP/IP networking. This allows multiple network clients to simultaneously access serial equipment, enabling remote monitoring, configuration, and control of industrial equipment, embedded systems, or test instruments. Host System The serial equipment or device connected to UART2ETH&#8217;s physical UART interface. In Gateway Mode, this is typically legacy industrial equipment, embedded systems, or test instruments that only support serial communication. In Full Bridge Mode, both endpoints are considered Host Systems. Host Systems are unaware of the network translation and continue using their native serial protocols. HW UART Hardware Universal Asynchronous Receiver-Transmitter - dedicated silicon circuitry within microcontrollers that handles serial communication at the hardware level. HW UARTs provide precise timing, automatic start/stop bit handling, parity checking, and interrupt generation without CPU intervention. This contrasts with software-based UART implementations that consume CPU cycles and may have timing limitations, especially at higher baud rates. Misra-c Motor Industry Software Reliability Association C - comprehensive coding standard that defines strict guidelines for writing safety-critical C code. MISRA-C rules cover language subset restrictions, coding practices, and documentation requirements designed to eliminate common programming errors, undefined behaviors, and implementation-defined constructs. Originally developed for automotive software, it&#8217;s now widely used in aerospace, medical devices, and industrial control systems. OTA (Over-The-Air) Remote firmware update mechanism that allows devices to receive and install new firmware through their existing communication channels (WiFi, Ethernet, cellular) without requiring physical access. OTA updates enable field devices to receive bug fixes, security patches, and feature updates remotely, reducing maintenance costs and enabling rapid deployment of improvements across device fleets. Critical for IoT devices in remote or inaccessible locations. PIO Programmable Input/Output - specialized hardware feature of the Raspberry Pi RP2350 microcontroller that provides highly flexible, real-time I/O processing independent of the main CPU cores. PIO consists of state machines that can execute custom assembly-like programs to handle precise timing requirements for protocols like WS2812 LEDs, custom serial formats, or parallel interfaces. Each PIO block can run multiple state machines simultaneously, enabling complex I/O operations without CPU intervention. PLC (Programmable Logic Controller) Industrial computer designed for automation of manufacturing processes, machinery control, and industrial monitoring systems. PLCs are ruggedized for harsh industrial environments and provide real-time control with deterministic response times. They typically use ladder logic programming and offer extensive I/O capabilities for sensors, actuators, and communication networks. Common in factory automation, process control, and building management systems. platformio Modern, open-source ecosystem for embedded and IoT development that provides unified tooling across multiple microcontroller platforms, frameworks, and boards. PlatformIO includes cross-platform IDE, library manager, unit testing framework, remote debugging capabilities, and continuous integration support. It abstracts away toolchain complexity while supporting hundreds of development boards and frameworks including Arduino, ESP-IDF, STM32, and many others. Protocol Filter Pluggable software component within UART2ETH that intelligently processes and optimizes serial data streams before TCP transmission. Protocol filters can implement packet framing, data compression, error correction, or protocol-specific optimizations to reduce network bandwidth, improve latency, or enhance reliability. Examples include buffering strategies for bulk data transfers, real-time filtering for control systems, or custom packet structures for specific industrial protocols. RPI RP2350 Second-generation microcontroller chip from Raspberry Pi Foundation featuring dual ARM Cortex-M33 cores running up to 150MHz, 520KB SRAM, advanced security features, and flexible I/O capabilities including PIO state machines. The RP2350 provides enhanced performance and security compared to the original RP2040, making it suitable for industrial applications requiring real-time processing, secure communications, and complex I/O handling. SCADA (Supervisory Control and Data Acquisition) Industrial control system architecture used for monitoring and controlling large-scale processes across multiple locations. SCADA systems collect data from remote sensors and equipment, provide centralized monitoring through human-machine interfaces (HMIs), and enable operators to control distributed processes. Common in utilities (power grids, water treatment), manufacturing, and transportation systems where real-time monitoring and control of geographically dispersed equipment is essential. SPI Ethernet Controller Ethernet controller chip that communicates with microcontrollers through the Serial Peripheral Interface (SPI) protocol rather than parallel buses. These controllers handle the complex Ethernet physical layer operations (signal encoding, collision detection, carrier sensing) while presenting a simple SPI interface to the host microcontroller. This approach reduces pin count requirements and simplifies PCB design while providing reliable network connectivity for embedded systems. SPI TCP/IP Controller Integrated circuit that implements the complete TCP/IP protocol stack in hardware and communicates with host microcontrollers via SPI interface. These chips handle all network protocol processing (IP, TCP, UDP, ARP, DHCP) independently, presenting socket-based APIs through SPI commands. This offloads complex network processing from the main microcontroller, simplifying firmware development and improving real-time performance for applications requiring both networking and real-time control. TCP Socket Network communication endpoint that provides reliable, ordered, and error-checked delivery of data streams between applications over IP networks. TCP sockets establish connections, handle flow control, retransmission of lost packets, and ensure data integrity through checksums and acknowledgments. Unlike UDP, TCP guarantees that data arrives in the correct order and without errors, making it essential for applications requiring reliable data transmission such as file transfers, web browsing, and industrial control protocols. UART (Universal Asynchronous Receiver-Transmitter) Serial communication protocol and hardware interface that transmits data character by character without requiring a shared clock signal between communicating devices. UART uses start and stop bits to frame each character, with configurable data bits (5-9), parity (none, even, odd), and stop bits (1, 1.5, 2). This asynchronous approach makes UART simple to implement and widely compatible, leading to its extensive use in embedded systems, industrial equipment, and debugging interfaces. UART2ETH Complete hardware and firmware solution that bridges between UART serial interfaces and TCP/IP Ethernet networks, supporting up to 4 simultaneous UART connections. The system provides bidirectional data translation, protocol filtering, secure OTA updates, and flexible operating modes (Gateway and Full Bridge) to enable legacy serial equipment integration with modern networks. Built on the RPI RP2350 platform with support for various Ethernet controller options. W5500 Fully integrated Ethernet controller from WIZnet that combines 10/100 Ethernet MAC, PHY, and a complete TCP/IP protocol stack in a single chip. The W5500 communicates with host microcontrollers via SPI and provides hardware-accelerated socket operations, automatic packet processing, and wake-on-LAN capabilities. Its integrated approach simplifies network integration for embedded systems by handling all low-level networking operations transparently, allowing developers to focus on application logic rather than network protocols. "
},

{
    "id": 12,
    "uri": "arc42/chapters/05_building_block_view.html",
    "menu": "arc42",
    "title": "Building Block View",
    "text": " Table of Contents Building Block View Whitebox Overall System Level 2 Level 3 Building Block View Whitebox Overall System The UART2ETH system follows a dual-core separation strategy that provides fault isolation while achieving hardware-driven performance. The system is decomposed into ten major building blocks that each handle distinct responsibilities in the UART-to-TCP bridge functionality. Motivation The dual-core separation strategy from our solution approach drives this decomposition to achieve: Fault isolation : Each core has distinct responsibilities to prevent cascading failures Performance optimization : Hardware-driven I/O with software control for real-time requirements Industrial reliability : Predictable behavior through static allocation and deterministic interfaces Bidirectional communication : Both UART and TCP interfaces require full-duplex operation System coordination : Global state machine ensures consistent system behavior across cores Comprehensive monitoring : Log Manager with performance data collection provides visibility and diagnostics Configuration persistence : Configuration Manager ensures settings survive power cycles and support factory operations Predictable maintenance : Periodic background processing ensures system housekeeping at regular intervals Automatic recovery : Watchdog system provides fault detection and recovery capabilities Contained Building Blocks Name Responsibility Core 0 UART Subsystem Manages all 4 UART interfaces with interrupt/DMA handling. Performs bidirectional stream-to-packet conversion for communication with the ring buffer system. Core 1 Network Subsystem Implements TCP/IP stack and Ethernet controller interface with interrupt/DMA handling. Copies packets from and to the network stack and manages TCP socket connections. Ring Buffer Communication Provides bidirectional inter-core data transfer using a shared memory pool with cache-aligned, mutex-protected buffers. Handles dynamic burst allocation by being channel and driection agnostic. Management Interface Offers web-based configuration, monitoring, and administration through HTTP server with authentication, statistics collection, and configuration UIs. OTA Update System Manages secure firmware updates with A/B partition management, signature validation, and automatic rollback capabilities. Global State Machine Coordinates overall system state across both cores including boot sequence, operational modes, error handling, and update states. Provides centralized state synchronization and transition control. Log Manager Collects, formats, and stores system-wide events, errors, performance data, and diagnostic information from all components. Provides log rotation, filtering, and integration with management interface for diagnostics. Configuration Manager Manages persistent storage of all system settings including UART parameters, network configuration, user preferences, and system options. Provides factory defaults, parameter validation, configuration versioning, and backup/restore functionality. Periodic Background Process Executes system maintenance tasks every 100ms including statistics collection, connection cleanup, buffer maintenance, session management, configuration backup, and system health checks. Watchdog System Monitors system health through heartbeat signals from all major components. Detects failures, logs recovery events, and triggers automatic system recovery or reset when necessary. Important Interfaces Ring Buffer Interface Shared Pool Design : Single buffer pool serves both directions dynamically Core 0 : Producer (UART RX) + Consumer (UART TX) using shared pool Core 1 : Producer (TCP RX) + Consumer (TCP TX) using shared pool Entry Format : Fixed 1088-byte entries (64-byte header + 1024-byte payload) Synchronization : Mutex-protected operations for shared pool access Overflow Policy : Drop-oldest across entire pool (direction-agnostic) Network Interface External : 10BASE-T Ethernet, RJ45 connector (ENC28J60 limitation) Internal : SPI to ENC28J60 controller, software TCP/IP stack (lwIP) UART Interface Hardware : 4 independent UART channels with configurable parameters Protocols : UART/RS232/RS422 support with 300-500kBaud range Configuration : Per-channel baud rate, data bits, stop bits, parity settings Global State Machine Interface States : BOOT, INITIALIZING, OPERATIONAL, ERROR, UPDATE_MODE, RECOVERY Inter-core : Shared state variables with atomic updates and cache coherency Transitions : Event-driven state changes with validation and rollback capability Synchronization : Cross-core state synchronization using FreeRTOS primitives Logging Interface Log Levels : DEBUG, INFO, WARN, ERROR, CRITICAL with configurable filtering Storage : Circular buffer in RAM with optional flash persistence Format : Structured logging with timestamps, component ID, and severity Performance Data : Throughput metrics, latency measurements, resource utilization Access : Real-time log streaming via management interface Configuration Manager Interface Storage : Persistent flash storage with wear leveling and redundancy Settings Categories : UART parameters, network config, user accounts, system options Validation : Parameter range checking, conflict detection, dependency validation Factory Reset : Restore to known-good defaults with version migration Backup/Restore : Configuration export/import for deployment and recovery Periodic Process Interface Timer : Hardware timer interrupt every 100ms (10Hz frequency) Task Queue : Priority-based maintenance task scheduling Execution : Non-blocking operations with bounded execution time Health Reports : Regular status updates to watchdog system Watchdog Interface Heartbeat : Component-specific periodic health signals Thresholds : Configurable timeout values per monitored component Recovery Actions : Graduated response from warnings to system reset Hardware Integration : RP2350 hardware watchdog timer as final safety net Level 2 Whitebox Core 0 UART Subsystem The Core 0 UART Subsystem specializes in handling all UART communication with dedicated hardware management, interrupt processing, and bidirectional data conversion between stream and packet formats. Motivation Core 0 specialization enables real-time UART processing without interference from network operations. The bidirectional packet conversion allows seamless translation between continuous UART streams and discrete network packets. Contained Building Blocks Name Responsibility UART Hardware Manager Direct control of 4 UART channels with configurable parameters (baud rate, data bits, parity). Manages hardware registers and status monitoring. Interrupt Handler Processes time-critical UART events (RX data available, TX buffer empty) with minimal latency for real-time performance. DMA Controller Optimizes bulk data transfers in both directions to reduce CPU load and improve throughput for high-baud applications. Packet Assembler Converts incoming UART streams into fixed-size packets for ring buffer storage. Handles framing and timestamp metadata. Packet Disassembler Extracts UART data from ring buffer packets and converts back to continuous streams for transmission. Ring Buffer Interface Provides producer operations (UART RX data) and consumer operations (UART TX data) with proper synchronization. Whitebox Core 1 Network Subsystem The Core 1 Network Subsystem manages all network communication including TCP/IP protocol processing, Ethernet controller interface, and bidirectional packet routing between ring buffer and network clients. Motivation Core 1 specialization allows network processing to operate independently from time-critical UART operations. The modular design enables efficient TCP/IP processing while maintaining clear separation between hardware drivers and application logic. Contained Building Blocks Name Responsibility lwIP TCP/IP Stack Complete software-based TCP/IP implementation providing standard network protocols and socket interfaces. ENC28J60 Driver Low-level SPI driver for the 10BASE-T Ethernet controller, handling frame transmission and reception. Socket Manager Manages TCP socket connections with one dedicated socket per UART channel. Handles connection lifecycle and error recovery. Packet Router Maps UART channel numbers to TCP port numbers and routes data bidirectionally between network and ring buffer interfaces. Packet Assembler Converts incoming TCP data streams into ring buffer packets for transmission to Core 0. Packet Disassembler Extracts data from ring buffer packets and formats for TCP transmission to network clients. Ring Buffer Interface Provides producer operations (TCP RX data) and consumer operations (TCP TX data) with shared pool access. Whitebox Ring Buffer Communication System The Ring Buffer Communication System provides the critical inter-core communication mechanism using a shared memory pool that dynamically handles bursts from either direction while maintaining deterministic behavior. Motivation The shared buffer pool design provides elegant burst handling by allowing dynamic allocation to whichever direction needs capacity. This approach is more efficient than fixed per-direction pools and gracefully handles real-world traffic patterns. Contained Building Blocks Name Responsibility Shared Buffer Pool Single memory pool that dynamically serves both UART‚ÜíTCP and TCP‚ÜíUART directions with fixed-size entries. Mutex Manager Provides thread-safe access to the shared pool using FreeRTOS mutexes and semaphores for inter-core synchronization. Memory Manager Handles allocation and deallocation of fixed-size buffer entries with cache-aligned addressing for optimal performance. Overflow Handler Implements drop-oldest policy when buffer reaches capacity, ensuring deterministic behavior under overload conditions. Statistics Collector Tracks buffer utilization, message counts, throughput metrics, and error conditions for monitoring and diagnostics. Whitebox Log Manager The Log Manager provides system-wide event logging and performance data collection through lock-free interfaces that ensure real-time operations on both cores are never blocked by logging activities. Motivation Lock-free logging interfaces prevent real-time operations from being blocked by logging activities. The dual-interface design allows each core to log independently without synchronization overhead, while the ring buffer provides bounded memory usage and predictable performance. Contained Building Blocks Name Responsibility Lock-Free Interface Core 0 Provides atomic write operations for Core 0 components. Uses lock-free algorithms to ensure UART processing is never blocked by logging operations. Lock-Free Interface Core 1 Provides atomic write operations for Core 1 components. Ensures network processing continues uninterrupted during logging activities. Event Log Ring Buffer Circular buffer storing formatted log entries with fixed-size allocation. Implements overwrite-oldest policy to handle log bursts without memory allocation. Log Entry Formatter Converts raw log data into structured entries with timestamps, component IDs, severity levels, and formatted messages for consistent log format. Log Level Filter Runtime-configurable filtering based on severity levels and component masks. Reduces storage overhead by filtering out debug messages in production. Performance Data Collector Aggregates performance metrics from both cores including throughput calculations, latency measurements, and resource utilization statistics. Log Query Interface Provides search and retrieval capabilities for both real-time log streaming and historical log access via the management interface. Log Persistence Manager Handles optional flash storage with log rotation, compression, and archival. Manages persistent log files for post-mortem analysis. Important Interfaces Lock-Free Logging Interface Atomic Operations : Single-writer, multiple-reader lock-free ring buffer Non-blocking : Log calls never block or yield the calling thread Bounded Time : Worst-case execution time guarantees for real-time systems Overflow Handling : Graceful degradation when log buffer fills Event Log Ring Buffer Structure Entry Size : Fixed 128-byte entries for predictable memory usage Buffer Size : Configurable (default 1024 entries = 128KB) Overflow Policy : Drop oldest entries when buffer is full Memory Layout : Cache-aligned for optimal performance Performance Data Interface Metrics Collection : Throughput, latency, error counts, resource usage Aggregation : Time-based windowing for trend analysis Real-time Access : Current performance data always available Historical Data : Configurable retention period for trend analysis Whitebox Management Interface The Management Interface provides comprehensive web-based administration through modular components handling authentication, configuration, and monitoring functions. Motivation The modular management interface design separates concerns between web serving, authentication, data collection, and configuration UIs. This enables independent development and testing of each component while providing a comprehensive administration solution. Contained Building Blocks Name Responsibility HTTP Web Server Processes HTTP/1.1 requests, serves static content (HTML/CSS/JS), provides REST API endpoints, and manages user sessions. Authentication System Handles user login validation, JWT session token management, role-based access control, and security header implementation. Statistical Data Module Collects real-time metrics from system components, maintains historical data, tracks performance counters, and monitors system health. UART Configuration UI Provides web interface for configuring UART channel settings, hardware control options, protocol filters, and parameter validation. TCP/IP Configuration UI Offers web interface for network settings, TCP port mapping, connection limits, and security configurations. Level 3 Whitebox Core 0 UART Handler Subsystem The Core 0 UART Subsystem specializes in handling all UART communication with dedicated hardware management, interrupt processing, and bidirectional data conversion between stream and packet formats. Motivation UART processing utilizing UART specific ISR and DMA transfers for maximum troughput. Contained Building Blocks Name Responsibility UART Hardware Manager Direct control of 4 UART channels with configurable parameters (baud rate, data bits, parity). Manages hardware registers and status monitoring. Interrupt Handler Processes time-critical UART events (RX data available, TX buffer empty) with minimal latency for real-time performance. DMA Controller Controls bulk data transfers in both directions DMA Channel Optimizes bulk data transfers in both directions to reduce CPU load and improve throughput for high-baud applications. Packet Assembler Converts incoming UART streams into fixed-size packets for ring buffer storage. Handles framing and timestamp metadata. Packet Disassembler Extracts UART data from ring buffer packets and converts back to continuous streams for transmission. Ring Buffer Interface Provides producer operations (UART RX data) and consumer operations (UART TX data) with proper synchronization. Whitebox Ring Buffer System Internal Structure The Ring Buffer System provides the foundational inter-core communication with detailed memory management, helper functions, and synchronization primitives. Purpose Provides efficient, thread-safe, bidirectional communication between cores with deterministic behavior and comprehensive monitoring capabilities. Internal Structure Memory Layout Manager Manages the physical organization of the ring buffer in memory with cache-aligned addressing and efficient index calculations. Ring Buffer Array : Contiguous memory block with cache-aligned entries Index Management : Head/tail pointers with wrap-around logic Memory Addressing : Base address + (index √ó entry_size) calculations Buffer Management Functions Core API providing the helper functions for ring buffer operations and monitoring. // Core buffer operations ring_entry_t* find_next_free_block(void); ring_entry_t* find_next_ready_block(uint8_t uart_channel, uint8_t direction); bool is_buffer_full(void); bool is_buffer_empty(void); // Statistics and monitoring uint32_t get_cached_message_count(void); uint32_t get_cached_message_count_by_channel(uint8_t uart_channel); uint32_t get_cached_message_count_by_direction(uint8_t direction); uint32_t get_free_block_count(void); uint32_t get_overflow_count(void); // Dropped messages uint32_t get_total_throughput_bytes(void); // Advanced operations ring_entry_t* peek_next_block(uint8_t uart_channel, uint8_t direction); void mark_block_ready(ring_entry_t* entry); void mark_block_consumed(ring_entry_t* entry); void reset_buffer_statistics(void); Memory Layout Structure Complete ring buffer system data structure with metadata, statistics, and synchronization primitives. typedef struct { // Ring buffer metadata (cache-aligned) volatile uint32_t head_index; // Producer index volatile uint32_t tail_index; // Consumer index volatile uint32_t entry_count; // Current entries uint32_t max_entries; // Buffer capacity // Statistics (cache-aligned) uint32_t total_produced; uint32_t total_consumed; uint32_t overflow_count; uint32_t underflow_count; // Synchronization mutex_t buffer_mutex; semaphore_t free_space_sem; semaphore_t data_ready_sem; // Entry array (cache-aligned) ring_entry_t entries[]; } ring_buffer_system_t; Data Entry Format Individual ring buffer entry structure used for both communication directions. typedef struct { // Management Data (16 bytes) uint8_t uart_channel; // 0-3 uint8_t direction; // RX_UART_TO_TCP / RX_TCP_TO_UART uint8_t status; // FILLING/DRAINING/FULL/EMPTY uint8_t payload_length; // Actual data length uint32_t timestamp; // Fill timestamp uint32_t sequence_id; // For ordering/debugging uint32_t next_in_use; // Packets in use (within ring buffer) are a single linked list uint32_t reserved; // Future use/alignment // Payload Data (1024 bytes max) uint8_t payload[1024]; // Fixed max size for worst case } ring_entry_t; Whitebox UART Hardware Manager Internal Structure The UART Hardware Manager provides unified control over all 4 UART channels with individual controllers, parameter management, and comprehensive status monitoring. Purpose Provides unified interface to all 4 UART channels with configurable parameters, comprehensive status monitoring, and efficient interrupt handling. Internal Structure UART Configuration Interface Complete configuration structure for UART channel parameters. typedef struct { uint32_t baud_rate; // 300-500000 bps uint8_t data_bits; // 5-8 bits uint8_t stop_bits; // 1-2 bits uint8_t parity; // NONE/ODD/EVEN bool flow_control; // Hardware flow control bool rs485_mode; // RS485 half-duplex mode } uart_config_t; UART Operations API Core function interface for UART channel operations. // Channel operations int uart_channel_configure(uint8_t channel, uart_config_t* config); int uart_channel_read(uint8_t channel, uint8_t* buffer, size_t length); int uart_channel_write(uint8_t channel, const uint8_t* data, size_t length); bool uart_channel_is_ready(uint8_t channel); uint32_t uart_channel_get_status(uint8_t channel); Status Monitoring Structure Comprehensive status tracking for each UART channel. typedef struct { bool carrier_detect; bool clear_to_send; bool data_set_ready; uint32_t rx_errors; uint32_t tx_errors; uint32_t frames_received; uint32_t frames_transmitted; } uart_channel_status_t; Whitebox Management Interface Internal Structure The Management Interface provides comprehensive web-based administration through specialized components for HTTP serving, authentication, statistics, and configuration management. Purpose Provides comprehensive web-based configuration, monitoring, and administration interface with modular components for different management aspects. Internal Structure HTTP Web Server Components Request Handler typedef struct { uint16_t port; // Default: 80 uint32_t max_connections; // Concurrent sessions char document_root[256]; // Static content path } webserver_config_t; int webserver_start(webserver_config_t* config); int webserver_register_endpoint(const char* path, http_handler_t handler); int webserver_send_response(int client_fd, http_response_t* response); Authentication System Components User Management typedef enum { AUTH_ROLE_ADMIN, // Full configuration access AUTH_ROLE_OPERATOR, // Monitor + basic config AUTH_ROLE_READONLY // Monitor only } auth_role_t; typedef struct { char username[32]; char password_hash[64]; // SHA-256 hash auth_role_t role; bool enabled; } user_account_t; bool authenticate_user(const char* username, const char* password); const char* create_session_token(const char* username); bool validate_session_token(const char* token); Statistical Data Components System Statistics Structure typedef struct { // Per-channel statistics struct { uint64_t bytes_transmitted; uint64_t bytes_received; uint32_t messages_transmitted; uint32_t messages_received; uint32_t error_count; uint32_t overflow_count; float average_latency_ms; uint32_t current_baud_rate; } uart_stats[4]; // Network statistics uint64_t tcp_bytes_sent; uint64_t tcp_bytes_received; uint32_t tcp_connections_active; uint32_t tcp_connections_total; // System statistics uint32_t uptime_seconds; uint32_t cpu_usage_percent; uint32_t memory_used_bytes; uint32_t ring_buffer_utilization_percent; } system_statistics_t; Configuration Interface Components UART Configuration Structure typedef struct { bool enabled; uart_config_t config; // From UART Hardware Manager char description[64]; // User-friendly name bool protocol_filter_enabled; char protocol_filter_type[32]; // \"SharkNet\", \"custom\", etc. } uart_channel_settings_t; Network Configuration Structure typedef struct { // Network configuration bool use_dhcp; char ip_address[16]; // \"192.168.1.100\" char subnet_mask[16]; // \"255.255.255.0\" char gateway[16]; // \"192.168.1.1\" char dns_primary[16]; char dns_secondary[16]; // Port mapping struct { uint16_t tcp_port; // 4001-4004 default bool enabled; uint32_t connection_timeout_ms; char allowed_clients[256]; // IP ranges: \"192.168.1.0/24\" } port_config[4]; // Security bool enable_firewall; char hostname[64]; uint16_t management_port; // Web UI port (default 80) } network_config_t; "
},

{
    "id": 13,
    "uri": "arc42/chapters/00_architecture_communication_canvas.html",
    "menu": "arc42",
    "title": "Architecture Communication Canvas",
    "text": " Table of Contents Architecture Communication Canvas .canvas ul { margin-left: 0px; padding-left: 1em; list-style: square; } .canvas tr:nth-child(1) td:nth-child(1), .canvas tr:nth-child(1) td:nth-child(2), .canvas tr:nth-child(2) td:nth-child(1), .canvas tr:nth-child(3) td:nth-child(1), .canvas tr:nth-child(4) td:nth-child(1) { background-color: #8fe4b4; border: 1px solid black; } .canvas tr:nth-child(1) td:nth-child(3), .canvas tr:nth-child(1) td:nth-child(4), .canvas tr:nth-child(4) td:nth-child(2) { background-color: #94d7ef; border: 1px solid black; } .canvas tr:nth-child(5) td:nth-child(1), .canvas tr:nth-child(5) td:nth-child(2) { background-color: #ffc7c6; border: 1px solid black; } Architecture Communication Canvas Designed for: UART2ETH Designed by: Development Team Value Proposition Provide a low-cost, open source, western-component based, regulatory-compliant alternative to expensive or black-box UART-to-TCP bridge solutions for adding networking capabilities to legacy equipment. Core Functions Full Bridge mode: Transparent UART over TCP for distant device connections Gateway mode: Add networking capabilities to products without development Up to 4 UARTs exposed as TCP sockets on individual ports Secure OTA firmware updates with A/B update mechanism Custom pluggable serial protocol filters for efficient TCP packaging Package caching with custom transmit timeouts for latency/bulk optimization Core Decisions - Good or Bad Good: RP2350 selection for open ecosystem, long-term support, and secure update capabilities Moving from ATMega328 due to baudrate inflexibility and security limitations Western-only component supply chain for regulatory compliance Bad: No major problematic decisions identified yet Strategic: Anticipating new regulations requiring updateable and auditable firmware Addressing gap left by discontinued commercial solutions Technologies Programming: C/C++ with Arduino framework Development: VSCodium IDE, PlatformIO build system Hardware: RP2350 microcontroller, ENC28J60 SPI Ethernet controller Protocols: Raw TCP sockets, HTTP for WebUI Security: RP2350 Boot ROM provided security mechanisms Infrastructure: GitHub runners for CI/CD Documentation: docToolchain with AsciiDoc Key Stakeholder Industrial engineers dealing with infrastructure challenges (noise, cable length issues) requiring networking solutions for existing equipment System integrators needing regulatory-compliant, ready-to-use networking solutions for their products without custom development Quality Requirements Performance: 500kBaud sustained throughput, &lt;5ms latency Reliability: Critical uptime as long as hardware operates within environmental specifications Security: Prevention of data distortion and lateral network movement attacks Usability: Users need basic understanding of serial communication and TCP/IP Scalability: 1 TCP connection per UART port Compliance: CE certification for hardware Business Context Data Sources: Legacy PLCs, sensors, measurement instruments, and older industrial equipment with serial interfaces but no networking capabilities Data Sinks: SCADA systems, custom data processing software, other UART2ETH devices (in Full Bridge mode) Network Environment: Industrial and household LANs operating at 10Mbit Dependencies: Only requires correctly routed network infrastructure No risky external interfaces or operational costs Components / Modules Hardware Components: * RP2350 microcontroller * Microchip ENC28J60 SPI Ethernet Controller * RJ45 connector with integrated magnetics * Crystal clock source * SPI EEPROM for firmware storage Software Modules: * TCP/IP communication module * UART instance modules (up to 4) * OTA update manager with A/B update support * Protocol filtering/packet splitting engine * Caching module with flexible ring buffer * Configuration management module * Optional WebUI module * PIO-based UART implementation (send/receive tasks on GPIO) Core Risks Primary security risk: Device compromise allowing data distortion or use as attack vector for lateral network movement Hardware component availability and supply chain disruptions Regulatory changes requiring additional compliance measures Performance degradation under high concurrent load scenarios Missing Information Testing framework selection not yet decided Specific cryptographic implementation details for OTA security WebUI design and user experience specifications Detailed protocol filter plugin architecture Performance benchmarking under various network conditions Industrial certification requirements beyond CE marking Software Architecture Canvas by Gernot Starke, Patrick Roos and arc42 Contributors is licensed under Attribution-ShareAlike 4.0 International "
},

{
    "id": 14,
    "uri": "arc42/chapters/10_quality_requirements.html",
    "menu": "arc42",
    "title": "Quality Requirements",
    "text": " Table of Contents Quality Requirements Quality Tree Quality Scenarios Quality Scenarios Integration Quality Scenario Priority Matrix Quality Requirements Summary Security-Industrial Operation Balance Quality Requirements Quality Tree The quality tree organizes our quality requirements hierarchically, derived from stakeholder expectations and our industrial embedded systems context. Priority levels reflect architectural significance and business impact. Priority Levels: Critical (1) : System failure without this quality - business showstopper High (2) : Essential for reliable operation and long-term maintenance High (3) : Significant impact on user satisfaction and adoption Important (4) : Affects usability, deployment efficiency, and operational monitoring Medium (5) : Enhances user experience and compatibility but system functional without them Desired (6) : Nice-to-have features for future releases and enhanced security Resource and Performance Context: Platform : RP2350 dual-core ARM Cortex-M33 at 150MHz, 520KB SRAM, 4MB Flash Network : ENC28J60 10BASE-T Ethernet controller via SPI Expected Load : Up to 4 concurrent UART channels at combined 500kBaud maximum throughput Quality Scenarios Reliability Requirements (Priority 1 - Critical) Scenario R1: Industrial Continuous Operation Quality Attribute Reliability Context Manufacturing environment with 24/7 operation during normal environmental conditions (temperature, humidity, power within specifications) Stimulus UART2ETH device deployed in production line handling PLC communication Response System maintains continuous operation without software-induced failure Response Measure 99.99% uptime during scheduled production hours (876 hours/year), maximum 0.876 hours downtime annually due to software issues Priority Critical (1) Rationale Manufacturing downtime costs thousands per minute; industrial systems require exceptional reliability for business viability Verification Extended operation testing for 100+ continuous hours with simulated industrial traffic patterns, watchdog timer validation, memory leak detection tools Scenario R2: Hardware Component Failure Recovery Quality Attribute Reliability Context Production deployment with active UART and network connections Stimulus Single hardware component failure (e.g., ENC28J60 controller malfunction) Response System logs error with timestamp and component identifier, maintains UART data buffering, activates error LED with specific blink pattern, continues UART processing while disabling affected network functions Response Measure Failure detection within 100ms, no data corruption in ring buffer, error LED pattern visible, automatic recovery within 2 seconds when component functionality restored Priority Critical (1) Rationale Hardware failures are inevitable; system must handle them gracefully to maintain industrial reliability standards Verification Fault injection testing using SPI line manipulation and network disconnection. Verified with oscilloscope timing measurements and data integrity checksums Scenario R3: Power Cycle Recovery Quality Attribute Reliability Context Industrial environment with occasional power fluctuations or maintenance shutdowns Stimulus Unexpected power loss followed by power restoration Response System restarts cleanly, restores previous configuration, resumes operation without manual intervention Response Measure Full operational restart within 10 seconds, 100% configuration preservation, automatic reconnection from previous TCP clients within 15 seconds Priority Critical (1) Rationale Power interruptions are common in industrial settings; system must resume operation automatically to avoid service calls Scenario R4: Memory Exhaustion Protection Quality Attribute Reliability Context High-throughput operation with all 4 UARTs active at maximum baud rates Stimulus Ring buffer approaches capacity due to traffic burst or consumer processing delays Response System applies drop-oldest policy deterministically, continues operation without crash or memory leak Response Measure No system crash under any traffic conditions, maximum 5% packet loss during extreme bursts (&gt;150% of sustained capacity), recovery to normal operation within 1 second after burst ends Priority Critical (1) Rationale Static memory architecture must handle overload gracefully; crashes are unacceptable in industrial applications Verification Traffic generation testing at 200% rated capacity for 30 minutes, memory usage monitoring, packet loss measurement with statistical analysis Performance Requirements (Mixed Priority: High/Important) Scenario P1: Real-time Industrial Control Latency Quality Attribute Performance Context PLC communicating time-critical control data to SCADA system via UART2ETH bridge Stimulus PLC sends control command that must reach SCADA system with minimal delay Response Data transmitted through UART‚ÜíRing Buffer‚ÜíTCP path with optimized processing Response Measure End-to-end latency &lt;5ms for 95% of packets under normal load (up to 300kBaud sustained across all channels) Priority High (3) Rationale Industrial control loops require predictable, low latency to maintain process stability and safety Verification Measured using hardware timestamp injection at UART TX and TCP packet capture analysis. Test with 10,000 message sequences under sustained 300kBaud load Scenario P2: Sustained High Throughput Quality Attribute Performance Context Data-intensive application requiring bulk data transfer (e.g., measurement data logging) Stimulus Continuous data stream at maximum specified throughput across multiple UART channels Response System maintains data flow without drops or significant queuing delays Response Measure Sustain 500kBaud combined throughput across all active channels for 8+ hour periods with &lt;0.1% packet loss Priority High (2) Rationale High-volume applications require consistent throughput to avoid data loss and maintain system efficiency Verification Automated throughput testing with UART traffic generators, network packet capture analysis, 24-hour continuous operation validation Scenario P3: Resource Utilization Under Load Quality Attribute Performance Context System operating at 80% of maximum specified capacity across CPU, memory, and network resources Stimulus Normal industrial traffic patterns with occasional bursts Response System maintains responsive operation with efficient resource usage Response Measure CPU utilization &lt;70%, memory usage &lt;80% of available RAM, network buffer utilization &lt;60% during normal operation Priority Important (4) Rationale Efficient resource usage ensures headroom for traffic spikes and maintains system responsiveness Scenario P4: Network Congestion Handling Quality Attribute Performance Context Network infrastructure experiencing intermittent congestion or high latency Stimulus TCP connection experiences delays or temporary packet loss Response System adapts transmission patterns while maintaining UART data flow integrity Response Measure Automatic TCP retry within 50ms, UART data buffering up to 2 seconds during network issues, no UART data loss during network recovery Priority High (2) Rationale Network infrastructure issues are common; system must adapt while protecting serial data integrity Security Requirements (Mixed Priority: Critical/Important/Desired) Scenario S1: Unauthorized Network Access Prevention Quality Attribute Security Context UART2ETH deployed in production network with potential access from unauthorized devices Stimulus Unauthorized device attempts TCP connection to UART bridge ports (4001-4004) Response System validates connection using IP whitelist and optional TLS client certificate authentication, rejects unauthorized connections with RST packet, logs security events with ISO 8601 timestamp and source details to encrypted flash storage Response Measure 100% of unauthorized connection attempts blocked within 10ms, zero false positives for whitelisted IPs, security events logged with integrity protection, system remains operational during connection flood attacks (up to 1000 attempts/second) Priority Desired (6) Rationale Industrial networks require protection against unauthorized access to prevent data interception and system manipulation Verification OWASP-based penetration testing with unauthorized IP addresses, automated port scanning from external networks, TLS certificate validation testing, connection flood testing with 1000+ concurrent attempts Scenario S2: Firmware Integrity Validation Quality Attribute Security Context OTA firmware update process or system boot sequence with secure boot enabled Stimulus System receives firmware image or boots from flash memory Response System validates cryptographic signature using embedded public key, verifies SHA-256 image hash, implements secure boot chain from RP2350 ROM, validates firmware version to prevent rollback attacks, rejects invalid firmware Response Measure 100% signature validation before execution using, invalid firmware rejected within 500ms, automatic rollback to previous version if post-update health check fails within 15 seconds, firmware version monotonically increasing Priority Critical (1) Rationale Firmware integrity ensures system operates only trusted code, preventing malicious modifications in industrial environments Verification Test with tampered firmware images using invalid signatures, downgrade attack testing with older firmware versions, signature validation timing measurements on RP2350 hardware, secure boot chain validation, rollback procedure validation Scenario S3: Configuration Data Protection Quality Attribute Security Context Device configuration contains network credentials and operational parameters Stimulus Power cycle, configuration backup Response System validates configuration integrity with HMAC-SHA256, keeps 2 copies configuration, uses monotonic revision counter to keep track of latest vaild revision Response Measure Configuration tampering or corruption detected with HMAC-SHA256 validation triggering rollback to latest valid version Priority Critical (1) Rationale Configuration data must not be corrupted Verification Flash memory hexdump analysis to verify HMAC-SHA256 and revision counter, configuration integrity validation after power cycles, forced corruption to verify configuration rollback Scenario S4: Communication Security Quality Attribute Security Context UART data transmitted over TCP connections in potentially untrusted network environments Stimulus Sensitive industrial data (PLC commands, sensor readings) transmitted between UART devices and network clients Response System provides optional TLS 1.3 encryption for TCP connections with industrial-grade cipher suites, maintains data integrity during transmission, implements connection authentication Response Measure TLS 1.3 available for all TCP connections, &lt;10ms additional latency for TLS handshake, 100% data integrity verification using TLS record layer, certificate-based client authentication supported Priority Desired (6) Rationale Industrial data may contain sensitive process information requiring protection during network transmission Verification Network packet capture analysis to verify TLS encryption, latency measurement with TLS enabled/disabled, certificate validation testing, man-in-the-middle attack testing Scenario S5: Security Event Logging and Monitoring Quality Attribute Security Context Industrial environment requiring audit trails and security incident detection Stimulus Security events including authentication failures, unauthorized access attempts, configuration changes, firmware updates Response System logs all security events to encrypted flash storage with tamper-evident integrity protection, provides secure export capability, maintains event timestamps with NTP synchronization Response Measure 100% of events logged with ISO 8601 timestamps, log integrity protected with HMAC-SHA256, encrypted log storage using device-unique keys, log retention for 1000 events, log export via HTTP Web UI Priority Important (4) Rationale Industrial systems require comprehensive audit trails for compliance and security incident investigation Verification Security event generation testing, log integrity validation, encrypted storage verification, timestamp accuracy testing, log export functionality testing Compatibility Requirements (Mixed Priority: Critical/Medium) Scenario C1: Diverse Industrial Protocol Support Quality Attribute Compatibility Context System integrator deploying UART2ETH with various industrial equipment (PLCs, sensors, measurement devices) Stimulus Configuration requests for non-standard baud rates, unusual frame formats, or custom protocol timing Response System accepts and maintains stable communication with diverse protocol requirements Response Measure Support for baud rates 300-500000, all standard frame formats (5-8 data bits, 1-2 stop bits, none/odd/even parity), stable operation with 99.9% of industrial serial devices Priority Medium (5) Rationale Industrial environments contain diverse legacy equipment; broad compatibility enables market adoption and reduces integration effort Verification Protocol compliance testing with representative industrial devices (PLCs from 3+ vendors, measurement instruments), baud rate accuracy measurement with oscilloscope Scenario C2: Network Infrastructure Integration Quality Attribute Compatibility Context Deployment in existing network infrastructure with various switches, routers, and network management systems Stimulus Connection to different network environments (managed switches, VLANs, different subnet configurations) Response System auto-negotiates network parameters and maintains stable operation Response Measure Successful auto-negotiation with 95% of standard Ethernet infrastructure, stable operation across different network topologies, DHCP and static IP support Priority Critical (1) Rationale Network environments vary significantly between sites; automatic adaptation reduces deployment complexity and support costs Scenario C3: SCADA System Integration Quality Attribute Compatibility Context Integration with existing SCADA/HMI systems from various vendors Stimulus SCADA system establishes TCP connection with specific protocol expectations or timing requirements Response System provides transparent TCP socket interface compatible with SCADA expectations Response Measure Successful integration with 90% of common SCADA systems, transparent protocol forwarding without modification, support for multiple simultaneous connections per UART Priority Medium (5) Rationale SCADA integration is primary use case; broad compatibility ensures market viability and reduces customer integration effort Usability Requirements (Mixed Priority: Important/Medium) Scenario U1: Field Technician Deployment Quality Attribute Usability Context Field technician with basic networking knowledge deploying device in industrial facility Stimulus Technician needs to configure device for first-time operation Response System provides intuitive configuration interface with clear guidance and validation Response Measure Complete basic configuration (IP settings, UART parameters, port mapping) within 15 minutes by technician with minimal training, configuration errors caught with helpful error messages Priority Important (4) Rationale Simple deployment reduces installation time, training costs, and field support requirements Scenario U2: Troubleshooting and Diagnostics Quality Attribute Usability Context System experiencing communication issues in production environment Stimulus Field technician or system integrator needs to diagnose and resolve connectivity problems Response System provides clear diagnostic information and status indicators Response Measure Problem identification within 5 minutes using web interface diagnostics, LED status indicators visible from 2 meters, error messages identify specific issue and suggest resolution steps Priority Medium (5) Rationale Clear diagnostics reduce troubleshooting time, minimize production downtime, and reduce support costs Scenario U3: Configuration Management Quality Attribute Usability Context System integrator managing multiple UART2ETH devices across different sites Stimulus Need to backup, restore, or replicate device configurations Response System provides configuration export/import functionality with validation Response Measure Complete configuration backup/restore within 2 minutes, configuration file validation with clear error reporting, bulk configuration deployment to multiple devices Priority Medium (5) Rationale Configuration management reduces deployment time for multiple devices and simplifies maintenance procedures Maintainability Requirements (Mixed Priority: Critical/High/Desired) Scenario M1: Secure Over-the-Air Updates Quality Attribute Maintainability Context Deployed devices requiring firmware update for bug fixes or feature enhancements Stimulus Administrator initiates OTA update from management server Response System securely downloads, validates, and applies firmware update with automatic rollback on failure Response Measure Update completion within 10 minutes, 100% signature validation, automatic rollback within 2 minutes if update fails, zero configuration loss during successful updates Priority High (2) Rationale Field updates are essential for long-term maintenance; secure OTA capability reduces service costs and improves security posture Verification OTA update testing with valid/invalid signatures, network interruption during update, rollback timing measurement, configuration persistence validation Scenario M2: A/B Partition Rollback Quality Attribute Maintainability Context Recently updated device experiencing issues with new firmware version Stimulus Automatic rollback trigger due to system health check failure or manual rollback command Response System switches to previous firmware version and restores operation Response Measure Rollback completion within 30 seconds, 100% restoration of previous functionality, all user configurations preserved during rollback process Priority Critical (1) Rationale Rollback capability ensures update safety and reduces risk of system unavailability due to problematic firmware Scenario M3: Development and Testing Support Quality Attribute Maintainability Context Development team implementing new features or debugging reported issues Stimulus Developer needs to analyze system behavior or verify fix implementation Response System provides comprehensive debugging interfaces and test capabilities Response Measure Debug interface access within 30 seconds, comprehensive logging of system events, test mode operation without affecting production traffic Priority Desired (6) Rationale Development efficiency directly impacts time-to-market and bug resolution speed, affecting overall product quality Quality Scenarios Integration Architectural Decision Impact These quality scenarios directly influence key architectural decisions documented in our ADRs: Hardware Platform Decisions: - Reliability Scenarios R1-R4 ‚Üí ADR-001: RP2350 Selection provides dual-core architecture for fault isolation - Performance Scenarios P1-P2 ‚Üí Static memory allocation strategy eliminates runtime allocation failures Software Architecture Decisions: - Performance Scenarios P1-P4 ‚Üí ADR-003: C Language Selection enables deterministic, real-time behavior - Reliability Scenarios R2-R4 ‚Üí Ring buffer design with drop-oldest policy provides predictable overload behavior Network Architecture Decisions: - Compatibility Scenarios C1-C3 ‚Üí ENC28J60 selection with software TCP/IP stack enables full protocol control and auditability Testing and Validation Framework Each quality scenario translates directly into test cases: Reliability Testing: - Extended operation testing (1000+ hours) to validate R1 - Fault injection testing for hardware failure scenarios (R2) - Power cycle testing with configuration persistence validation (R3) - Memory stress testing with overload conditions (R4) Performance Testing: - Real-time latency measurement under various loads (P1) - Sustained throughput testing for extended periods (P2) - Resource monitoring during peak operations (P3) - Network resilience testing with simulated congestion (P4) Compatibility Testing: - Protocol compliance testing with diverse industrial equipment (C1) - Network infrastructure compatibility testing (C2) - SCADA system integration testing (C3) Usability Testing: - Field deployment simulation with time measurements (U1) - Diagnostic effectiveness testing with problem scenarios (U2) - Configuration management workflow testing (U3) Maintainability Testing: - OTA update testing with various failure scenarios (M1) - A/B rollback testing with timing and data integrity validation (M2) - Development workflow testing and debugging interface validation (M3) Quality Scenario Priority Matrix The following table summarizes all quality scenarios by priority level: Priority Scenario ID Scenario Name Key Metric Critical (1) R1, R2, R3, R4, S2, S3, C2, M2 Industrial Operation, Hardware Failure, Power Recovery, Memory Protection, Firmware Integrity, Configuration Protection, Network Integration, A/B Rollback 99.99% uptime, &lt;100ms failure detection, 100% signature validation, automatic network compatibility High (2) P2, P4, M1 High Throughput, Network Congestion Handling, OTA Updates 500kBaud sustained throughput, &lt;10min OTA updates, network resilience High (3) P1 Real-time Industrial Control Latency &lt;5ms latency for 95% of packets Important (4) P3, S5, U1 Resource Utilization, Security Logging, Field Deployment &lt;70% CPU utilization, comprehensive audit trails, &lt;15min deployment Medium (5) C1, C3, U2, U3 Protocol Support, SCADA Integration, Diagnostics, Configuration Management 99.9% device compatibility, &lt;5min troubleshooting, configuration backup/restore Desired (6) S1, S4, M3 Network Access Control, Communication Security, Development Support TLS 1.3 encryption, unauthorized access blocking, debug interface access Quality Requirements Summary The quality scenarios establish measurable success criteria that guide both architectural decisions and validation approaches. Critical scenarios represent non-negotiable requirements where system failure would render the product unsuitable for industrial deployment. High priority scenarios significantly impact user satisfaction and market adoption. Lower priority scenarios enhance user experience and reduce operational costs. Security-Industrial Operation Balance Industrial systems require a careful balance between security measures and operational requirements: Security vs. Availability Trade-offs: - Security features (authentication, encryption) must not compromise the 99.99% uptime requirement - TLS encryption adds &lt;10ms latency, acceptable for industrial control loops - Security event logging uses &lt;1% of flash storage, preserving system resources Platform-Specific Security Considerations: - RP2350 hardware security features (secure boot, unique device ID) integrated into security architecture - Lightweight cryptographic algorithms chosen to minimize CPU overhead (&lt;5% utilization) - Static memory allocation prevents security-related memory leaks - Hardware random number generator used for cryptographic operations Fail-Safe Security Principles: - Security failures default to secure state (deny access, maintain logging) - Industrial operation continues during security incidents where possible - Critical security events trigger controlled degradation, not system shutdown - Recovery procedures restore both security and operational functionality These scenarios serve as the foundation for: - Architecture decision evaluation criteria - Test case development and acceptance criteria - Performance benchmarking and validation - Stakeholder communication about quality expectations - Risk assessment and mitigation planning - Security-operational trade-off analysis "
},

{
    "id": 15,
    "uri": "arc42/chapters/07_deployment_view.html",
    "menu": "arc42",
    "title": "Deployment View",
    "text": " Table of Contents Deployment View Operational Requirements Summary Deployment Environments Firmware Deployment Architecture Infrastructure Components Deployment Strategies Operational Procedures Configuration Management Deployment View Operational Requirements Summary Requirement Type Target Description Availability Zero-downtime updates A/B partition switching maintains device operation until manual reboot Security Signed firmware delivery Cryptographic signing, secure boot, initial key embedding at factory Reliability Automatic rollback Watchdog-based rollback mechanism for failed firmware updates Auditability Version tracking Git tags and commit checksums embedded in firmware builds Control Manual operations No remote device reboots, QA gatekeeping for all releases Deployment Environments Environment Overview Environment Specifications Environment Purpose Hardware Deployment Method Development Feature development and local testing Individual RP2350 devices per developer Direct flash programming QA Testing Release validation with real hardware Single testbench with RP2350 hardware Automated test deployment Production Live firmware distribution Customer-deployed field devices OTA HTTP downloads Factory Initial device provisioning Manufacturing test fixtures Flash programming + key embedding Firmware Deployment Architecture High-Level Architecture A/B Partition Strategy Infrastructure Components Build and Release Infrastructure Component Technology &amp; Configuration Purpose &amp; Responsibilities CMake Build System Pico SDK integration, firmware signing Compile source code, embed version info, sign binaries Developer Hardware Individual RP2350 devices Local development and unit testing QA Testbench Single automated test fixture with RP2350 Hardware-in-the-loop validation of release candidates Cloud OTA Server HTTP-based firmware distribution Serve approved firmware to field devices Key Management Secure cryptographic key storage Firmware signing keys, device authentication Security Architecture Security Layer Implementation Factory Key Embedding Cryptographic keys installed during initial manufacturing flash Firmware Signing All firmware builds cryptographically signed before distribution Secure Boot RP2350 ROM bootloader verifies firmware signatures before execution OTA Authentication Device authenticates with OTA server before firmware download Partition Verification Each partition validated before boot attempt Deployment Strategies Firmware Update Process Stage Process Validation &amp; Control Development Build CMake compilation with embedded version tags Local developer testing on real hardware QA Validation Automated testbench execution Hardware-in-the-loop testing, manual approval gate Production Release QA promotes approved firmware to OTA server Single gatekeeper model, full traceability Field Deployment Device pulls firmware via HTTP when configured Manual reboot required, automatic rollback protection A/B Partition Management Operational Procedures Version Management and Auditability Aspect Implementation Benefits Version Identification Git tags and commit checksums embedded in firmware Precise traceability of deployed firmware versions Build Reproducibility Deterministic build process with version tagging Ability to rebuild exact firmware for debugging Release Documentation QA approval records linked to firmware versions Clear audit trail for all production releases Field Identification Device reports firmware version via management interface Support teams can identify deployed firmware versions Rollback and Recovery Procedures Scenario Recovery Method Implementation Boot Failure Automatic rollback via watchdog timeout RP2350 ROM bootloader switches to backup partition Corrupted Download Signature verification failure Device rejects invalid firmware, retains current version Network Issues Download retry mechanism Device continues with current firmware, retries later Total Firmware Corruption Device replacement No field recovery possible when both partitions corrupted Monitoring and Maintenance Monitoring Aspect Implementation Firmware Version Tracking Git checksums embedded in firmware, reported via management UI Update Success Rate Device reports successful updates to management interface Rollback Events Watchdog rollback events logged in device memory OTA Server Health HTTP availability monitoring for firmware distribution Configuration Management OTA Server Configuration The UART2ETH device supports flexible OTA server configuration: Default Server : Company-hosted cloud OTA server for standard deployments Customer Servers : Configurable OTA server URL via management interface HTTP Protocol : Simple HTTP-based firmware downloads (no HTTPS requirement) Pull-based Updates : Devices initiate update checks, no push capability "
},

{
    "id": 16,
    "uri": "arc42/chapters/04_solution_strategy.html",
    "menu": "arc42",
    "title": "Solution Strategy",
    "text": " Table of Contents Solution Strategy Solution Approach Overview Technology Strategy Decomposition Strategy Quality Achievement Strategy Strategic Decisions and Trade-offs Implementation Strategy Risk Assessment and Mitigation Architecture Evolution Strategy Conclusion Solution Strategy Solution Approach Overview Fundamental Architecture: Dual-Core Separation + Interrupts/DMA Technology Strategy Core Technology Decisions Technology Area Strategic Decision &amp; Rationale Architecture Pattern Dual-core separation with interrupt/DMA - provides fault isolation while achieving hardware-driven performance Programming Language C with Native Pico SDK - leverages team expertise, provides full platform access, enables deterministic behavior Memory Management Static allocation only - enables industrial reliability through predictable behavior, no dynamic allocation risks Inter-Core Communication Cache-aligned ring buffers with mutexes - optimal performance with deterministic behavior Ethernet Controller ENC28J60 with software TCP/IP - \"dumb\" controller enables full code auditability and control Communication Architecture Ring Buffer Design: // Each entry = 1 cache line (64 bytes base + 1024 payload) typedef struct { // Management Data (16 bytes) uint8_t uart_channel; // 0-3 uint8_t direction; // TX/RX uint8_t status; // FILLING/DRAINING/FULL/EMPTY uint8_t payload_length; // Actual data length uint32_t timestamp; // Fill timestamp uint32_t sequence_id; // For ordering/debugging uint32_t reserved; // Future use/alignment // Payload Data (1024 bytes max) uint8_t payload[1024]; // Fixed max size for worst case } ring_entry_t; Memory Allocation Strategy: Buffer Size: (total_mem - static_vars) / sizeof(ring_entry_t) - 1 entries Cache Aligned: No core contention, optimal performance Overflow Policy: Drop oldest packets (deterministic, simple) Decomposition Strategy System Decomposition Approach Dual-core functional separation - Each core specializes in distinct responsibilities with clean interfaces through shared memory ring buffers. Major Components/Services Component/Service Responsibilities Key Interfaces Core 0 UART Manager All 4 UART interfaces, interrupt/DMA handling, stream-to-packet conversion Hardware UARTs, Ring buffer producer Core 1 Network Manager TCP/IP stack, ENC28J60 control, packet-to-network conversion Ring buffer consumer, SPI to ENC28J60 Ring Buffer System Inter-core communication, cache-aligned data transfer Shared memory + mutex interfaces HTTP Management UI Device configuration, diagnostics, OTA trigger HTTP server on Core 1 OTA Update System Secure firmware updates, A/B partition management Secure boot, flash management Component Interaction Strategy Interaction Principles: Core 0 ‚Üí Ring Buffer: UART streams converted to fixed-size packets, cache-aligned writes Ring Buffer ‚Üí Core 1: Packet consumption for TCP transmission Overflow Policy: Drop oldest packets (deterministic, simple) Priority: UART processing takes priority over HTTP UI Quality Achievement Strategy Quality Goal Implementation Quality Goal Architectural Mechanisms Validation Approach Reliability Core separation, static allocation, deterministic behavior, drop-oldest overflow Extended operation testing, fault injection, environmental testing Compatibility Protocol-agnostic packet handling, configurable UART parameters Testing with diverse industrial protocols, auto-negotiation validation Performance Interrupt/DMA driven I/O, cache-aligned buffers, hardware-optimized data paths Sustained 500kBaud testing, latency measurements, stress testing Cross-Cutting Concerns Strategy Cross-Cutting Concern Implementation Strategy Error Handling Graceful degradation, fault isolation between cores, deterministic error responses Memory Management Static allocation only, pre-calculated buffer sizes, cache-aligned data structures Security Secure OTA updates, A/B partitioning, auditable code paths Testing Host-based testing with abstracted semaphores, hardware-in-the-loop validation Strategic Decisions and Trade-offs Major Architectural Decisions Decision Rationale Trade-offs Dual-Core Separation Fault isolation + performance, leverages RP2350 capabilities Increased complexity vs single-core simplicity Fixed 1024-byte Packets Deterministic behavior, handles worst-case scenarios 96% memory waste (avg 40 bytes vs 1024 max) accepted for simplicity Drop-Oldest Overflow Deterministic, reliable behavior under overload Data loss vs flow control complexity Cache-Aligned Buffers Optimal inter-core performance Memory overhead vs efficiency Key Trade-off: Fixed Packet Size Inefficiency The Challenge: Realistic scenario: Max=1024 bytes, Average=40 bytes ‚Üí 96% memory waste Risk: Significant resource inefficiency in typical use cases Mitigation Rationale: Sub-5ms latency requirement limits buffering depth anyway (~2-3 packets maximum) Total waste limited: 4 UARTs √ó 3 packets √ó 1024 bytes = ~12KB (acceptable in 520KB system) Implementation simplicity enables reliable delivery Future Optimization Path: Protocol-aware multi-pool approach documented for later enhancement: Small Pool: 64-byte entries (for ‚â§40 byte packets) Medium Pool: 256-byte entries (for 41-200 byte packets) Large Pool: 1024-byte entries (for 201-1024 byte packets) Alternative Approaches Considered Alternative Why Not Selected Key Insight Single-Core Design Cannot achieve 4-UART + network performance simultaneously Core separation essential for real-time requirements Dynamic Memory Allocation Conflicts with industrial reliability requirements Static allocation mandatory for predictable behavior W5500 Ethernet Controller Hardware TCP/IP stack not auditable, conflicts with compliance goals \"Dumb\" controller enables full code control Implementation Strategy Development Approach Implementation Aspect Strategy Development Methodology Test-driven development with host-based testing using abstracted semaphores Testing Strategy Host simulation with pthread/threads, then hardware validation Risk Mitigation Single UART + single TCP proof-of-concept first Platform Abstraction Abstract semaphores/mutexes for host testing: platform_mutex_t , platform_semaphore_t Implementation Phases Phase 1: Proof of Concept Single UART + Single TCP socket Mock ring buffer with abstracted semaphores Host-based testing with thread simulation Validate core architecture concepts Phase 2: Full System Implementation All 4 UARTs on Core 0 Complete ring buffer system Full TCP/IP integration on Core 1 HTTP management UI Phase 3: Advanced Features Secure OTA implementation A/B update mechanism Industrial hardening and optimization Validation and Success Metrics Milestone Success Criteria Validation Method Ring Buffer Validation Concurrent producer/consumer without data corruption Host-based stress testing Performance Achievement 500kBaud sustained, &lt;5ms latency Hardware-in-the-loop measurement Reliability Demonstration 24+ hour continuous operation Extended testing under load Risk Assessment and Mitigation Strategic Risks Risk Probability/Impact Mitigation Strategy Fixed Packet Size Inefficiency High/Medium Document multi-pool optimization path, validate memory usage early Inter-Core Communication Complexity Medium/High Prove with host-based testing first, extensive validation Performance Under Load Medium/High Early prototyping, stress testing, hardware validation Architecture Evolution Strategy Future Optimization Path Protocol-Aware Enhancements: Multi-pool buffer management for memory efficiency Protocol-specific packet sizing based on message type analysis Dynamic buffer allocation per UART based on usage patterns Security and Compliance Evolution: Enhanced security features for evolving compliance requirements Extended audit trail capabilities Additional cryptographic features as regulations develop Performance Optimizations: Fine-tuned based on real-world deployment data Protocol filter optimizations Network stack performance improvements Success Factors Critical Dependencies: Early validation of ring buffer architecture with host-based testing Incremental implementation starting with single UART proof-of-concept Comprehensive testing at each phase before proceeding Key Assumptions: RP2350 dual-core performance meets concurrent processing requirements Cache-aligned ring buffers provide sufficient inter-core bandwidth Static memory allocation provides adequate resource management Monitoring and Adaptation: Continuous validation of memory efficiency in real deployments Performance monitoring under various industrial load scenarios Regular assessment of compliance requirement evolution Conclusion This solution strategy establishes UART2ETH as an \"unbreakable foundation with field-updateable capability\" through: Core Architectural Principles: Reliability-first dual-core separation Static allocation for predictable behavior Hardware-driven performance with software control Protocol-agnostic flexibility Strategic Advantages: Fault isolation enables industrial reliability Deterministic behavior supports real-time requirements Full code auditability meets compliance needs Incremental implementation reduces development risk Success Enablers: TDD approach with host-based validation Clear module boundaries for team development Documented optimization paths for future enhancement Strong foundation for scaling and feature evolution The strategy balances immediate reliability requirements with long-term flexibility, ensuring UART2ETH can serve as a robust industrial networking solution while maintaining the ability to evolve with changing requirements and regulations. "
},

{
    "id": 17,
    "uri": "arc42/chapters/02_architecture_constraints.html",
    "menu": "arc42",
    "title": "Architecture Constraints",
    "text": " Table of Contents Architecture Constraints Technical Constraints Organizational Constraints Economic Constraints Regulatory and Legal Constraints Architecture Constraints Technical Constraints Constraint Description Rationale Hardware Platform Must use RP2350 microcontroller as primary processing unit Provides required security features for OTA updates, sufficient processing power for 4 UART channels, and western supply chain compliance Component Sourcing All components must be sourced from western suppliers only Regulatory compliance requirement for target markets and supply chain security considerations Performance Requirements Minimum 500kBaud sustained throughput with sub-5ms latency per UART channel Industrial application requirements for real-time data transmission Network Interface 10Mbit Ethernet connectivity via SPI-based controller Cost constraints and sufficient bandwidth for target applications while maintaining hardware simplicity UART Channel Limit Maximum 4 independent UART interfaces Hardware resource limitations of chosen microcontroller platform and cost optimization Organizational Constraints Constraint Description Rationale Open Source License Complete system must be released under GPL license Leverage existing open source libraries and reduce implementation effort by reusing proven components Development Process Test-driven development (TDD) approach mandatory for all production code Quality assurance and maintainability requirements for industrial application reliability Documentation Standard Architecture documentation must follow arc42 template structure Standardized documentation approach for future maintainers and contributors Version Control GitHub-based development workflow with mandatory pull request reviews Code quality control and collaborative development coordination Economic Constraints Constraint Description Rationale Hardware Cost Hardware target price per unit must be significantly below commercially available solutions Competitive market positioning requires substantial cost advantage to justify adoption over established commercial products Development Effort Development effort must achieve return on investment within first year of deployment Resource allocation constraint limits project scope and complexity to ensure economic viability and timely market entry Regulatory and Legal Constraints Constraint Description Rationale CE Certification Hardware must achieve CE compliance for European market Legal requirement for commercial deployment in target markets Firmware Security Must implement secure boot and signed firmware update mechanisms Anticipated regulatory requirements for updateable industrial devices EMC Compliance Electromagnetic compatibility requirements for industrial environments Regulatory requirement and operational necessity in electrically noisy industrial settings Export Control No components or technologies subject to export restrictions Unrestricted distribution and deployment capability Patent Avoidance Must not infringe on existing patents in communication protocols or hardware interfaces Legal risk mitigation and freedom to operate requirements "
},

{
    "id": 18,
    "uri": "arc42/arc42.html",
    "menu": "-",
    "title": "image:arc42-logo.png[arc42] Template",
    "text": " Table of Contents Template 1. Introduction and Goals 1.1. Requirements Overview 1.2. Quality Goals 1.3. Stakeholders 2. Architecture Constraints 2.1. Technical Constraints 2.2. Organizational Constraints 2.3. Economic Constraints 2.4. Regulatory and Legal Constraints 3. Context and Scope 3.1. Business Context 3.2. Technical Context 3.3. Operating Mode Contexts 3.4. Integration Architecture 3.5. Future State Considerations 4. Solution Strategy 4.1. Solution Approach Overview 4.2. Technology Strategy 4.3. Decomposition Strategy 4.4. Quality Achievement Strategy 4.5. Strategic Decisions and Trade-offs 4.6. Implementation Strategy 4.7. Risk Assessment and Mitigation 4.8. Architecture Evolution Strategy 4.9. Conclusion 5. Building Block View 5.1. Whitebox Overall System 5.2. Level 2 5.3. Level 3 6. Runtime View 6.1. System Startup Sequence 6.2. UART-to-TCP Data Flow 6.3. TCP-to-UART Data Flow 6.4. Ring Buffer Cache-Coherent Access Pattern 6.5. Ring Buffer Overflow Handling 6.6. Watchdog Health Monitoring 6.7. Network Connection Handling 6.8. Hardware-in-the-Loop Testing Scenario 6.9. Performance and Timing Requirements 7. Deployment View 7.1. Operational Requirements Summary 7.2. Deployment Environments 7.3. Firmware Deployment Architecture 7.4. Infrastructure Components 7.5. Deployment Strategies 7.6. Operational Procedures 7.7. Configuration Management 8. Cross-cutting Concepts 8.1. Protocol Filtering 8.2. Web Management Interface 8.3. Error Handling Strategy 8.4. Security Architecture 8.5. Configuration Management 8.6. Performance Optimization 9. Architecture Decisions 9.1. Hardware Platform Decisions 9.2. Software Platform Decisions 9.3. Implementation Strategy Decisions 9.4. Decision Interdependencies 10. Quality Requirements 10.1. Quality Tree 10.2. Quality Scenarios 10.3. Quality Scenarios Integration 10.4. Quality Scenario Priority Matrix 10.5. Quality Requirements Summary 10.6. Security-Industrial Operation Balance 11. Risks and Technical Debts 11.1. Risk Overview 11.2. Detailed Risk Analysis 11.3. Technical Debt Register 11.4. Risk Mitigation Plan 11.5. Risk Monitoring 11.6. Risk Escalation Triggers 12. Glossary Template .arc42help {font-size:small; width: 14px; height: 16px; overflow: hidden; position: absolute; right: 0; padding: 2px 0 3px 2px;} .arc42help::before {content: \"?\";} .arc42help:hover {width:auto; height: auto; z-index: 100; padding: 10px;} .arc42help:hover::before {content: \"\";} @media print { .arc42help {display:none;} } About arc42 arc42, the template for documentation of software and system architecture. Template Version 8.2 EN. (based upon AsciiDoc version), January 2023 Created, maintained and &#169; by Dr. Peter Hruschka, Dr. Gernot Starke and contributors. See https://arc42.org . 1. Introduction and Goals 1.1. Requirements Overview 1.1.1. Purpose UART2ETH provides a hardware and firmware solution for bridging UART interfaces to TCP sockets, enabling network connectivity for legacy industrial equipment and embedded systems. 1.1.2. Core Functional Requirements Hardware Capabilities: Support up to 4 independent UART interfaces 10Mbit network interface with RJ45 connector Networking Features: Each UART exposed as individual TCP socket on dedicated port Raw TCP socket communication for transparent data transmission Support for concurrent connections (1 TCP connection per UART) Operating Modes: Full Bridge Mode: Transparent UART-over-TCP for remote device connections Gateway Mode: Add networking capabilities to existing products without firmware modifications Firmware Management: Secure Over-The-Air (OTA) firmware updates A/B update mechanism for rollback capability Protocol Optimization: Custom pluggable serial protocol filters for efficient TCP packaging Configurable packet caching with ring buffer implementation Adjustable transmit timeouts for latency or bulk transfer optimization 1.1.3. Target Use Cases Use Case Description Legacy Equipment Integration Connect PLCs, sensors, and measurement instruments to SCADA systems via network Infrastructure Problem Solving Overcome noise and cable length limitations in industrial environments System Integration Add networking to existing products without custom development effort Remote Device Access Enable distant connections to serial devices through Full Bridge mode 1.1.4. Driving Forces Regulatory Compliance: Western-only component supply chain for regulatory compliance Anticipation of new regulations requiring updateable and auditable firmware CE certification requirement for hardware Market Requirements: Address gap left by discontinued commercial UART-to-TCP solutions Provide open source alternative to expensive or black-box commercial products Enable cost-effective networking solutions for system integrators Substantial per-unit cost savings when deploying multiple units in-house compared to commercial alternatives Technical Requirements: 500kBaud sustained throughput capability Sub-5ms latency for real-time applications Critical system uptime within environmental specifications 1.2. Quality Goals The following quality goals are prioritized by importance to our major stakeholders (industrial engineers and system integrators): Priority Quality Goal Concrete Scenario 1 Reliability Critical system uptime for industrial applications A UART2ETH device deployed in a manufacturing line must maintain continuous operation for the duration that the connected hardware operates within environmental specifications. System failure should not occur due to software issues during normal operation. 2 Performance Real-time data transmission capabilities The system must sustain 500kBaud throughput with less than 5ms latency end-to-end. A PLC sending time-critical control data to a SCADA system must not experience delays that could affect industrial process control. 3 Compatibility Seamless integration with diverse industrial systems The system must work reliably with a broad range of custom baud rates and protocol parameters. It should reliably auto-negotiate ethernet connection parameters. 4 Usability Simple deployment without specialized knowledge A system integrator with basic understanding of serial communication and TCP/IP should be able to deploy and configure the device without extensive training. Configuration should be straightforward with clear error messages for common misconfigurations. 5 Maintainability Secure field updates without physical access Firmware updates must be deployable remotely via OTA mechanism with A/B rollback capability. A device installed in a remote location must be updatable without requiring on-site technician visits, while ensuring update integrity and system recovery from failed updates. 1.3. Stakeholders Role/Name Contact Expectations Industrial Engineers End user organizations, manufacturing facilities Clear documentation of network integration capabilities, performance specifications, and compatibility with existing industrial equipment. Need confidence in reliability and uptime guarantees. System Integrators Engineering consultancies, automation solution providers Comprehensive deployment guides, configuration documentation, and troubleshooting procedures. Expect regulatory compliance documentation (CE certification) and clear cost-benefit analysis. Development Team Internal project contributors Detailed architectural decisions, coding standards, build procedures, and testing frameworks. Need clear module interfaces and dependencies for parallel development work. Hardware Engineers PCB designers, component selection specialists Hardware interface specifications, power requirements, environmental constraints, and component selection rationale. Need mechanical and electrical interface documentation. Field Technicians Installation and maintenance personnel Simple installation procedures, diagnostic capabilities, and field troubleshooting guides. Need clear error indicators and recovery procedures for common failure modes. Regulatory Authorities CE certification bodies, industrial standards organizations Compliance documentation, safety analysis, electromagnetic compatibility evidence, and audit trails for component sourcing and manufacturing processes. Open Source Community Contributors, adopters, derivative projects Clear licensing terms (GPL), contribution guidelines, architectural documentation enabling modifications and extensions. Expect maintainable and well-documented code structure. 2. Architecture Constraints 2.1. Technical Constraints Constraint Description Rationale Hardware Platform Must use RP2350 microcontroller as primary processing unit Provides required security features for OTA updates, sufficient processing power for 4 UART channels, and western supply chain compliance Component Sourcing All components must be sourced from western suppliers only Regulatory compliance requirement for target markets and supply chain security considerations Performance Requirements Minimum 500kBaud sustained throughput with sub-5ms latency per UART channel Industrial application requirements for real-time data transmission Network Interface 10Mbit Ethernet connectivity via SPI-based controller Cost constraints and sufficient bandwidth for target applications while maintaining hardware simplicity UART Channel Limit Maximum 4 independent UART interfaces Hardware resource limitations of chosen microcontroller platform and cost optimization 2.2. Organizational Constraints Constraint Description Rationale Open Source License Complete system must be released under GPL license Leverage existing open source libraries and reduce implementation effort by reusing proven components Development Process Test-driven development (TDD) approach mandatory for all production code Quality assurance and maintainability requirements for industrial application reliability Documentation Standard Architecture documentation must follow arc42 template structure Standardized documentation approach for future maintainers and contributors Version Control GitHub-based development workflow with mandatory pull request reviews Code quality control and collaborative development coordination 2.3. Economic Constraints Constraint Description Rationale Hardware Cost Hardware target price per unit must be significantly below commercially available solutions Competitive market positioning requires substantial cost advantage to justify adoption over established commercial products Development Effort Development effort must achieve return on investment within first year of deployment Resource allocation constraint limits project scope and complexity to ensure economic viability and timely market entry 2.4. Regulatory and Legal Constraints Constraint Description Rationale CE Certification Hardware must achieve CE compliance for European market Legal requirement for commercial deployment in target markets Firmware Security Must implement secure boot and signed firmware update mechanisms Anticipated regulatory requirements for updateable industrial devices EMC Compliance Electromagnetic compatibility requirements for industrial environments Regulatory requirement and operational necessity in electrically noisy industrial settings Export Control No components or technologies subject to export restrictions Unrestricted distribution and deployment capability Patent Avoidance Must not infringe on existing patents in communication protocols or hardware interfaces Legal risk mitigation and freedom to operate requirements 3. Context and Scope 3.1. Business Context 3.1.1. Primary Stakeholders Stakeholder Role Primary Business Interactions Industrial Engineers Solution designers and specifiers Define networking requirements for automation projects, specify UART2ETH configurations for integrating legacy equipment into modern networks System Integrators Implementation specialists Deploy UART2ETH devices in customer facilities, configure networking parameters, integrate with existing SCADA and monitoring systems Field Technicians Installation and maintenance personnel Physical installation of devices, diagnostic troubleshooting, basic configuration changes, routine maintenance procedures Equipment Manufacturers Original equipment makers Embed UART2ETH into products to add networking capabilities, specify custom protocol filters, integrate with product lifecycle management 3.1.2. Business Use Cases Legacy Equipment Integration: Industrial Engineers specify UART2ETH to network aging PLCs, sensors, and measurement instruments that lack modern connectivity. System Integrators deploy these solutions to extend equipment lifecycles and enable remote monitoring without costly equipment replacement. Infrastructure Problem Solving: Field installations requiring long cable runs or operating in electrically noisy environments use UART2ETH to overcome serial communication limitations through network-based transmission. Remote Access Enablement: SCADA systems and monitoring applications access distributed serial devices through UART2ETH bridges, enabling centralized control and data collection across geographically dispersed facilities. 3.2. Technical Context 3.2.1. Technical Interface Specifications Interface Type Technical Details Communication Pattern UART Ports (4x) Host System Interface UART/RS232/RS422, 300-500k baud, configurable parameters Bidirectional serial, protocol-agnostic Ethernet Port Network Interface 10BASE-TX, RJ45 connector, Auto-MDIX TCP/IP networking, DHCP/Static IP TCP Sockets Client Interface Ports configurable, single connection per port TCP client connections, application protocols Management Interface Configuration Interface Web UI (HTTP), configuration interface HTTP, JSON configuration OTA Update Interface Firmware Interface Secure update server, A/B partition management HTTP, signed firmware images 3.2.2. Communication Protocols and Data Formats UART Communication: Raw serial data transmission (protocol-agnostic) Configurable baud rates: 300 bps to 500 kbps Support for custom frame formats and timing requirements Network Communication: TCP socket connections for data transmission JSON for configuration and management data Binary protocol passthrough with optional filtering HTTP for management and OTA updates Network Protocols: IPv4 with DHCP or static configuration NTP for time synchronization DNS for name resolution 3.3. Operating Mode Contexts 3.3.1. Gateway Mode Context Gateway Mode Data Flow: 1. Host System sends serial data using original protocol to UART2ETH 2. UART2ETH receives serial data and applies protocol filtering/optimization 3. Processed data is transmitted to Client Systems via TCP sockets 4. Client Systems send responses back through TCP connections 5. UART2ETH forwards responses to Host System via UART interface 3.3.2. Full Bridge Mode Context Full Bridge Mode Data Flow: 1. Host System A sends serial data to UART2ETH A 2. UART2ETH A encapsulates serial data in TCP packets and transmits over network 3. UART2ETH B receives TCP packets and extracts original serial data 4. UART2ETH B forwards serial data to Host System B via UART 5. Bidirectional communication maintains transparent serial connection 3.4. Integration Architecture 3.4.1. Critical Dependencies Network Infrastructure Dependencies: Reliable Ethernet connectivity for TCP/IP communication Network switches with appropriate bandwidth and latency characteristics DHCP services for automatic IP configuration (or static IP management) Network time synchronization for accurate timestamping Power and Environmental Dependencies: 3.3V-24V power supply within industrial specifications Operating temperature range suitable for industrial environments Protection from electromagnetic interference in industrial settings Security Dependencies: Network firewall configuration to allow necessary TCP ports Firmware signing infrastructure for secure OTA updates Network segmentation appropriate for industrial security requirements 3.4.2. Security and Compliance Boundaries Network Security: Cryptographic signatures for firmware validation and integrity Configurable TCP port ranges to support firewall policies Input validation and sanitization for all network interfaces Industrial Compliance: CE certification for European industrial markets Electromagnetic compatibility (EMC) for industrial environments Component sourcing from Western suppliers for regulatory compliance Audit trail for firmware updates and configuration changes 3.4.3. Performance and Scalability Characteristics Performance Requirements: 500 kbps sustained throughput per UART port Sub-5ms end-to-end latency for real-time applications Concurrent TCP connections (one per UART port) Configurable buffering for latency vs. throughput optimization Scalability Considerations: Up to 4 simultaneous UART-to-TCP bridges per device Network deployment limited by IP address availability and network bandwidth Protocol filtering reduces network traffic for efficient bulk transfers A/B firmware updates enable fleet-wide updates without service interruption 3.5. Future State Considerations 3.5.1. Planned Integrations Enhanced Protocol Support: Additional protocol filters for common industrial protocols (Modbus, DNP3, IEC 61850) HTTPS/TLS on-the-wire encryption Advanced Management Features: Integration with network management systems (SNMP, NETCONF) Enhanced diagnostic and monitoring capabilities 4. Solution Strategy 4.1. Solution Approach Overview Fundamental Architecture: Dual-Core Separation + Interrupts/DMA 4.2. Technology Strategy 4.2.1. Core Technology Decisions Technology Area Strategic Decision &amp; Rationale Architecture Pattern Dual-core separation with interrupt/DMA - provides fault isolation while achieving hardware-driven performance Programming Language C with Native Pico SDK - leverages team expertise, provides full platform access, enables deterministic behavior Memory Management Static allocation only - enables industrial reliability through predictable behavior, no dynamic allocation risks Inter-Core Communication Cache-aligned ring buffers with mutexes - optimal performance with deterministic behavior Ethernet Controller ENC28J60 with software TCP/IP - \"dumb\" controller enables full code auditability and control 4.2.2. Communication Architecture Ring Buffer Design: // Each entry = 1 cache line (64 bytes base + 1024 payload) typedef struct { // Management Data (16 bytes) uint8_t uart_channel; // 0-3 uint8_t direction; // TX/RX uint8_t status; // FILLING/DRAINING/FULL/EMPTY uint8_t payload_length; // Actual data length uint32_t timestamp; // Fill timestamp uint32_t sequence_id; // For ordering/debugging uint32_t reserved; // Future use/alignment // Payload Data (1024 bytes max) uint8_t payload[1024]; // Fixed max size for worst case } ring_entry_t; Memory Allocation Strategy: Buffer Size: (total_mem - static_vars) / sizeof(ring_entry_t) - 1 entries Cache Aligned: No core contention, optimal performance Overflow Policy: Drop oldest packets (deterministic, simple) 4.3. Decomposition Strategy 4.3.1. System Decomposition Approach Dual-core functional separation - Each core specializes in distinct responsibilities with clean interfaces through shared memory ring buffers. 4.3.2. Major Components/Services Component/Service Responsibilities Key Interfaces Core 0 UART Manager All 4 UART interfaces, interrupt/DMA handling, stream-to-packet conversion Hardware UARTs, Ring buffer producer Core 1 Network Manager TCP/IP stack, ENC28J60 control, packet-to-network conversion Ring buffer consumer, SPI to ENC28J60 Ring Buffer System Inter-core communication, cache-aligned data transfer Shared memory + mutex interfaces HTTP Management UI Device configuration, diagnostics, OTA trigger HTTP server on Core 1 OTA Update System Secure firmware updates, A/B partition management Secure boot, flash management 4.3.3. Component Interaction Strategy Interaction Principles: Core 0 ‚Üí Ring Buffer: UART streams converted to fixed-size packets, cache-aligned writes Ring Buffer ‚Üí Core 1: Packet consumption for TCP transmission Overflow Policy: Drop oldest packets (deterministic, simple) Priority: UART processing takes priority over HTTP UI 4.4. Quality Achievement Strategy 4.4.1. Quality Goal Implementation Quality Goal Architectural Mechanisms Validation Approach Reliability Core separation, static allocation, deterministic behavior, drop-oldest overflow Extended operation testing, fault injection, environmental testing Compatibility Protocol-agnostic packet handling, configurable UART parameters Testing with diverse industrial protocols, auto-negotiation validation Performance Interrupt/DMA driven I/O, cache-aligned buffers, hardware-optimized data paths Sustained 500kBaud testing, latency measurements, stress testing 4.4.2. Cross-Cutting Concerns Strategy Cross-Cutting Concern Implementation Strategy Error Handling Graceful degradation, fault isolation between cores, deterministic error responses Memory Management Static allocation only, pre-calculated buffer sizes, cache-aligned data structures Security Secure OTA updates, A/B partitioning, auditable code paths Testing Host-based testing with abstracted semaphores, hardware-in-the-loop validation 4.5. Strategic Decisions and Trade-offs 4.5.1. Major Architectural Decisions Decision Rationale Trade-offs Dual-Core Separation Fault isolation + performance, leverages RP2350 capabilities Increased complexity vs single-core simplicity Fixed 1024-byte Packets Deterministic behavior, handles worst-case scenarios 96% memory waste (avg 40 bytes vs 1024 max) accepted for simplicity Drop-Oldest Overflow Deterministic, reliable behavior under overload Data loss vs flow control complexity Cache-Aligned Buffers Optimal inter-core performance Memory overhead vs efficiency 4.5.2. Key Trade-off: Fixed Packet Size Inefficiency The Challenge: Realistic scenario: Max=1024 bytes, Average=40 bytes ‚Üí 96% memory waste Risk: Significant resource inefficiency in typical use cases Mitigation Rationale: Sub-5ms latency requirement limits buffering depth anyway (~2-3 packets maximum) Total waste limited: 4 UARTs √ó 3 packets √ó 1024 bytes = ~12KB (acceptable in 520KB system) Implementation simplicity enables reliable delivery Future Optimization Path: Protocol-aware multi-pool approach documented for later enhancement: Small Pool: 64-byte entries (for ‚â§40 byte packets) Medium Pool: 256-byte entries (for 41-200 byte packets) Large Pool: 1024-byte entries (for 201-1024 byte packets) 4.5.3. Alternative Approaches Considered Alternative Why Not Selected Key Insight Single-Core Design Cannot achieve 4-UART + network performance simultaneously Core separation essential for real-time requirements Dynamic Memory Allocation Conflicts with industrial reliability requirements Static allocation mandatory for predictable behavior W5500 Ethernet Controller Hardware TCP/IP stack not auditable, conflicts with compliance goals \"Dumb\" controller enables full code control 4.6. Implementation Strategy 4.6.1. Development Approach Implementation Aspect Strategy Development Methodology Test-driven development with host-based testing using abstracted semaphores Testing Strategy Host simulation with pthread/threads, then hardware validation Risk Mitigation Single UART + single TCP proof-of-concept first Platform Abstraction Abstract semaphores/mutexes for host testing: platform_mutex_t , platform_semaphore_t 4.6.2. Implementation Phases Phase 1: Proof of Concept Single UART + Single TCP socket Mock ring buffer with abstracted semaphores Host-based testing with thread simulation Validate core architecture concepts Phase 2: Full System Implementation All 4 UARTs on Core 0 Complete ring buffer system Full TCP/IP integration on Core 1 HTTP management UI Phase 3: Advanced Features Secure OTA implementation A/B update mechanism Industrial hardening and optimization 4.6.3. Validation and Success Metrics Milestone Success Criteria Validation Method Ring Buffer Validation Concurrent producer/consumer without data corruption Host-based stress testing Performance Achievement 500kBaud sustained, &lt;5ms latency Hardware-in-the-loop measurement Reliability Demonstration 24+ hour continuous operation Extended testing under load 4.7. Risk Assessment and Mitigation 4.7.1. Strategic Risks Risk Probability/Impact Mitigation Strategy Fixed Packet Size Inefficiency High/Medium Document multi-pool optimization path, validate memory usage early Inter-Core Communication Complexity Medium/High Prove with host-based testing first, extensive validation Performance Under Load Medium/High Early prototyping, stress testing, hardware validation 4.8. Architecture Evolution Strategy 4.8.1. Future Optimization Path Protocol-Aware Enhancements: Multi-pool buffer management for memory efficiency Protocol-specific packet sizing based on message type analysis Dynamic buffer allocation per UART based on usage patterns Security and Compliance Evolution: Enhanced security features for evolving compliance requirements Extended audit trail capabilities Additional cryptographic features as regulations develop Performance Optimizations: Fine-tuned based on real-world deployment data Protocol filter optimizations Network stack performance improvements 4.8.2. Success Factors Critical Dependencies: Early validation of ring buffer architecture with host-based testing Incremental implementation starting with single UART proof-of-concept Comprehensive testing at each phase before proceeding Key Assumptions: RP2350 dual-core performance meets concurrent processing requirements Cache-aligned ring buffers provide sufficient inter-core bandwidth Static memory allocation provides adequate resource management Monitoring and Adaptation: Continuous validation of memory efficiency in real deployments Performance monitoring under various industrial load scenarios Regular assessment of compliance requirement evolution 4.9. Conclusion This solution strategy establishes UART2ETH as an \"unbreakable foundation with field-updateable capability\" through: Core Architectural Principles: Reliability-first dual-core separation Static allocation for predictable behavior Hardware-driven performance with software control Protocol-agnostic flexibility Strategic Advantages: Fault isolation enables industrial reliability Deterministic behavior supports real-time requirements Full code auditability meets compliance needs Incremental implementation reduces development risk Success Enablers: TDD approach with host-based validation Clear module boundaries for team development Documented optimization paths for future enhancement Strong foundation for scaling and feature evolution The strategy balances immediate reliability requirements with long-term flexibility, ensuring UART2ETH can serve as a robust industrial networking solution while maintaining the ability to evolve with changing requirements and regulations. 5. Building Block View 5.1. Whitebox Overall System The UART2ETH system follows a dual-core separation strategy that provides fault isolation while achieving hardware-driven performance. The system is decomposed into ten major building blocks that each handle distinct responsibilities in the UART-to-TCP bridge functionality. 5.1.1. Motivation The dual-core separation strategy from our solution approach drives this decomposition to achieve: Fault isolation : Each core has distinct responsibilities to prevent cascading failures Performance optimization : Hardware-driven I/O with software control for real-time requirements Industrial reliability : Predictable behavior through static allocation and deterministic interfaces Bidirectional communication : Both UART and TCP interfaces require full-duplex operation System coordination : Global state machine ensures consistent system behavior across cores Comprehensive monitoring : Log Manager with performance data collection provides visibility and diagnostics Configuration persistence : Configuration Manager ensures settings survive power cycles and support factory operations Predictable maintenance : Periodic background processing ensures system housekeeping at regular intervals Automatic recovery : Watchdog system provides fault detection and recovery capabilities 5.1.2. Contained Building Blocks Name Responsibility Core 0 UART Subsystem Manages all 4 UART interfaces with interrupt/DMA handling. Performs bidirectional stream-to-packet conversion for communication with the ring buffer system. Core 1 Network Subsystem Implements TCP/IP stack and Ethernet controller interface with interrupt/DMA handling. Copies packets from and to the network stack and manages TCP socket connections. Ring Buffer Communication Provides bidirectional inter-core data transfer using a shared memory pool with cache-aligned, mutex-protected buffers. Handles dynamic burst allocation by being channel and driection agnostic. Management Interface Offers web-based configuration, monitoring, and administration through HTTP server with authentication, statistics collection, and configuration UIs. OTA Update System Manages secure firmware updates with A/B partition management, signature validation, and automatic rollback capabilities. Global State Machine Coordinates overall system state across both cores including boot sequence, operational modes, error handling, and update states. Provides centralized state synchronization and transition control. Log Manager Collects, formats, and stores system-wide events, errors, performance data, and diagnostic information from all components. Provides log rotation, filtering, and integration with management interface for diagnostics. Configuration Manager Manages persistent storage of all system settings including UART parameters, network configuration, user preferences, and system options. Provides factory defaults, parameter validation, configuration versioning, and backup/restore functionality. Periodic Background Process Executes system maintenance tasks every 100ms including statistics collection, connection cleanup, buffer maintenance, session management, configuration backup, and system health checks. Watchdog System Monitors system health through heartbeat signals from all major components. Detects failures, logs recovery events, and triggers automatic system recovery or reset when necessary. 5.1.3. Important Interfaces Ring Buffer Interface Shared Pool Design : Single buffer pool serves both directions dynamically Core 0 : Producer (UART RX) + Consumer (UART TX) using shared pool Core 1 : Producer (TCP RX) + Consumer (TCP TX) using shared pool Entry Format : Fixed 1088-byte entries (64-byte header + 1024-byte payload) Synchronization : Mutex-protected operations for shared pool access Overflow Policy : Drop-oldest across entire pool (direction-agnostic) Network Interface External : 10BASE-T Ethernet, RJ45 connector (ENC28J60 limitation) Internal : SPI to ENC28J60 controller, software TCP/IP stack (lwIP) UART Interface Hardware : 4 independent UART channels with configurable parameters Protocols : UART/RS232/RS422 support with 300-500kBaud range Configuration : Per-channel baud rate, data bits, stop bits, parity settings Global State Machine Interface States : BOOT, INITIALIZING, OPERATIONAL, ERROR, UPDATE_MODE, RECOVERY Inter-core : Shared state variables with atomic updates and cache coherency Transitions : Event-driven state changes with validation and rollback capability Synchronization : Cross-core state synchronization using FreeRTOS primitives Logging Interface Log Levels : DEBUG, INFO, WARN, ERROR, CRITICAL with configurable filtering Storage : Circular buffer in RAM with optional flash persistence Format : Structured logging with timestamps, component ID, and severity Performance Data : Throughput metrics, latency measurements, resource utilization Access : Real-time log streaming via management interface Configuration Manager Interface Storage : Persistent flash storage with wear leveling and redundancy Settings Categories : UART parameters, network config, user accounts, system options Validation : Parameter range checking, conflict detection, dependency validation Factory Reset : Restore to known-good defaults with version migration Backup/Restore : Configuration export/import for deployment and recovery Periodic Process Interface Timer : Hardware timer interrupt every 100ms (10Hz frequency) Task Queue : Priority-based maintenance task scheduling Execution : Non-blocking operations with bounded execution time Health Reports : Regular status updates to watchdog system Watchdog Interface Heartbeat : Component-specific periodic health signals Thresholds : Configurable timeout values per monitored component Recovery Actions : Graduated response from warnings to system reset Hardware Integration : RP2350 hardware watchdog timer as final safety net 5.2. Level 2 5.2.1. Whitebox Core 0 UART Subsystem The Core 0 UART Subsystem specializes in handling all UART communication with dedicated hardware management, interrupt processing, and bidirectional data conversion between stream and packet formats. Motivation Core 0 specialization enables real-time UART processing without interference from network operations. The bidirectional packet conversion allows seamless translation between continuous UART streams and discrete network packets. Contained Building Blocks Name Responsibility UART Hardware Manager Direct control of 4 UART channels with configurable parameters (baud rate, data bits, parity). Manages hardware registers and status monitoring. Interrupt Handler Processes time-critical UART events (RX data available, TX buffer empty) with minimal latency for real-time performance. DMA Controller Optimizes bulk data transfers in both directions to reduce CPU load and improve throughput for high-baud applications. Packet Assembler Converts incoming UART streams into fixed-size packets for ring buffer storage. Handles framing and timestamp metadata. Packet Disassembler Extracts UART data from ring buffer packets and converts back to continuous streams for transmission. Ring Buffer Interface Provides producer operations (UART RX data) and consumer operations (UART TX data) with proper synchronization. 5.2.2. Whitebox Core 1 Network Subsystem The Core 1 Network Subsystem manages all network communication including TCP/IP protocol processing, Ethernet controller interface, and bidirectional packet routing between ring buffer and network clients. Motivation Core 1 specialization allows network processing to operate independently from time-critical UART operations. The modular design enables efficient TCP/IP processing while maintaining clear separation between hardware drivers and application logic. Contained Building Blocks Name Responsibility lwIP TCP/IP Stack Complete software-based TCP/IP implementation providing standard network protocols and socket interfaces. ENC28J60 Driver Low-level SPI driver for the 10BASE-T Ethernet controller, handling frame transmission and reception. Socket Manager Manages TCP socket connections with one dedicated socket per UART channel. Handles connection lifecycle and error recovery. Packet Router Maps UART channel numbers to TCP port numbers and routes data bidirectionally between network and ring buffer interfaces. Packet Assembler Converts incoming TCP data streams into ring buffer packets for transmission to Core 0. Packet Disassembler Extracts data from ring buffer packets and formats for TCP transmission to network clients. Ring Buffer Interface Provides producer operations (TCP RX data) and consumer operations (TCP TX data) with shared pool access. 5.2.3. Whitebox Ring Buffer Communication System The Ring Buffer Communication System provides the critical inter-core communication mechanism using a shared memory pool that dynamically handles bursts from either direction while maintaining deterministic behavior. Motivation The shared buffer pool design provides elegant burst handling by allowing dynamic allocation to whichever direction needs capacity. This approach is more efficient than fixed per-direction pools and gracefully handles real-world traffic patterns. Contained Building Blocks Name Responsibility Shared Buffer Pool Single memory pool that dynamically serves both UART‚ÜíTCP and TCP‚ÜíUART directions with fixed-size entries. Mutex Manager Provides thread-safe access to the shared pool using FreeRTOS mutexes and semaphores for inter-core synchronization. Memory Manager Handles allocation and deallocation of fixed-size buffer entries with cache-aligned addressing for optimal performance. Overflow Handler Implements drop-oldest policy when buffer reaches capacity, ensuring deterministic behavior under overload conditions. Statistics Collector Tracks buffer utilization, message counts, throughput metrics, and error conditions for monitoring and diagnostics. 5.2.4. Whitebox Log Manager The Log Manager provides system-wide event logging and performance data collection through lock-free interfaces that ensure real-time operations on both cores are never blocked by logging activities. Motivation Lock-free logging interfaces prevent real-time operations from being blocked by logging activities. The dual-interface design allows each core to log independently without synchronization overhead, while the ring buffer provides bounded memory usage and predictable performance. Contained Building Blocks Name Responsibility Lock-Free Interface Core 0 Provides atomic write operations for Core 0 components. Uses lock-free algorithms to ensure UART processing is never blocked by logging operations. Lock-Free Interface Core 1 Provides atomic write operations for Core 1 components. Ensures network processing continues uninterrupted during logging activities. Event Log Ring Buffer Circular buffer storing formatted log entries with fixed-size allocation. Implements overwrite-oldest policy to handle log bursts without memory allocation. Log Entry Formatter Converts raw log data into structured entries with timestamps, component IDs, severity levels, and formatted messages for consistent log format. Log Level Filter Runtime-configurable filtering based on severity levels and component masks. Reduces storage overhead by filtering out debug messages in production. Performance Data Collector Aggregates performance metrics from both cores including throughput calculations, latency measurements, and resource utilization statistics. Log Query Interface Provides search and retrieval capabilities for both real-time log streaming and historical log access via the management interface. Log Persistence Manager Handles optional flash storage with log rotation, compression, and archival. Manages persistent log files for post-mortem analysis. Important Interfaces Lock-Free Logging Interface Atomic Operations : Single-writer, multiple-reader lock-free ring buffer Non-blocking : Log calls never block or yield the calling thread Bounded Time : Worst-case execution time guarantees for real-time systems Overflow Handling : Graceful degradation when log buffer fills Event Log Ring Buffer Structure Entry Size : Fixed 128-byte entries for predictable memory usage Buffer Size : Configurable (default 1024 entries = 128KB) Overflow Policy : Drop oldest entries when buffer is full Memory Layout : Cache-aligned for optimal performance Performance Data Interface Metrics Collection : Throughput, latency, error counts, resource usage Aggregation : Time-based windowing for trend analysis Real-time Access : Current performance data always available Historical Data : Configurable retention period for trend analysis 5.2.5. Whitebox Management Interface The Management Interface provides comprehensive web-based administration through modular components handling authentication, configuration, and monitoring functions. Motivation The modular management interface design separates concerns between web serving, authentication, data collection, and configuration UIs. This enables independent development and testing of each component while providing a comprehensive administration solution. Contained Building Blocks Name Responsibility HTTP Web Server Processes HTTP/1.1 requests, serves static content (HTML/CSS/JS), provides REST API endpoints, and manages user sessions. Authentication System Handles user login validation, JWT session token management, role-based access control, and security header implementation. Statistical Data Module Collects real-time metrics from system components, maintains historical data, tracks performance counters, and monitors system health. UART Configuration UI Provides web interface for configuring UART channel settings, hardware control options, protocol filters, and parameter validation. TCP/IP Configuration UI Offers web interface for network settings, TCP port mapping, connection limits, and security configurations. 5.3. Level 3 5.3.1. Whitebox Core 0 UART Handler Subsystem The Core 0 UART Subsystem specializes in handling all UART communication with dedicated hardware management, interrupt processing, and bidirectional data conversion between stream and packet formats. Motivation UART processing utilizing UART specific ISR and DMA transfers for maximum troughput. Contained Building Blocks Name Responsibility UART Hardware Manager Direct control of 4 UART channels with configurable parameters (baud rate, data bits, parity). Manages hardware registers and status monitoring. Interrupt Handler Processes time-critical UART events (RX data available, TX buffer empty) with minimal latency for real-time performance. DMA Controller Controls bulk data transfers in both directions DMA Channel Optimizes bulk data transfers in both directions to reduce CPU load and improve throughput for high-baud applications. Packet Assembler Converts incoming UART streams into fixed-size packets for ring buffer storage. Handles framing and timestamp metadata. Packet Disassembler Extracts UART data from ring buffer packets and converts back to continuous streams for transmission. Ring Buffer Interface Provides producer operations (UART RX data) and consumer operations (UART TX data) with proper synchronization. 5.3.2. Whitebox Ring Buffer System Internal Structure The Ring Buffer System provides the foundational inter-core communication with detailed memory management, helper functions, and synchronization primitives. Purpose Provides efficient, thread-safe, bidirectional communication between cores with deterministic behavior and comprehensive monitoring capabilities. Internal Structure Memory Layout Manager Manages the physical organization of the ring buffer in memory with cache-aligned addressing and efficient index calculations. Ring Buffer Array : Contiguous memory block with cache-aligned entries Index Management : Head/tail pointers with wrap-around logic Memory Addressing : Base address + (index √ó entry_size) calculations Buffer Management Functions Core API providing the helper functions for ring buffer operations and monitoring. // Core buffer operations ring_entry_t* find_next_free_block(void); ring_entry_t* find_next_ready_block(uint8_t uart_channel, uint8_t direction); bool is_buffer_full(void); bool is_buffer_empty(void); // Statistics and monitoring uint32_t get_cached_message_count(void); uint32_t get_cached_message_count_by_channel(uint8_t uart_channel); uint32_t get_cached_message_count_by_direction(uint8_t direction); uint32_t get_free_block_count(void); uint32_t get_overflow_count(void); // Dropped messages uint32_t get_total_throughput_bytes(void); // Advanced operations ring_entry_t* peek_next_block(uint8_t uart_channel, uint8_t direction); void mark_block_ready(ring_entry_t* entry); void mark_block_consumed(ring_entry_t* entry); void reset_buffer_statistics(void); Memory Layout Structure Complete ring buffer system data structure with metadata, statistics, and synchronization primitives. typedef struct { // Ring buffer metadata (cache-aligned) volatile uint32_t head_index; // Producer index volatile uint32_t tail_index; // Consumer index volatile uint32_t entry_count; // Current entries uint32_t max_entries; // Buffer capacity // Statistics (cache-aligned) uint32_t total_produced; uint32_t total_consumed; uint32_t overflow_count; uint32_t underflow_count; // Synchronization mutex_t buffer_mutex; semaphore_t free_space_sem; semaphore_t data_ready_sem; // Entry array (cache-aligned) ring_entry_t entries[]; } ring_buffer_system_t; Data Entry Format Individual ring buffer entry structure used for both communication directions. typedef struct { // Management Data (16 bytes) uint8_t uart_channel; // 0-3 uint8_t direction; // RX_UART_TO_TCP / RX_TCP_TO_UART uint8_t status; // FILLING/DRAINING/FULL/EMPTY uint8_t payload_length; // Actual data length uint32_t timestamp; // Fill timestamp uint32_t sequence_id; // For ordering/debugging uint32_t next_in_use; // Packets in use (within ring buffer) are a single linked list uint32_t reserved; // Future use/alignment // Payload Data (1024 bytes max) uint8_t payload[1024]; // Fixed max size for worst case } ring_entry_t; 5.3.3. Whitebox UART Hardware Manager Internal Structure The UART Hardware Manager provides unified control over all 4 UART channels with individual controllers, parameter management, and comprehensive status monitoring. Purpose Provides unified interface to all 4 UART channels with configurable parameters, comprehensive status monitoring, and efficient interrupt handling. Internal Structure UART Configuration Interface Complete configuration structure for UART channel parameters. typedef struct { uint32_t baud_rate; // 300-500000 bps uint8_t data_bits; // 5-8 bits uint8_t stop_bits; // 1-2 bits uint8_t parity; // NONE/ODD/EVEN bool flow_control; // Hardware flow control bool rs485_mode; // RS485 half-duplex mode } uart_config_t; UART Operations API Core function interface for UART channel operations. // Channel operations int uart_channel_configure(uint8_t channel, uart_config_t* config); int uart_channel_read(uint8_t channel, uint8_t* buffer, size_t length); int uart_channel_write(uint8_t channel, const uint8_t* data, size_t length); bool uart_channel_is_ready(uint8_t channel); uint32_t uart_channel_get_status(uint8_t channel); Status Monitoring Structure Comprehensive status tracking for each UART channel. typedef struct { bool carrier_detect; bool clear_to_send; bool data_set_ready; uint32_t rx_errors; uint32_t tx_errors; uint32_t frames_received; uint32_t frames_transmitted; } uart_channel_status_t; 5.3.4. Whitebox Management Interface Internal Structure The Management Interface provides comprehensive web-based administration through specialized components for HTTP serving, authentication, statistics, and configuration management. Purpose Provides comprehensive web-based configuration, monitoring, and administration interface with modular components for different management aspects. Internal Structure HTTP Web Server Components Request Handler typedef struct { uint16_t port; // Default: 80 uint32_t max_connections; // Concurrent sessions char document_root[256]; // Static content path } webserver_config_t; int webserver_start(webserver_config_t* config); int webserver_register_endpoint(const char* path, http_handler_t handler); int webserver_send_response(int client_fd, http_response_t* response); Authentication System Components User Management typedef enum { AUTH_ROLE_ADMIN, // Full configuration access AUTH_ROLE_OPERATOR, // Monitor + basic config AUTH_ROLE_READONLY // Monitor only } auth_role_t; typedef struct { char username[32]; char password_hash[64]; // SHA-256 hash auth_role_t role; bool enabled; } user_account_t; bool authenticate_user(const char* username, const char* password); const char* create_session_token(const char* username); bool validate_session_token(const char* token); Statistical Data Components System Statistics Structure typedef struct { // Per-channel statistics struct { uint64_t bytes_transmitted; uint64_t bytes_received; uint32_t messages_transmitted; uint32_t messages_received; uint32_t error_count; uint32_t overflow_count; float average_latency_ms; uint32_t current_baud_rate; } uart_stats[4]; // Network statistics uint64_t tcp_bytes_sent; uint64_t tcp_bytes_received; uint32_t tcp_connections_active; uint32_t tcp_connections_total; // System statistics uint32_t uptime_seconds; uint32_t cpu_usage_percent; uint32_t memory_used_bytes; uint32_t ring_buffer_utilization_percent; } system_statistics_t; Configuration Interface Components UART Configuration Structure typedef struct { bool enabled; uart_config_t config; // From UART Hardware Manager char description[64]; // User-friendly name bool protocol_filter_enabled; char protocol_filter_type[32]; // \"SharkNet\", \"custom\", etc. } uart_channel_settings_t; Network Configuration Structure typedef struct { // Network configuration bool use_dhcp; char ip_address[16]; // \"192.168.1.100\" char subnet_mask[16]; // \"255.255.255.0\" char gateway[16]; // \"192.168.1.1\" char dns_primary[16]; char dns_secondary[16]; // Port mapping struct { uint16_t tcp_port; // 4001-4004 default bool enabled; uint32_t connection_timeout_ms; char allowed_clients[256]; // IP ranges: \"192.168.1.0/24\" } port_config[4]; // Security bool enable_firewall; char hostname[64]; uint16_t management_port; // Web UI port (default 80) } network_config_t; 6. Runtime View 6.1. System Startup Sequence The system follows a carefully orchestrated startup sequence ensuring proper initialization of shared resources before concurrent operation begins. Startup Sequence Details: Basic System Init (Core 0 only): Clock configuration to operational frequency GPIO pin configuration for UART and SPI interfaces Memory controller initialization for cache-coherent operation Shared Infrastructure Init (Core 0 only): Ring buffer allocation across 4 memory banks (128 entries total) Log manager initialization with flash storage and debug UART output Watchdog timer configuration with 200ms timeout per core Core 1 Startup : Core 0 releases Core 1 from reset state If Core 1 fails to respond within timeout, system reset is triggered Concurrent Core-Specific Init : Core 0: UART hardware initialization, interrupt/DMA configuration Core 1: Network stack initialization, ENC28J60 setup, TCP socket creation Both cores register with watchdog system Critical Startup Requirements: - Shared infrastructure must be fully initialized before Core 1 startup - Core-specific initialization can proceed concurrently once both cores are active - Any startup failure triggers immediate system reset for fail-safe operation 6.2. UART-to-TCP Data Flow This scenario demonstrates the complete data path from UART reception to TCP transmission, highlighting the cache-coherent ring buffer operation and inter-core coordination. Data Flow Key Points: Interrupt-Driven Reception : UART RX interrupt triggers immediate DMA setup for bulk transfer Cache-Coherent Allocation : Ring buffer entries use bank-striped allocation to avoid cache contention Metadata Management : Each entry includes channel, direction, timing, and sequence information Consumer Notification : Ring buffer signals Core 1 when data is ready for transmission Automatic Cleanup : Consumed entries are immediately marked for reuse Memory Bank Allocation Strategy: Entry 0: Bank 0 (0x20000000) - 1664 bytes (padded from 1088 bytes) Entry 1: Bank 1 (0x2000D000) - 1664 bytes (52KB stride) Entry 2: Bank 2 (0x2001A000) - 1664 bytes (52KB stride) Entry 3: Bank 3 (0x20027000) - 1664 bytes (52KB stride) Entry 4: Bank 0 (0x20001680) - 1664 bytes (next slot in Bank 0) ... 32 entries per bank √ó 4 banks = 128 total entries Total ring buffer memory: 4 √ó 52KB = 208KB 6.3. TCP-to-UART Data Flow This scenario shows the reverse data path from TCP reception to UART transmission, demonstrating the bidirectional nature of the ring buffer system. Reverse Data Flow Characteristics: TCP Reception : lwIP stack triggers callback on Core 1 with received data Producer Allocation : Core 1 acts as producer, allocating ring buffer entries Channel Routing : TCP port number maps to specific UART channel for data routing Consumer Processing : Core 0 consumes entries and triggers UART transmission DMA Efficiency : Bulk transfers minimize CPU overhead for high-throughput operation 6.4. Ring Buffer Cache-Coherent Access Pattern The ring buffer implementation uses bank-striped memory allocation to ensure cache coherency between cores without explicit synchronization overhead. Cache-Coherent Access Implementation: // Ring buffer entry calculation for cache coherency #define RING_BUFFER_BASE 0x20000000 #define BANK_SIZE (52 * 1024) // 52KB per bank #define ENTRIES_PER_BANK 32 #define ENTRY_SIZE 1664 // Padded from 1088 to align at bank boundaries #define TOTAL_ENTRIES 128 // 32 √ó 4 banks #define TOTAL_RING_MEMORY (4 * BANK_SIZE) // 208KB total typedef struct { uint32_t bank_id; // 0-3 uint32_t bank_offset; // Offset within bank void* entry_ptr; // Cache-aligned pointer } ring_entry_location_t; // Calculate cache-coherent entry address with bank striping ring_entry_location_t calculate_entry_location(uint32_t entry_index) { ring_entry_location_t loc; loc.bank_id = entry_index % 4; // Rotate through banks 0-3 loc.bank_offset = (entry_index / 4) * ENTRY_SIZE; loc.entry_ptr = (void*)(RING_BUFFER_BASE + (loc.bank_id * BANK_SIZE) + loc.bank_offset); return loc; } Cache Coherency Benefits: - No Explicit Synchronization : Bank striping eliminates cache line conflicts - Concurrent Access : Both cores can access ring buffer simultaneously - Predictable Performance : No cache coherency protocol overhead - Scalable Design : Adding more entries maintains cache efficiency 6.5. Ring Buffer Overflow Handling When the ring buffer reaches capacity during data bursts, the drop-oldest policy ensures deterministic behavior without blocking either core. Overflow Handling Characteristics: Deterministic Behavior : Drop-oldest policy provides predictable response to overload Non-Blocking Operation : Neither producer nor consumer cores are ever blocked Comprehensive Logging : All overflow events are logged with detailed context Transparent Recovery : System continues normal operation after overflow Performance Preservation : Overflow handling adds minimal latency to normal operation Overflow Prevention Strategies: - Monitor ring buffer utilization via management interface - Adjust TCP connection parameters to reduce data bursts - Configure UART baud rates to match expected data flow - Use performance counters to identify problematic traffic patterns 6.6. Watchdog Health Monitoring The dual-core watchdog system ensures system reliability by monitoring both cores independently and triggering recovery when failures are detected. Watchdog Implementation Details: Independent Monitoring : Each core has separate watchdog channel with 200ms timeout Background Task Integration : Keepalive signals sent during regular 100ms background tasks Failure Logging : All watchdog timeouts logged to log ring buffer (stored to flash) and debug UART (if enabled) Immediate Recovery : Hardware reset triggered immediately upon timeout detection Post-Reset Analysis : Failure logs available after system restart for diagnostics Watchdog Configuration: #define WATCHDOG_TIMEOUT_MS 200 #define BACKGROUND_TASK_MS 100 // Provides safety margin #define CORE0_WATCHDOG_CHANNEL 0 #define CORE1_WATCHDOG_CHANNEL 1 // Keepalive function called from background tasks void watchdog_keepalive(uint8_t core_id) { hw_watchdog_update(core_id); last_keepalive_timestamp[core_id] = get_system_time_ms(); } 6.7. Network Connection Handling Network connections are managed dynamically with automatic recovery mechanisms to handle real-world network conditions. Connection Management Features: Dynamic Port Mapping : TCP ports 4001-4004 map to UART channels 0-3 respectively Connection Validation : Client connections validated against configured limits and permissions Automatic Buffering : Temporary data buffering during connection interruptions (30-second window) Graceful Recovery : Both graceful and ungraceful disconnection handling Comprehensive Logging : All connection events logged for diagnostics and monitoring Network Configuration Parameters: #define TCP_PORT_UART0 4001 #define TCP_PORT_UART1 4002 #define TCP_PORT_UART2 4003 #define TCP_PORT_UART3 4004 #define MAX_CONNECTIONS 4 // One per UART channel #define BUFFER_TIMEOUT_MS 30000 // 30 seconds 6.8. Hardware-in-the-Loop Testing Scenario The hardware-in-the-loop (HiL) testing framework enables automated validation of system behavior using real RP2350 hardware with comprehensive data collection from multiple sources. HiL Testing Configuration: Development Machine Setup: # Network configuration ip addr add 10.10.10.11/24 dev eth0 # UART device mapping /dev/ttyUSB0 ‚Üí Debug UART (115200 8N1) - Debug output and flashing /dev/ttyUSB1 ‚Üí System UART 0 (230400 8N1) - Test channel 0 /dev/ttyUSB2 ‚Üí System UART 1 (230400 8N1) - Test channel 1 /dev/ttyUSB3 ‚Üí System UART 2 (230400 8N1) - Test channel 2 # UART 3 uses internal loopback for testing Device Network Configuration: #define DEVICE_IP_ADDR \"10.10.10.10\" #define DEVICE_SUBNET \"255.255.255.0\" #define DEVICE_GATEWAY \"10.10.10.1\" #define DEV_MACHINE_IP \"10.10.10.11\" // Test-specific ports #define TEST_LOG_PORT 8080 // Event log retrieval #define MGMT_PORT 80 // Management interface // UART Test Configuration #define DEBUG_UART_BAUD 115200 // /dev/ttyUSB0 - 8N1 #define SYSTEM_UART_BAUD 230400 // /dev/ttyUSB1-3 - 8N1 Test Data Collection Sources: Debug UART Output ( /dev/ttyUSB0 ): System startup messages Real-time performance counters Error and warning messages Watchdog timeout notifications TCP Event Log (Port 8080): Structured JSON event records Timing measurements with microsecond precision Ring buffer utilization statistics Network connection state changes System UART Responses ( /dev/ttyUSB1-3 ): Actual serial data transmitted by device Response timing verification Data integrity validation Protocol compliance testing TCP Socket Data (Ports 4001-4004): Network data transmission verification Connection establishment timing Error recovery behavior Multi-channel coordination Automated Test Scenarios: Throughput Testing : Sustained 500kBaud operation across all channels Latency Measurement : End-to-end timing from UART RX to TCP TX Stress Testing : Ring buffer overflow conditions and recovery Error Injection : Network disconnection, UART errors, power fluctuations Regression Testing : Automated validation of all critical scenarios The HiL testing framework ensures comprehensive validation of the UART2ETH system behavior under real-world conditions while maintaining the benefits of automated testing for continuous integration. 6.9. Performance and Timing Requirements Critical Timing Specifications: Performance Metric Target Value Measurement Method Validation Criteria End-to-End Latency &lt; 5ms HiL timestamp correlation 99% of messages under 5ms Sustained Throughput 500kBaud per channel Long-duration data streaming No data loss over 1 hour Ring Buffer Access Time &lt; 100Œºs Hardware performance counters Cache-coherent bank access Watchdog Response Time &lt; 200ms Failure injection testing System reset within timeout Network Recovery Time &lt; 30 seconds Connection interruption tests Automatic reconnection success System Boot Time &lt; 5 seconds Power-on to operational state Ready for data processing 7. Deployment View 7.1. Operational Requirements Summary Requirement Type Target Description Availability Zero-downtime updates A/B partition switching maintains device operation until manual reboot Security Signed firmware delivery Cryptographic signing, secure boot, initial key embedding at factory Reliability Automatic rollback Watchdog-based rollback mechanism for failed firmware updates Auditability Version tracking Git tags and commit checksums embedded in firmware builds Control Manual operations No remote device reboots, QA gatekeeping for all releases 7.2. Deployment Environments 7.2.1. Environment Overview 7.2.2. Environment Specifications Environment Purpose Hardware Deployment Method Development Feature development and local testing Individual RP2350 devices per developer Direct flash programming QA Testing Release validation with real hardware Single testbench with RP2350 hardware Automated test deployment Production Live firmware distribution Customer-deployed field devices OTA HTTP downloads Factory Initial device provisioning Manufacturing test fixtures Flash programming + key embedding 7.3. Firmware Deployment Architecture 7.3.1. High-Level Architecture 7.3.2. A/B Partition Strategy 7.4. Infrastructure Components 7.4.1. Build and Release Infrastructure Component Technology &amp; Configuration Purpose &amp; Responsibilities CMake Build System Pico SDK integration, firmware signing Compile source code, embed version info, sign binaries Developer Hardware Individual RP2350 devices Local development and unit testing QA Testbench Single automated test fixture with RP2350 Hardware-in-the-loop validation of release candidates Cloud OTA Server HTTP-based firmware distribution Serve approved firmware to field devices Key Management Secure cryptographic key storage Firmware signing keys, device authentication 7.4.2. Security Architecture Security Layer Implementation Factory Key Embedding Cryptographic keys installed during initial manufacturing flash Firmware Signing All firmware builds cryptographically signed before distribution Secure Boot RP2350 ROM bootloader verifies firmware signatures before execution OTA Authentication Device authenticates with OTA server before firmware download Partition Verification Each partition validated before boot attempt 7.5. Deployment Strategies 7.5.1. Firmware Update Process Stage Process Validation &amp; Control Development Build CMake compilation with embedded version tags Local developer testing on real hardware QA Validation Automated testbench execution Hardware-in-the-loop testing, manual approval gate Production Release QA promotes approved firmware to OTA server Single gatekeeper model, full traceability Field Deployment Device pulls firmware via HTTP when configured Manual reboot required, automatic rollback protection 7.5.2. A/B Partition Management 7.6. Operational Procedures 7.6.1. Version Management and Auditability Aspect Implementation Benefits Version Identification Git tags and commit checksums embedded in firmware Precise traceability of deployed firmware versions Build Reproducibility Deterministic build process with version tagging Ability to rebuild exact firmware for debugging Release Documentation QA approval records linked to firmware versions Clear audit trail for all production releases Field Identification Device reports firmware version via management interface Support teams can identify deployed firmware versions 7.6.2. Rollback and Recovery Procedures Scenario Recovery Method Implementation Boot Failure Automatic rollback via watchdog timeout RP2350 ROM bootloader switches to backup partition Corrupted Download Signature verification failure Device rejects invalid firmware, retains current version Network Issues Download retry mechanism Device continues with current firmware, retries later Total Firmware Corruption Device replacement No field recovery possible when both partitions corrupted 7.6.3. Monitoring and Maintenance Monitoring Aspect Implementation Firmware Version Tracking Git checksums embedded in firmware, reported via management UI Update Success Rate Device reports successful updates to management interface Rollback Events Watchdog rollback events logged in device memory OTA Server Health HTTP availability monitoring for firmware distribution 7.7. Configuration Management 7.7.1. OTA Server Configuration The UART2ETH device supports flexible OTA server configuration: Default Server : Company-hosted cloud OTA server for standard deployments Customer Servers : Configurable OTA server URL via management interface HTTP Protocol : Simple HTTP-based firmware downloads (no HTTPS requirement) Pull-based Updates : Devices initiate update checks, no push capability 8. Cross-cutting Concepts 8.1. Protocol Filtering Protocol filtering provides a configurable mechanism to determine packet boundaries in UART data streams. The system implements pluggable filters that analyze incoming byte streams to identify complete data units for efficient TCP transmission. 8.1.1. Packet Determination Algorithm The protocol filter operates on incoming UART data to identify discrete packets using configurable delimiters and patterns: Basic Line-Based Filter Example Input stream: \"sensor1=23.5\\r\\ntemperature=18.2\\r\\nhumidity=65\\r\\n\" Delimiter: \"\\r\\n\" Output packets: - \"sensor1=23.5\" - \"temperature=18.2\" - \"humidity=65\" 8.1.2. Filter Types The system supports multiple filter implementations: Line-based filters : Use configurable line terminators (\\r\\n, \\n, \\r) Fixed-length filters : Extract packets of predetermined byte count Delimiter-based filters : Use custom byte sequences as packet boundaries Timeout-based filters : Form packets after configurable idle periods 8.1.3. Configuration Parameters Each UART channel supports independent filter configuration: Filter type selection Delimiter specification (for delimiter-based filters) Packet length (for fixed-length filters) Timeout values (for timeout-based filters) Maximum packet size limits 8.2. Web Management Interface The web management interface provides system configuration and monitoring through a responsive web UI. 8.2.1. Main Interface Mockup 8.2.2. Network Configuration Panel 8.2.3. Protocol Filter Configuration 8.2.4. System Monitoring Dashboard 8.2.5. OTA Update Interface 8.3. Error Handling Strategy 8.3.1. Hierarchical Error Management The system implements a three-tier error handling approach: Application Layer Errors * Protocol parsing failures * Configuration validation errors * User authentication failures Communication Layer Errors * UART framing/parity errors * TCP connection failures * Network timeout conditions System Layer Errors * Memory allocation failures * Hardware malfunction detection * Critical system resource exhaustion 8.3.2. Error Recovery Mechanisms Each error category implements specific recovery procedures: Graceful degradation : Non-critical failures maintain partial functionality Automatic retry : Transient errors trigger configurable retry attempts Failover switching : Critical component failures activate backup systems User notification : All error conditions generate appropriate user feedback 8.4. Security Architecture 8.4.1. Authentication and Authorization Multi-level Access Control * Administrator: Full system configuration access * Operator: Monitoring and basic configuration changes * Guest: Read-only monitoring access Session Management * Token-based authentication with configurable expiry * Automatic session timeout after inactivity * Concurrent session limits per user role 8.4.2. Data Protection Network Security * Configurable firewall rules per UART channel * Rate limiting for TCP connections * Intrusion detection for unusual traffic patterns 8.5. Configuration Management 8.5.1. Persistent Storage Configuration data persistence uses JSON format with schema validation: System settings (network, users, security) UART channel configurations (baud rate, protocol filters) Performance tuning parameters Historical statistics and logs 8.5.2. Backup and Restore Automatic Backups * Daily configuration snapshots * Pre-update system state capture * Critical setting change tracking Manual Operations * Configuration export/import via web interface * Factory reset with selective data preservation * Remote backup to external storage systems 8.6. Performance Optimization 8.6.1. Buffer Management Dynamic Buffer Allocation * Adaptive buffer sizes based on data flow patterns * Memory pool management for high-frequency allocations * Garbage collection for unused buffer segments Flow Control * Back-pressure mechanisms for overloaded channels * Priority queuing for different data types * Load balancing across multiple TCP connections 8.6.2. Monitoring and Metrics Real-time Performance Tracking * Throughput measurements per UART channel * Latency monitoring for end-to-end data flow * Resource utilization (CPU, memory, network) Historical Analysis * Trend analysis for capacity planning * Performance regression detection * Automated alerting for threshold violations 9. Architecture Decisions This section references the Architecture Decision Records (ADRs) that document key technical decisions for the UART2ETH project. These decisions form the foundation of the system architecture and significantly influence capabilities, performance characteristics, and development approach. 9.1. Hardware Platform Decisions ADR-001: Microcontroller Platform Selection - Documents the decision to use the Raspberry Pi RP2350 as the core microcontroller platform. ADR-002: Ethernet Controller Selection - Documents the decision to use the ENC28J60 as the Ethernet controller. 9.2. Software Platform Decisions ADR-003: Programming Language Selection - Documents the decision to use C programming language for firmware development, considering team expertise, delivery timeline, and memory model constraints. ADR-004: Development Ecosystem Selection - Documents the decision to use Native Pico SDK + CMake development ecosystem for professional, industrial-grade development. 9.3. Implementation Strategy Decisions ADR-005: Ring Buffer Memory Allocation Strategy - Documents the decision to use static worst-case allocation for inter-core communication buffers, prioritizing reliability and determinism over memory efficiency. 9.4. Decision Interdependencies The ADRs reveal important interdependencies that influence architectural coherence: ADR-004 (Development Ecosystem) challenges ADR-002 (Ethernet Controller) : The ecosystem analysis revealed that ENC28J60 lacks mature RP2350 SDK integration, potentially requiring significant custom development effort and impacting industrial reliability goals. ADR-003 (C Language) reinforces ADR-004 (Native SDK) : The choice of C programming language aligns optimally with the Native Pico SDK approach, enabling direct application of team expertise. ADR-005 (Buffer Strategy) supports ADR-003 (C Language) : Static allocation strategy leverages C&#8217;s deterministic memory model and supports industrial reliability requirements. 10. Quality Requirements 10.1. Quality Tree The quality tree organizes our quality requirements hierarchically, derived from stakeholder expectations and our industrial embedded systems context. Priority levels reflect architectural significance and business impact. Priority Levels: Critical (1) : System failure without this quality - business showstopper High (2) : Essential for reliable operation and long-term maintenance High (3) : Significant impact on user satisfaction and adoption Important (4) : Affects usability, deployment efficiency, and operational monitoring Medium (5) : Enhances user experience and compatibility but system functional without them Desired (6) : Nice-to-have features for future releases and enhanced security Resource and Performance Context: Platform : RP2350 dual-core ARM Cortex-M33 at 150MHz, 520KB SRAM, 4MB Flash Network : ENC28J60 10BASE-T Ethernet controller via SPI Expected Load : Up to 4 concurrent UART channels at combined 500kBaud maximum throughput 10.2. Quality Scenarios 10.2.1. Reliability Requirements (Priority 1 - Critical) Scenario R1: Industrial Continuous Operation Quality Attribute Reliability Context Manufacturing environment with 24/7 operation during normal environmental conditions (temperature, humidity, power within specifications) Stimulus UART2ETH device deployed in production line handling PLC communication Response System maintains continuous operation without software-induced failure Response Measure 99.99% uptime during scheduled production hours (876 hours/year), maximum 0.876 hours downtime annually due to software issues Priority Critical (1) Rationale Manufacturing downtime costs thousands per minute; industrial systems require exceptional reliability for business viability Verification Extended operation testing for 100+ continuous hours with simulated industrial traffic patterns, watchdog timer validation, memory leak detection tools Scenario R2: Hardware Component Failure Recovery Quality Attribute Reliability Context Production deployment with active UART and network connections Stimulus Single hardware component failure (e.g., ENC28J60 controller malfunction) Response System logs error with timestamp and component identifier, maintains UART data buffering, activates error LED with specific blink pattern, continues UART processing while disabling affected network functions Response Measure Failure detection within 100ms, no data corruption in ring buffer, error LED pattern visible, automatic recovery within 2 seconds when component functionality restored Priority Critical (1) Rationale Hardware failures are inevitable; system must handle them gracefully to maintain industrial reliability standards Verification Fault injection testing using SPI line manipulation and network disconnection. Verified with oscilloscope timing measurements and data integrity checksums Scenario R3: Power Cycle Recovery Quality Attribute Reliability Context Industrial environment with occasional power fluctuations or maintenance shutdowns Stimulus Unexpected power loss followed by power restoration Response System restarts cleanly, restores previous configuration, resumes operation without manual intervention Response Measure Full operational restart within 10 seconds, 100% configuration preservation, automatic reconnection from previous TCP clients within 15 seconds Priority Critical (1) Rationale Power interruptions are common in industrial settings; system must resume operation automatically to avoid service calls Scenario R4: Memory Exhaustion Protection Quality Attribute Reliability Context High-throughput operation with all 4 UARTs active at maximum baud rates Stimulus Ring buffer approaches capacity due to traffic burst or consumer processing delays Response System applies drop-oldest policy deterministically, continues operation without crash or memory leak Response Measure No system crash under any traffic conditions, maximum 5% packet loss during extreme bursts (&gt;150% of sustained capacity), recovery to normal operation within 1 second after burst ends Priority Critical (1) Rationale Static memory architecture must handle overload gracefully; crashes are unacceptable in industrial applications Verification Traffic generation testing at 200% rated capacity for 30 minutes, memory usage monitoring, packet loss measurement with statistical analysis 10.2.2. Performance Requirements (Mixed Priority: High/Important) Scenario P1: Real-time Industrial Control Latency Quality Attribute Performance Context PLC communicating time-critical control data to SCADA system via UART2ETH bridge Stimulus PLC sends control command that must reach SCADA system with minimal delay Response Data transmitted through UART‚ÜíRing Buffer‚ÜíTCP path with optimized processing Response Measure End-to-end latency &lt;5ms for 95% of packets under normal load (up to 300kBaud sustained across all channels) Priority High (3) Rationale Industrial control loops require predictable, low latency to maintain process stability and safety Verification Measured using hardware timestamp injection at UART TX and TCP packet capture analysis. Test with 10,000 message sequences under sustained 300kBaud load Scenario P2: Sustained High Throughput Quality Attribute Performance Context Data-intensive application requiring bulk data transfer (e.g., measurement data logging) Stimulus Continuous data stream at maximum specified throughput across multiple UART channels Response System maintains data flow without drops or significant queuing delays Response Measure Sustain 500kBaud combined throughput across all active channels for 8+ hour periods with &lt;0.1% packet loss Priority High (2) Rationale High-volume applications require consistent throughput to avoid data loss and maintain system efficiency Verification Automated throughput testing with UART traffic generators, network packet capture analysis, 24-hour continuous operation validation Scenario P3: Resource Utilization Under Load Quality Attribute Performance Context System operating at 80% of maximum specified capacity across CPU, memory, and network resources Stimulus Normal industrial traffic patterns with occasional bursts Response System maintains responsive operation with efficient resource usage Response Measure CPU utilization &lt;70%, memory usage &lt;80% of available RAM, network buffer utilization &lt;60% during normal operation Priority Important (4) Rationale Efficient resource usage ensures headroom for traffic spikes and maintains system responsiveness Scenario P4: Network Congestion Handling Quality Attribute Performance Context Network infrastructure experiencing intermittent congestion or high latency Stimulus TCP connection experiences delays or temporary packet loss Response System adapts transmission patterns while maintaining UART data flow integrity Response Measure Automatic TCP retry within 50ms, UART data buffering up to 2 seconds during network issues, no UART data loss during network recovery Priority High (2) Rationale Network infrastructure issues are common; system must adapt while protecting serial data integrity 10.2.3. Security Requirements (Mixed Priority: Critical/Important/Desired) Scenario S1: Unauthorized Network Access Prevention Quality Attribute Security Context UART2ETH deployed in production network with potential access from unauthorized devices Stimulus Unauthorized device attempts TCP connection to UART bridge ports (4001-4004) Response System validates connection using IP whitelist and optional TLS client certificate authentication, rejects unauthorized connections with RST packet, logs security events with ISO 8601 timestamp and source details to encrypted flash storage Response Measure 100% of unauthorized connection attempts blocked within 10ms, zero false positives for whitelisted IPs, security events logged with integrity protection, system remains operational during connection flood attacks (up to 1000 attempts/second) Priority Desired (6) Rationale Industrial networks require protection against unauthorized access to prevent data interception and system manipulation Verification OWASP-based penetration testing with unauthorized IP addresses, automated port scanning from external networks, TLS certificate validation testing, connection flood testing with 1000+ concurrent attempts Scenario S2: Firmware Integrity Validation Quality Attribute Security Context OTA firmware update process or system boot sequence with secure boot enabled Stimulus System receives firmware image or boots from flash memory Response System validates cryptographic signature using embedded public key, verifies SHA-256 image hash, implements secure boot chain from RP2350 ROM, validates firmware version to prevent rollback attacks, rejects invalid firmware Response Measure 100% signature validation before execution using, invalid firmware rejected within 500ms, automatic rollback to previous version if post-update health check fails within 15 seconds, firmware version monotonically increasing Priority Critical (1) Rationale Firmware integrity ensures system operates only trusted code, preventing malicious modifications in industrial environments Verification Test with tampered firmware images using invalid signatures, downgrade attack testing with older firmware versions, signature validation timing measurements on RP2350 hardware, secure boot chain validation, rollback procedure validation Scenario S3: Configuration Data Protection Quality Attribute Security Context Device configuration contains network credentials and operational parameters Stimulus Power cycle, configuration backup Response System validates configuration integrity with HMAC-SHA256, keeps 2 copies configuration, uses monotonic revision counter to keep track of latest vaild revision Response Measure Configuration tampering or corruption detected with HMAC-SHA256 validation triggering rollback to latest valid version Priority Critical (1) Rationale Configuration data must not be corrupted Verification Flash memory hexdump analysis to verify HMAC-SHA256 and revision counter, configuration integrity validation after power cycles, forced corruption to verify configuration rollback Scenario S4: Communication Security Quality Attribute Security Context UART data transmitted over TCP connections in potentially untrusted network environments Stimulus Sensitive industrial data (PLC commands, sensor readings) transmitted between UART devices and network clients Response System provides optional TLS 1.3 encryption for TCP connections with industrial-grade cipher suites, maintains data integrity during transmission, implements connection authentication Response Measure TLS 1.3 available for all TCP connections, &lt;10ms additional latency for TLS handshake, 100% data integrity verification using TLS record layer, certificate-based client authentication supported Priority Desired (6) Rationale Industrial data may contain sensitive process information requiring protection during network transmission Verification Network packet capture analysis to verify TLS encryption, latency measurement with TLS enabled/disabled, certificate validation testing, man-in-the-middle attack testing Scenario S5: Security Event Logging and Monitoring Quality Attribute Security Context Industrial environment requiring audit trails and security incident detection Stimulus Security events including authentication failures, unauthorized access attempts, configuration changes, firmware updates Response System logs all security events to encrypted flash storage with tamper-evident integrity protection, provides secure export capability, maintains event timestamps with NTP synchronization Response Measure 100% of events logged with ISO 8601 timestamps, log integrity protected with HMAC-SHA256, encrypted log storage using device-unique keys, log retention for 1000 events, log export via HTTP Web UI Priority Important (4) Rationale Industrial systems require comprehensive audit trails for compliance and security incident investigation Verification Security event generation testing, log integrity validation, encrypted storage verification, timestamp accuracy testing, log export functionality testing 10.2.4. Compatibility Requirements (Mixed Priority: Critical/Medium) Scenario C1: Diverse Industrial Protocol Support Quality Attribute Compatibility Context System integrator deploying UART2ETH with various industrial equipment (PLCs, sensors, measurement devices) Stimulus Configuration requests for non-standard baud rates, unusual frame formats, or custom protocol timing Response System accepts and maintains stable communication with diverse protocol requirements Response Measure Support for baud rates 300-500000, all standard frame formats (5-8 data bits, 1-2 stop bits, none/odd/even parity), stable operation with 99.9% of industrial serial devices Priority Medium (5) Rationale Industrial environments contain diverse legacy equipment; broad compatibility enables market adoption and reduces integration effort Verification Protocol compliance testing with representative industrial devices (PLCs from 3+ vendors, measurement instruments), baud rate accuracy measurement with oscilloscope Scenario C2: Network Infrastructure Integration Quality Attribute Compatibility Context Deployment in existing network infrastructure with various switches, routers, and network management systems Stimulus Connection to different network environments (managed switches, VLANs, different subnet configurations) Response System auto-negotiates network parameters and maintains stable operation Response Measure Successful auto-negotiation with 95% of standard Ethernet infrastructure, stable operation across different network topologies, DHCP and static IP support Priority Critical (1) Rationale Network environments vary significantly between sites; automatic adaptation reduces deployment complexity and support costs Scenario C3: SCADA System Integration Quality Attribute Compatibility Context Integration with existing SCADA/HMI systems from various vendors Stimulus SCADA system establishes TCP connection with specific protocol expectations or timing requirements Response System provides transparent TCP socket interface compatible with SCADA expectations Response Measure Successful integration with 90% of common SCADA systems, transparent protocol forwarding without modification, support for multiple simultaneous connections per UART Priority Medium (5) Rationale SCADA integration is primary use case; broad compatibility ensures market viability and reduces customer integration effort 10.2.5. Usability Requirements (Mixed Priority: Important/Medium) Scenario U1: Field Technician Deployment Quality Attribute Usability Context Field technician with basic networking knowledge deploying device in industrial facility Stimulus Technician needs to configure device for first-time operation Response System provides intuitive configuration interface with clear guidance and validation Response Measure Complete basic configuration (IP settings, UART parameters, port mapping) within 15 minutes by technician with minimal training, configuration errors caught with helpful error messages Priority Important (4) Rationale Simple deployment reduces installation time, training costs, and field support requirements Scenario U2: Troubleshooting and Diagnostics Quality Attribute Usability Context System experiencing communication issues in production environment Stimulus Field technician or system integrator needs to diagnose and resolve connectivity problems Response System provides clear diagnostic information and status indicators Response Measure Problem identification within 5 minutes using web interface diagnostics, LED status indicators visible from 2 meters, error messages identify specific issue and suggest resolution steps Priority Medium (5) Rationale Clear diagnostics reduce troubleshooting time, minimize production downtime, and reduce support costs Scenario U3: Configuration Management Quality Attribute Usability Context System integrator managing multiple UART2ETH devices across different sites Stimulus Need to backup, restore, or replicate device configurations Response System provides configuration export/import functionality with validation Response Measure Complete configuration backup/restore within 2 minutes, configuration file validation with clear error reporting, bulk configuration deployment to multiple devices Priority Medium (5) Rationale Configuration management reduces deployment time for multiple devices and simplifies maintenance procedures 10.2.6. Maintainability Requirements (Mixed Priority: Critical/High/Desired) Scenario M1: Secure Over-the-Air Updates Quality Attribute Maintainability Context Deployed devices requiring firmware update for bug fixes or feature enhancements Stimulus Administrator initiates OTA update from management server Response System securely downloads, validates, and applies firmware update with automatic rollback on failure Response Measure Update completion within 10 minutes, 100% signature validation, automatic rollback within 2 minutes if update fails, zero configuration loss during successful updates Priority High (2) Rationale Field updates are essential for long-term maintenance; secure OTA capability reduces service costs and improves security posture Verification OTA update testing with valid/invalid signatures, network interruption during update, rollback timing measurement, configuration persistence validation Scenario M2: A/B Partition Rollback Quality Attribute Maintainability Context Recently updated device experiencing issues with new firmware version Stimulus Automatic rollback trigger due to system health check failure or manual rollback command Response System switches to previous firmware version and restores operation Response Measure Rollback completion within 30 seconds, 100% restoration of previous functionality, all user configurations preserved during rollback process Priority Critical (1) Rationale Rollback capability ensures update safety and reduces risk of system unavailability due to problematic firmware Scenario M3: Development and Testing Support Quality Attribute Maintainability Context Development team implementing new features or debugging reported issues Stimulus Developer needs to analyze system behavior or verify fix implementation Response System provides comprehensive debugging interfaces and test capabilities Response Measure Debug interface access within 30 seconds, comprehensive logging of system events, test mode operation without affecting production traffic Priority Desired (6) Rationale Development efficiency directly impacts time-to-market and bug resolution speed, affecting overall product quality 10.3. Quality Scenarios Integration 10.3.1. Architectural Decision Impact These quality scenarios directly influence key architectural decisions documented in our ADRs: Hardware Platform Decisions: - Reliability Scenarios R1-R4 ‚Üí ADR-001: RP2350 Selection provides dual-core architecture for fault isolation - Performance Scenarios P1-P2 ‚Üí Static memory allocation strategy eliminates runtime allocation failures Software Architecture Decisions: - Performance Scenarios P1-P4 ‚Üí ADR-003: C Language Selection enables deterministic, real-time behavior - Reliability Scenarios R2-R4 ‚Üí Ring buffer design with drop-oldest policy provides predictable overload behavior Network Architecture Decisions: - Compatibility Scenarios C1-C3 ‚Üí ENC28J60 selection with software TCP/IP stack enables full protocol control and auditability 10.3.2. Testing and Validation Framework Each quality scenario translates directly into test cases: Reliability Testing: - Extended operation testing (1000+ hours) to validate R1 - Fault injection testing for hardware failure scenarios (R2) - Power cycle testing with configuration persistence validation (R3) - Memory stress testing with overload conditions (R4) Performance Testing: - Real-time latency measurement under various loads (P1) - Sustained throughput testing for extended periods (P2) - Resource monitoring during peak operations (P3) - Network resilience testing with simulated congestion (P4) Compatibility Testing: - Protocol compliance testing with diverse industrial equipment (C1) - Network infrastructure compatibility testing (C2) - SCADA system integration testing (C3) Usability Testing: - Field deployment simulation with time measurements (U1) - Diagnostic effectiveness testing with problem scenarios (U2) - Configuration management workflow testing (U3) Maintainability Testing: - OTA update testing with various failure scenarios (M1) - A/B rollback testing with timing and data integrity validation (M2) - Development workflow testing and debugging interface validation (M3) 10.4. Quality Scenario Priority Matrix The following table summarizes all quality scenarios by priority level: Priority Scenario ID Scenario Name Key Metric Critical (1) R1, R2, R3, R4, S2, S3, C2, M2 Industrial Operation, Hardware Failure, Power Recovery, Memory Protection, Firmware Integrity, Configuration Protection, Network Integration, A/B Rollback 99.99% uptime, &lt;100ms failure detection, 100% signature validation, automatic network compatibility High (2) P2, P4, M1 High Throughput, Network Congestion Handling, OTA Updates 500kBaud sustained throughput, &lt;10min OTA updates, network resilience High (3) P1 Real-time Industrial Control Latency &lt;5ms latency for 95% of packets Important (4) P3, S5, U1 Resource Utilization, Security Logging, Field Deployment &lt;70% CPU utilization, comprehensive audit trails, &lt;15min deployment Medium (5) C1, C3, U2, U3 Protocol Support, SCADA Integration, Diagnostics, Configuration Management 99.9% device compatibility, &lt;5min troubleshooting, configuration backup/restore Desired (6) S1, S4, M3 Network Access Control, Communication Security, Development Support TLS 1.3 encryption, unauthorized access blocking, debug interface access 10.5. Quality Requirements Summary The quality scenarios establish measurable success criteria that guide both architectural decisions and validation approaches. Critical scenarios represent non-negotiable requirements where system failure would render the product unsuitable for industrial deployment. High priority scenarios significantly impact user satisfaction and market adoption. Lower priority scenarios enhance user experience and reduce operational costs. 10.6. Security-Industrial Operation Balance Industrial systems require a careful balance between security measures and operational requirements: Security vs. Availability Trade-offs: - Security features (authentication, encryption) must not compromise the 99.99% uptime requirement - TLS encryption adds &lt;10ms latency, acceptable for industrial control loops - Security event logging uses &lt;1% of flash storage, preserving system resources Platform-Specific Security Considerations: - RP2350 hardware security features (secure boot, unique device ID) integrated into security architecture - Lightweight cryptographic algorithms chosen to minimize CPU overhead (&lt;5% utilization) - Static memory allocation prevents security-related memory leaks - Hardware random number generator used for cryptographic operations Fail-Safe Security Principles: - Security failures default to secure state (deny access, maintain logging) - Industrial operation continues during security incidents where possible - Critical security events trigger controlled degradation, not system shutdown - Recovery procedures restore both security and operational functionality These scenarios serve as the foundation for: - Architecture decision evaluation criteria - Test case development and acceptance criteria - Performance benchmarking and validation - Stakeholder communication about quality expectations - Risk assessment and mitigation planning - Security-operational trade-off analysis 11. Risks and Technical Debts 11.1. Risk Overview Risk ID Risk Title Category Probability Impact Risk Level R-001 ENC28J60 Ecosystem Maturity Technical High High CRITICAL R-002 UART Hardware Resource Conflicts Technical High Medium HIGH R-003 No TLS/HTTPS Security Implementation Technical Medium High HIGH R-004 No UART Flow Control Implementation Technical High Medium HIGH R-005 Single Developer Knowledge Dependencies Organizational Medium High HIGH R-006 RP2350 Platform Learning Curve Organizational Medium Medium MEDIUM R-007 Component Supply Chain Availability External Low High MEDIUM R-008 Industrial Performance Requirements Business Medium High HIGH 11.2. Detailed Risk Analysis 11.2.1. R-001: ENC28J60 Ecosystem Maturity Risk Category Technical Description ENC28J60 ethernet controller lacks mature RP2350 SDK integration, requiring significant custom development effort and potentially impacting industrial reliability goals Probability High - No official RP2350 support exists, only individual open-source efforts Impact High - Could require months of custom lwIP integration development and create maintenance risks Risk Level CRITICAL Current Controls - Decision made to accept risk and proceed with ENC28J60 - Basic research completed on integration approaches - Alternative W5500 option identified Additional Mitigation - Allocate 2-4 weeks for custom integration development - Create fallback plan for W5500 migration if integration proves too complex - Establish contact with existing ENC28J60+RP2350 community projects Owner Senior Developer Timeline Early implementation phase (next 3 months) Early Warning Signs - Integration taking longer than 4 weeks - Stability issues with ethernet stack - Performance not meeting requirements Review Date Monthly during development 11.2.2. R-002: UART Hardware Resource Conflicts Category Technical Description RP2350 has limited UART resources: only 3 PIO UARTs available, 1 hardware UART conflicts with debug UART, other hardware UART used for SPI Probability High - Hardware limitations are fixed constraints Impact Medium - Limits system to 3 UARTs instead of advertised 4, affects product specification Risk Level HIGH Current Controls - Issue documented in technical debt register - PIO UART implementation planned Additional Mitigation - Redesign system for 3 UARTs maximum - Investigate debug UART alternatives (SWD-only debugging) - Consider external UART expansion via I2C Owner Hardware Lead Timeline Hardware design phase Early Warning Signs - Debug UART conflicts discovered during testing - PIO UART performance insufficient Review Date During hardware design finalization 11.2.3. R-003: No TLS/HTTPS Security Implementation Category Technical Description Current architecture does not include TLS/HTTPS support, creating security vulnerability for industrial applications Probability Medium - Not all deployments require TLS, but many industrial environments do Impact High - Could prevent deployment in security-conscious environments, data interception risk Risk Level HIGH Current Controls - Issue documented in technical debt register - TLS requirement identified for future implementation Additional Mitigation - Research mbedTLS integration with RP2350 - Plan TLS implementation for firmware v2.0 - Document security limitations clearly for v1.0 - Consider VPN-based security as interim solution Owner Security Lead Timeline Post-v1.0 release Early Warning Signs - Customer inquiries about TLS support - Security audit requirements emerge Review Date Quarterly 11.2.4. R-004: No UART Flow Control Implementation Category Technical Description UART implementation lacks hardware flow control (RTS/CTS), risking data loss under high throughput conditions Probability High - High-speed UART communication commonly requires flow control Impact Medium - Data loss possible, but software buffering may mitigate for many use cases Risk Level HIGH Current Controls - Issue documented in technical debt register - Software buffering strategy implemented Additional Mitigation - Implement XON/XOFF software flow control - Add hardware flow control pins to hardware design - Document flow control limitations clearly - Test thoroughly with high-speed protocols Owner Firmware Lead Timeline During UART implementation Early Warning Signs - Data loss observed during testing - Customer requirements include flow control Review Date During UART testing phase 11.2.5. R-005: Single Developer Knowledge Dependencies Category Organizational Description Critical project knowledge concentrated in individual team members, creating project continuity risk Probability Medium - Team changes can occur during project lifecycle Impact High - Could halt development if key person unavailable Risk Level HIGH Current Controls - Comprehensive arc42 documentation being created - ADR records document technical decisions Additional Mitigation - Implement pair programming for critical components - Create detailed technical documentation for all modules - Cross-train team members on RP2350 platform - Record design decision rationale thoroughly Owner Project Manager Timeline Throughout project Early Warning Signs - Key team member availability concerns - Knowledge gaps identified during reviews Review Date Monthly 11.2.6. R-006: RP2350 Platform Learning Curve Category Organizational Description Team unfamiliarity with RP2350-specific features (PIO, dual-core, security) may slow development Probability Medium - Team has embedded experience but not RP2350-specific Impact Medium - Could extend development timeline, suboptimal implementations Risk Level MEDIUM Current Controls - ADR-004 selected Native Pico SDK for best platform access - Team has strong C and embedded background Additional Mitigation - Allocate time for RP2350 training sessions - Create proof-of-concept implementations for key features - Engage with Raspberry Pi developer community - Study official examples and documentation Owner Technical Lead Timeline Early development phase Early Warning Signs - Development taking longer than estimated - Suboptimal use of platform features Review Date Bi-weekly during development 11.2.7. R-007: Component Supply Chain Availability Category External Description RP2350 and ENC28J60 component availability could be affected by supply chain disruptions Probability Low - Both components currently available from multiple suppliers Impact High - Could halt production if components unavailable Risk Level MEDIUM Current Controls - Multiple supplier sources identified - Components currently in stock at major distributors Additional Mitigation - Monitor component availability regularly - Establish relationships with multiple suppliers - Consider alternative component specifications (W5500 backup) - Plan component inventory for production runs Owner Supply Chain Manager Timeline Pre-production and production phases Early Warning Signs - Lead times extending beyond normal - Price increases indicating supply constraints Review Date Quarterly 11.2.8. R-008: Industrial Performance Requirements Category Business Description System may not meet industrial performance requirements (latency, throughput, reliability) under real-world conditions Probability Medium - Performance requirements are aggressive for embedded system Impact High - Could prevent adoption in target industrial applications Risk Level HIGH Current Controls - Quality requirements documented in Chapter 10 - Performance testing planned - Static allocation strategy chosen for predictability Additional Mitigation - Implement comprehensive performance testing framework - Test with realistic industrial data patterns - Monitor performance metrics continuously - Plan performance optimization iterations Owner Performance Engineer Timeline Testing and validation phases Early Warning Signs - Performance tests failing targets - Latency spikes under load Review Date Weekly during testing 11.3. Technical Debt Register The following technical debts have been identified and require future resolution: 11.3.1. TD-001: UART Flow Control Description: No hardware flow control implementation for UART interfaces Impact: Potential data loss under high throughput conditions Priority: High Effort: Medium (2-3 weeks) Resolution Plan: Implement XON/XOFF software flow control and add hardware pins in next revision 11.3.2. TD-002: TLS/HTTPS Security Description: No TLS/HTTPS security implementation for network communications Impact: Security vulnerability in industrial environments Priority: High Effort: High (4-6 weeks) Resolution Plan: Integrate mbedTLS library in firmware v2.0 11.3.3. TD-003: UART Resource Limitations Description: Only 3 UARTs available due to debug and SPI conflicts, not 4 as originally planned Impact: Product specification limitation Priority: Medium Effort: High (hardware redesign) Resolution Plan: Document limitation clearly, investigate external UART expansion options 11.4. Risk Mitigation Plan 11.4.1. Immediate Actions (Next 30 Days) &#10063; Allocate ENC28J60 integration development time (R-001) &#10063; Finalize UART hardware configuration to avoid conflicts (R-002) &#10063; Begin RP2350 platform training sessions (R-006) &#10063; Create detailed technical documentation templates (R-005) 11.4.2. Short-term Actions (Next 90 Days) &#10063; Complete ENC28J60 integration prototype (R-001) &#10063; Implement comprehensive performance testing (R-008) &#10063; Document security limitations and alternatives (R-003) &#10063; Establish component supplier relationships (R-007) 11.4.3. Long-term Actions (Next 6 Months) &#10063; Plan TLS implementation for v2.0 (R-003) &#10063; Evaluate hardware flow control addition (R-004) &#10063; Quarterly risk assessment reviews &#10063; Post-implementation risk validation 11.5. Risk Monitoring 11.5.1. Weekly Reviews Monitor ENC28J60 integration progress Review performance testing results Track component availability 11.5.2. Monthly Reviews Assess risk mitigation progress Identify new risks from development discoveries Update risk levels based on current status 11.5.3. Quarterly Reviews Complete comprehensive risk register review Validate mitigation effectiveness Update risk management process Review technical debt resolution progress 11.6. Risk Escalation Triggers Critical : ENC28J60 integration proves unfeasible High : Performance targets consistently missed Medium : Key team member unavailability Any : New risks emerge that threaten project success 12. Glossary Term Definition A/B Updates Dual partition firmware update strategy that maintains two separate flash memory partitions (A and B) containing different firmware versions. During updates, the new firmware is written to the inactive partition while the system continues running from the active partition. If the new firmware fails or becomes corrupted, the system can automatically rollback to the previous working version, ensuring system reliability and preventing brick situations in remote deployments. Arduino Open-source electronics platform consisting of both hardware boards (microcontroller development boards) and software (integrated development environment). Arduino provides a simplified programming framework with pre-built libraries and functions that abstract complex microcontroller operations, making embedded programming accessible to beginners while remaining powerful enough for professional applications. The Arduino ecosystem includes thousands of community-contributed libraries and shields (expansion boards). CI/CD Continuous Integration/Continuous Deployment - modern software development methodology that automates the building, testing, and deployment pipeline. CI automatically builds and tests code changes when developers commit to version control, catching integration issues early. CD extends this by automatically deploying tested code to production environments, reducing manual errors and enabling rapid, reliable software releases. Client System In Gateway Mode, the networked device or application that connects to UART2ETH via TCP sockets to communicate with legacy serial equipment. Client systems can be computers, servers, mobile devices, or other networked equipment that need to access serial devices remotely over Ethernet networks. Examples include monitoring software, configuration tools, or remote control applications. CMake Cross-platform, open-source build system generator that creates native build files (Makefiles, Visual Studio projects, Xcode projects) from platform-independent configuration files. CMake manages complex build dependencies, compiler flags, and linking requirements across different operating systems and compilers, simplifying the build process for C/C++ projects and enabling consistent builds across development teams. ENC28J60 Low-cost Ethernet controller chip from Microchip Technology that provides 10Base-T Ethernet connectivity via SPI interface. This single-chip solution includes MAC (Media Access Control) and PHY (Physical Layer) functions, making it popular for adding basic Ethernet capabilities to microcontroller projects. It requires external TCP/IP stack implementation and offers a cost-effective alternative to more integrated solutions. Full Bridge Mode UART2ETH operating mode that creates a transparent network bridge between two serial devices located at different physical locations. Both devices communicate through their UART interfaces as if they were directly connected with a serial cable, but the connection is actually routed through TCP/IP networks. This mode enables legacy serial equipment to communicate across long distances, through existing network infrastructure, without requiring protocol modifications. Gateway Mode UART2ETH operating mode that adds network connectivity to existing serial-only equipment without modifying the original device. The UART2ETH device acts as a protocol gateway, translating between the legacy device&#8217;s serial communication and modern TCP/IP networking. This allows multiple network clients to simultaneously access serial equipment, enabling remote monitoring, configuration, and control of industrial equipment, embedded systems, or test instruments. Host System The serial equipment or device connected to UART2ETH&#8217;s physical UART interface. In Gateway Mode, this is typically legacy industrial equipment, embedded systems, or test instruments that only support serial communication. In Full Bridge Mode, both endpoints are considered Host Systems. Host Systems are unaware of the network translation and continue using their native serial protocols. HW UART Hardware Universal Asynchronous Receiver-Transmitter - dedicated silicon circuitry within microcontrollers that handles serial communication at the hardware level. HW UARTs provide precise timing, automatic start/stop bit handling, parity checking, and interrupt generation without CPU intervention. This contrasts with software-based UART implementations that consume CPU cycles and may have timing limitations, especially at higher baud rates. Misra-c Motor Industry Software Reliability Association C - comprehensive coding standard that defines strict guidelines for writing safety-critical C code. MISRA-C rules cover language subset restrictions, coding practices, and documentation requirements designed to eliminate common programming errors, undefined behaviors, and implementation-defined constructs. Originally developed for automotive software, it&#8217;s now widely used in aerospace, medical devices, and industrial control systems. OTA (Over-The-Air) Remote firmware update mechanism that allows devices to receive and install new firmware through their existing communication channels (WiFi, Ethernet, cellular) without requiring physical access. OTA updates enable field devices to receive bug fixes, security patches, and feature updates remotely, reducing maintenance costs and enabling rapid deployment of improvements across device fleets. Critical for IoT devices in remote or inaccessible locations. PIO Programmable Input/Output - specialized hardware feature of the Raspberry Pi RP2350 microcontroller that provides highly flexible, real-time I/O processing independent of the main CPU cores. PIO consists of state machines that can execute custom assembly-like programs to handle precise timing requirements for protocols like WS2812 LEDs, custom serial formats, or parallel interfaces. Each PIO block can run multiple state machines simultaneously, enabling complex I/O operations without CPU intervention. PLC (Programmable Logic Controller) Industrial computer designed for automation of manufacturing processes, machinery control, and industrial monitoring systems. PLCs are ruggedized for harsh industrial environments and provide real-time control with deterministic response times. They typically use ladder logic programming and offer extensive I/O capabilities for sensors, actuators, and communication networks. Common in factory automation, process control, and building management systems. platformio Modern, open-source ecosystem for embedded and IoT development that provides unified tooling across multiple microcontroller platforms, frameworks, and boards. PlatformIO includes cross-platform IDE, library manager, unit testing framework, remote debugging capabilities, and continuous integration support. It abstracts away toolchain complexity while supporting hundreds of development boards and frameworks including Arduino, ESP-IDF, STM32, and many others. Protocol Filter Pluggable software component within UART2ETH that intelligently processes and optimizes serial data streams before TCP transmission. Protocol filters can implement packet framing, data compression, error correction, or protocol-specific optimizations to reduce network bandwidth, improve latency, or enhance reliability. Examples include buffering strategies for bulk data transfers, real-time filtering for control systems, or custom packet structures for specific industrial protocols. RPI RP2350 Second-generation microcontroller chip from Raspberry Pi Foundation featuring dual ARM Cortex-M33 cores running up to 150MHz, 520KB SRAM, advanced security features, and flexible I/O capabilities including PIO state machines. The RP2350 provides enhanced performance and security compared to the original RP2040, making it suitable for industrial applications requiring real-time processing, secure communications, and complex I/O handling. SCADA (Supervisory Control and Data Acquisition) Industrial control system architecture used for monitoring and controlling large-scale processes across multiple locations. SCADA systems collect data from remote sensors and equipment, provide centralized monitoring through human-machine interfaces (HMIs), and enable operators to control distributed processes. Common in utilities (power grids, water treatment), manufacturing, and transportation systems where real-time monitoring and control of geographically dispersed equipment is essential. SPI Ethernet Controller Ethernet controller chip that communicates with microcontrollers through the Serial Peripheral Interface (SPI) protocol rather than parallel buses. These controllers handle the complex Ethernet physical layer operations (signal encoding, collision detection, carrier sensing) while presenting a simple SPI interface to the host microcontroller. This approach reduces pin count requirements and simplifies PCB design while providing reliable network connectivity for embedded systems. SPI TCP/IP Controller Integrated circuit that implements the complete TCP/IP protocol stack in hardware and communicates with host microcontrollers via SPI interface. These chips handle all network protocol processing (IP, TCP, UDP, ARP, DHCP) independently, presenting socket-based APIs through SPI commands. This offloads complex network processing from the main microcontroller, simplifying firmware development and improving real-time performance for applications requiring both networking and real-time control. TCP Socket Network communication endpoint that provides reliable, ordered, and error-checked delivery of data streams between applications over IP networks. TCP sockets establish connections, handle flow control, retransmission of lost packets, and ensure data integrity through checksums and acknowledgments. Unlike UDP, TCP guarantees that data arrives in the correct order and without errors, making it essential for applications requiring reliable data transmission such as file transfers, web browsing, and industrial control protocols. UART (Universal Asynchronous Receiver-Transmitter) Serial communication protocol and hardware interface that transmits data character by character without requiring a shared clock signal between communicating devices. UART uses start and stop bits to frame each character, with configurable data bits (5-9), parity (none, even, odd), and stop bits (1, 1.5, 2). This asynchronous approach makes UART simple to implement and widely compatible, leading to its extensive use in embedded systems, industrial equipment, and debugging interfaces. UART2ETH Complete hardware and firmware solution that bridges between UART serial interfaces and TCP/IP Ethernet networks, supporting up to 4 simultaneous UART connections. The system provides bidirectional data translation, protocol filtering, secure OTA updates, and flexible operating modes (Gateway and Full Bridge) to enable legacy serial equipment integration with modern networks. Built on the RPI RP2350 platform with support for various Ethernet controller options. W5500 Fully integrated Ethernet controller from WIZnet that combines 10/100 Ethernet MAC, PHY, and a complete TCP/IP protocol stack in a single chip. The W5500 communicates with host microcontrollers via SPI and provides hardware-accelerated socket operations, automatic packet processing, and wake-on-LAN capabilities. Its integrated approach simplifies network integration for embedded systems by handling all low-level networking operations transparently, allowing developers to focus on application logic rather than network protocols. "
},

{
    "id": 19,
    "uri": "search.html",
    "menu": "-",
    "title": "search",
    "text": " Search Results "
},

{
    "id": 20,
    "uri": "lunrjsindex.html",
    "menu": "-",
    "title": "null",
    "text": " will be replaced by the index "
},

];
